<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Composite 1D Grids · NumericalEFT.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://numericaleft.github.io/NumericalEFT.jl/lib/compositegrids/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="NumericalEFT.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">NumericalEFT.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Module ReadMe</span><ul><li><a class="tocitem" href="../../readme/Lehmann/">Lehmann</a></li><li><a class="tocitem" href="../../readme/FeynmanDiagram/">FeynmanDiagram</a></li><li><a class="tocitem" href="../../readme/MCIntegration/">MCIntegration</a></li><li><a class="tocitem" href="../../readme/CompositeGrids/">CompositeGrids</a></li><li><a class="tocitem" href="../../readme/GreenFunc/">GreenFunc</a></li><li><a class="tocitem" href="../../readme/Atom/">Atom</a></li></ul></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../man/DLR/">Discrete Lehmann Representation</a></li><li><a class="tocitem" href="../../man/kernel/">Lehmann representation convention</a></li><li><a class="tocitem" href="../../man/MC/">Monte Carlo integrator</a></li><li><a class="tocitem" href="../../man/important_sampling/">Important Sampling</a></li></ul></li><li><span class="tocitem">API reference</span><ul><li><a class="tocitem" href="../Lehmann/">Discrete Lehmann representation</a></li><li><a class="tocitem" href="../Feynmandiagram/">Feynman Diagram</a></li><li><a class="tocitem" href="../MCintegration/">Monte Carlo Integrator</a></li><li class="is-active"><a class="tocitem" href>Composite 1D Grids</a><ul class="internal"><li><a class="tocitem" href="#Basic-Grids"><span>Basic Grids</span></a></li><li><a class="tocitem" href="#Composite-Grids"><span>Composite Grids</span></a></li><li><a class="tocitem" href="#Interpolation-and-Integration"><span>Interpolation and Integration</span></a></li></ul></li><li><a class="tocitem" href="../greenfunc/">Green&#39;s Function</a></li><li><a class="tocitem" href="../atom/">Atom</a></li><li><a class="tocitem" href="../utility/">Utility</a></li><li><a class="tocitem" href="../fastmath/">Fast Math Functions</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API reference</a></li><li class="is-active"><a href>Composite 1D Grids</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Composite 1D Grids</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/numericalEFT/NumericalEFT.jl/blob/master/docs/src/lib/compositegrids.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Composite-1D-Grids"><a class="docs-heading-anchor" href="#Composite-1D-Grids">Composite 1D Grids</a><a id="Composite-1D-Grids-1"></a><a class="docs-heading-anchor-permalink" href="#Composite-1D-Grids" title="Permalink"></a></h1><h2 id="Basic-Grids"><a class="docs-heading-anchor" href="#Basic-Grids">Basic Grids</a><a id="Basic-Grids-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Grids" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="NumericalEFT.CompositeGrids.SimpleG" href="#NumericalEFT.CompositeGrids.SimpleG"><code>NumericalEFT.CompositeGrids.SimpleG</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Basic grids including common grids like arbitrary grids, uniform grids, log grids, and optimized grids like barycheb for interpolation and gausslegendre for integration.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numericalEFT/NumericalEFT.jl/blob/833b1b89245a4763d29836df15be517072fd35ad/src/CompositeGrids/grid/simple.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NumericalEFT.CompositeGrids.SimpleG.AbstractGrid" href="#NumericalEFT.CompositeGrids.SimpleG.AbstractGrid"><code>NumericalEFT.CompositeGrids.SimpleG.AbstractGrid</code></a> — <span class="docstring-category">Type</span></header><section><div><p>All Grids are derived from AbstractGrid; ClosedGrid has bound[1], bound[2] == grid[1], grid[end], while OpenGrid has bound[1]&lt;grid[1]&lt;grid[end]&lt;bound[2]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numericalEFT/NumericalEFT.jl/blob/833b1b89245a4763d29836df15be517072fd35ad/src/CompositeGrids/grid/simple.jl#L15-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NumericalEFT.CompositeGrids.SimpleG.Arbitrary" href="#NumericalEFT.CompositeGrids.SimpleG.Arbitrary"><code>NumericalEFT.CompositeGrids.SimpleG.Arbitrary</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Arbitrary{T&lt;:AbstractFloat} &lt;: ClosedGrid</code></pre><p>Arbitrary grid generated from given sorted grid.</p><p>#Members:</p><ul><li><code>bound</code> : boundary of the grid</li><li><code>size</code> : number of grid points</li><li><code>grid</code> : grid points</li><li><code>weight</code> : integration weight</li></ul><p>#Constructor:</p><ul><li>function Arbitrary{T}(grid) where {T&lt;:AbstractFloat}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numericalEFT/NumericalEFT.jl/blob/833b1b89245a4763d29836df15be517072fd35ad/src/CompositeGrids/grid/simple.jl#L23-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NumericalEFT.CompositeGrids.SimpleG.BaryCheb" href="#NumericalEFT.CompositeGrids.SimpleG.BaryCheb"><code>NumericalEFT.CompositeGrids.SimpleG.BaryCheb</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct BaryCheb{T&lt;:AbstractFloat} &lt;: OpenGrid</code></pre><p>BaryCheb grid generated on [bound[1], bound[2]] with order N.</p><p>#Members:</p><ul><li><code>bound</code> : boundary of the grid</li><li><code>size</code> : number of grid points</li><li><code>grid</code> : grid points</li><li><code>weight</code> : interpolation weight</li></ul><p>#Constructor:</p><ul><li>function BaryCheb{T}(bound, size) where {T&lt;:AbstractFloat}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numericalEFT/NumericalEFT.jl/blob/833b1b89245a4763d29836df15be517072fd35ad/src/CompositeGrids/grid/simple.jl#L161-L174">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NumericalEFT.CompositeGrids.SimpleG.GaussLegendre" href="#NumericalEFT.CompositeGrids.SimpleG.GaussLegendre"><code>NumericalEFT.CompositeGrids.SimpleG.GaussLegendre</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct GaussLegendre{T&lt;:AbstractFloat} &lt;: OpenGrid</code></pre><p>GaussLegendre grid generated on [bound[1], bound[2]] with order N.</p><p>#Members:</p><ul><li><code>bound</code> : boundary of the grid</li><li><code>size</code> : number of grid points</li><li><code>grid</code> : grid points</li><li><code>weight</code> : integration weight</li></ul><p>#Constructor:</p><ul><li>function GaussLegendre{T}(bound, size) where {T&lt;:AbstractFloat}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numericalEFT/NumericalEFT.jl/blob/833b1b89245a4763d29836df15be517072fd35ad/src/CompositeGrids/grid/simple.jl#L209-L222">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NumericalEFT.CompositeGrids.SimpleG.Log" href="#NumericalEFT.CompositeGrids.SimpleG.Log"><code>NumericalEFT.CompositeGrids.SimpleG.Log</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Log{T&lt;:AbstractFloat} &lt;: ClosedGrid</code></pre><p>Log grid generated on [bound[1], bound[2]] with N grid points. Minimal interval is set to be minterval. Dense to sparse if d2s, vice versa.</p><p>On [0, 1], a typical d2s Log grid looks like [0, λ^(N-1), ..., λ^2, λ, 1].</p><p>#Members:</p><ul><li><p><code>bound</code> : boundary of the grid</p></li><li><p><code>size</code> : number of grid points</p></li><li><p><code>grid</code> : grid points</p></li><li><p><code>weight</code> : integration weight</p></li><li><p><code>λ</code> : scale parameter</p></li><li><p><code>d2s</code> : dense to sparse or not</p></li></ul><p>#Constructor:</p><ul><li>function Log{T}(bound, size, minterval, d2s) where {T&lt;:AbstractFloat}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numericalEFT/NumericalEFT.jl/blob/833b1b89245a4763d29836df15be517072fd35ad/src/CompositeGrids/grid/simple.jl#L246-L266">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NumericalEFT.CompositeGrids.SimpleG.Uniform" href="#NumericalEFT.CompositeGrids.SimpleG.Uniform"><code>NumericalEFT.CompositeGrids.SimpleG.Uniform</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Uniform{T&lt;:AbstractFloat} &lt;: ClosedGrid</code></pre><p>Uniform grid generated on [bound[1], bound[2]] with N points</p><p>#Members:</p><ul><li><code>bound</code> : boundary of the grid</li><li><code>size</code> : number of grid points</li><li><code>grid</code> : grid points</li><li><code>weight</code> : integration weight</li></ul><p>#Constructor:</p><ul><li>function Uniform{T}(bound, size) where {T&lt;:AbstractFloat}</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numericalEFT/NumericalEFT.jl/blob/833b1b89245a4763d29836df15be517072fd35ad/src/CompositeGrids/grid/simple.jl#L98-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.floor-Tuple{NumericalEFT.CompositeGrids.SimpleG.AbstractGrid, Any}" href="#Base.floor-Tuple{NumericalEFT.CompositeGrids.SimpleG.AbstractGrid, Any}"><code>Base.floor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function Base.floor(grid::AbstractGrid, x) #where {T}</code></pre><p>use basic searchsorted function to find the index of largest grid point smaller than x.</p><p>return 1 for x&lt;grid[1] and grid.size-1 for x&gt;grid[end].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numericalEFT/NumericalEFT.jl/blob/833b1b89245a4763d29836df15be517072fd35ad/src/CompositeGrids/grid/simple.jl#L66-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.floor-Union{Tuple{T}, Tuple{NumericalEFT.CompositeGrids.SimpleG.Log{T}, Any}} where T" href="#Base.floor-Union{Tuple{T}, Tuple{NumericalEFT.CompositeGrids.SimpleG.Log{T}, Any}} where T"><code>Base.floor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function Base.floor(grid::Log{T}, x) where {T}</code></pre><p>find the index of largest grid point smaller than x.</p><p>return 1 for x&lt;grid[1] and grid.size-1 for x&gt;grid[end].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numericalEFT/NumericalEFT.jl/blob/833b1b89245a4763d29836df15be517072fd35ad/src/CompositeGrids/grid/simple.jl#L313-L320">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.floor-Union{Tuple{T}, Tuple{NumericalEFT.CompositeGrids.SimpleG.Uniform{T}, Any}} where T" href="#Base.floor-Union{Tuple{T}, Tuple{NumericalEFT.CompositeGrids.SimpleG.Uniform{T}, Any}} where T"><code>Base.floor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function Base.floor(grid::Uniform{T}, x) where {T}</code></pre><p>find the index of largest grid point smaller than x.</p><p>return 1 for x&lt;grid[1] and grid.size-1 for x&gt;grid[end].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numericalEFT/NumericalEFT.jl/blob/833b1b89245a4763d29836df15be517072fd35ad/src/CompositeGrids/grid/simple.jl#L141-L148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NumericalEFT.CompositeGrids.SimpleG.barycheb-NTuple{5, Any}" href="#NumericalEFT.CompositeGrids.SimpleG.barycheb-NTuple{5, Any}"><code>NumericalEFT.CompositeGrids.SimpleG.barycheb</code></a> — <span class="docstring-category">Method</span></header><section><div><p>function barycheb(n, x, f, wc, xc)</p><p>Barycentric Lagrange interpolation at Chebyshev nodes Reference: Berrut, J.P. and Trefethen, L.N., 2004. Barycentric lagrange interpolation. SIAM review, 46(3), pp.501-517.</p><p><strong>Arguments</strong></p><ul><li><code>n</code>: order of the Chebyshev interpolation</li><li><code>x</code>: coordinate to interpolate</li><li><code>f</code>: array of size n, function at the Chebyshev nodes</li><li><code>wc</code>: array of size n, Barycentric Lagrange interpolation weights</li><li><code>xc</code>: array of size n, coordinates of Chebyshev nodes</li></ul><p><strong>Returns</strong></p><ul><li>Interpolation result</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numericalEFT/NumericalEFT.jl/blob/833b1b89245a4763d29836df15be517072fd35ad/src/CompositeGrids/grid/chebyshev.jl#L80-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NumericalEFT.CompositeGrids.SimpleG.barychebinit-Tuple{Any}" href="#NumericalEFT.CompositeGrids.SimpleG.barychebinit-Tuple{Any}"><code>NumericalEFT.CompositeGrids.SimpleG.barychebinit</code></a> — <span class="docstring-category">Method</span></header><section><div><p>barychebinit(n)</p><p>Get Chebyshev nodes of first kind and corresponding barycentric Lagrange interpolation weights.  Reference: Berrut, J.P. and Trefethen, L.N., 2004. Barycentric lagrange interpolation. SIAM review, 46(3), pp.501-517.</p><p><strong>Arguments</strong></p><ul><li><code>n</code>: order of the Chebyshev interpolation</li></ul><p><strong>Returns</strong></p><ul><li>Chebyshev nodes</li><li>Barycentric Lagrange interpolation weights</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numericalEFT/NumericalEFT.jl/blob/833b1b89245a4763d29836df15be517072fd35ad/src/CompositeGrids/grid/chebyshev.jl#L1-L13">source</a></section></article><h2 id="Composite-Grids"><a class="docs-heading-anchor" href="#Composite-Grids">Composite Grids</a><a id="Composite-Grids-1"></a><a class="docs-heading-anchor-permalink" href="#Composite-Grids" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="NumericalEFT.CompositeGrids.CompositeG" href="#NumericalEFT.CompositeGrids.CompositeG"><code>NumericalEFT.CompositeGrids.CompositeG</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Composite grid that has tree structure. The whole interval is first divided by a panel grid, then each interval of a panel grid is divided by a smaller grid in subgrids. Subgrid could also be composite grid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numericalEFT/NumericalEFT.jl/blob/833b1b89245a4763d29836df15be517072fd35ad/src/CompositeGrids/grid/composite.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NumericalEFT.CompositeGrids.CompositeG.Composite" href="#NumericalEFT.CompositeGrids.CompositeG.Composite"><code>NumericalEFT.CompositeGrids.CompositeG.Composite</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Composite{T&lt;:AbstractFloat,PG,SG} &lt;: SimpleG.ClosedGrid</code></pre><p>Composite grid generated with panel grid of type PG and subgrids of type SG. PG should always be ClosedGrid, while SG could be any grid.</p><p>#Members:</p><ul><li><code>bound</code> : boundary of the grid</li><li><code>size</code> : number of grid points</li><li><code>grid</code> : grid points</li><li><code>panel</code> : panel grid</li><li><code>subgrids</code> : a vector of subgrids</li><li><code>inits</code> : index of the first grid point of a subgrid on the whole grid</li></ul><p>#Constructor:</p><ul><li>function Composite{T,PG,SG}(panel, subgrids) where {T&lt;:AbstractFloat,PG,SG}</li></ul><p>create Composite grid from panel and subgrids. if the boundary grid point of two neighbor subgrids are too close, they will be combined in the whole grid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numericalEFT/NumericalEFT.jl/blob/833b1b89245a4763d29836df15be517072fd35ad/src/CompositeGrids/grid/composite.jl#L13-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.floor-Union{Tuple{SG}, Tuple{PG}, Tuple{T}, Tuple{NumericalEFT.CompositeGrids.CompositeG.Composite{T, PG, SG}, Any}} where {T, PG, SG}" href="#Base.floor-Union{Tuple{SG}, Tuple{PG}, Tuple{T}, Tuple{NumericalEFT.CompositeGrids.CompositeG.Composite{T, PG, SG}, Any}} where {T, PG, SG}"><code>Base.floor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function Base.floor(grid::Composite{T,PG,SG}, x) where {T,PG,SG}</code></pre><p>first find the corresponding subgrid by flooring on panel grid, then floor on subgrid and collect result. give the floor result on the whole grid. if floor on panel grid is needed, simply call floor(grid.panel, x).</p><p>return 1 for x&lt;grid[1] and grid.size-1 for x&gt;grid[end].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numericalEFT/NumericalEFT.jl/blob/833b1b89245a4763d29836df15be517072fd35ad/src/CompositeGrids/grid/composite.jl#L83-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NumericalEFT.CompositeGrids.CompositeG.CompositeLogGrid" href="#NumericalEFT.CompositeGrids.CompositeG.CompositeLogGrid"><code>NumericalEFT.CompositeGrids.CompositeG.CompositeLogGrid</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function CompositeLogGrid(type, bound, N, minterval, d2s, order, T=Float64)</code></pre><p>create a composite grid with a Log grid as panel and subgrids of selected type.</p><p>#Members:</p><ul><li><code>type</code> : type of the subgrids, currently in [:cheb, :gauss, :uniform]</li><li><code>bound</code> : boundary of the grid</li><li><code>N</code> : number of grid points of panel grid</li><li><code>minterval</code> : minimum interval of panel grid</li><li><code>d2s</code> : panel grid is dense to sparse or not</li><li><code>order</code> : number of grid points of subgrid</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numericalEFT/NumericalEFT.jl/blob/833b1b89245a4763d29836df15be517072fd35ad/src/CompositeGrids/grid/composite.jl#L127-L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NumericalEFT.CompositeGrids.CompositeG.LogDensedGrid" href="#NumericalEFT.CompositeGrids.CompositeG.LogDensedGrid"><code>NumericalEFT.CompositeGrids.CompositeG.LogDensedGrid</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function LogDensedGrid(type, bound, dense_at, N, minterval, order, T=Float64)</code></pre><p>create a composite grid of CompositeLogGrid as subgrids. the grid is densed at selected points in dense_at, which in the real situation could be [kF,] for fermi k grid and [0, 2kF] for bose k grid, etc. if two densed point is too close to each other, they will be combined.</p><p>#Members:</p><ul><li><code>type</code> : type of the subgrid of subgrid, currently in [:cheb, :gauss, :uniform]</li><li><code>bound</code> : boundary of the grid</li><li><code>dense_at</code> : list of points that requires densed grid</li><li><code>N</code> : number of grid points of panel grid</li><li><code>minterval</code> : minimum interval of panel grid</li><li><code>order</code> : number of grid points of subgrid</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numericalEFT/NumericalEFT.jl/blob/833b1b89245a4763d29836df15be517072fd35ad/src/CompositeGrids/grid/composite.jl#L168-L183">source</a></section></article><h2 id="Interpolation-and-Integration"><a class="docs-heading-anchor" href="#Interpolation-and-Integration">Interpolation and Integration</a><a id="Interpolation-and-Integration-1"></a><a class="docs-heading-anchor-permalink" href="#Interpolation-and-Integration" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="NumericalEFT.CompositeGrids.Interp" href="#NumericalEFT.CompositeGrids.Interp"><code>NumericalEFT.CompositeGrids.Interp</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Provide interpolation and integration.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numericalEFT/NumericalEFT.jl/blob/833b1b89245a4763d29836df15be517072fd35ad/src/CompositeGrids/grid/interpolate.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NumericalEFT.CompositeGrids.Interp.dataslice-Tuple{Any, Int64, Any}" href="#NumericalEFT.CompositeGrids.Interp.dataslice-Tuple{Any, Int64, Any}"><code>NumericalEFT.CompositeGrids.Interp.dataslice</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function dataslice(data, axes, indices)</code></pre><p>Return a view of data sliced on given axes with given indices. Works like view(data, (:, ..., :, i<em>1:f</em>1,  :, ..., i<em>n:f</em>n, :, ..., :)). Type unstable unless slice dims are constant.</p><p>#Members:</p><ul><li>data: data to be sliced.</li><li>axes: axes to be sliced. accept Int or NTuple{DIM, Int} for single or multiple axes. when omitted, assume all axes.</li><li>indices: indices of slicing. accept UnitRange{Int} or Vector of UnitRange{Int} like 2:8 or [2:8, 3:7]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numericalEFT/NumericalEFT.jl/blob/833b1b89245a4763d29836df15be517072fd35ad/src/CompositeGrids/grid/interpolate.jl#L104-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NumericalEFT.CompositeGrids.Interp.differentiate1D-Union{Tuple{T}, Tuple{Any, T, Any}} where T" href="#NumericalEFT.CompositeGrids.Interp.differentiate1D-Union{Tuple{T}, Tuple{Any, T, Any}} where T"><code>NumericalEFT.CompositeGrids.Interp.differentiate1D</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function differentiate1D(data, xgrid, x; axis=1)</code></pre><p>calculate integration of data[i] on xgrid. For 1D data, return a number; for multiple dimension, reduce the given axis.</p><p>#Arguments:</p><ul><li>xgrid: one-dimensional grid of x</li><li>data: one-dimensional array of data</li><li>x: point to differentiate</li><li>axis: axis to be differentiated in data</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numericalEFT/NumericalEFT.jl/blob/833b1b89245a4763d29836df15be517072fd35ad/src/CompositeGrids/grid/interpolate.jl#L818-L829">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NumericalEFT.CompositeGrids.Interp.findneighbor-Union{Tuple{T}, Tuple{T, Any}} where T" href="#NumericalEFT.CompositeGrids.Interp.findneighbor-Union{Tuple{T}, Tuple{T, Any}} where T"><code>NumericalEFT.CompositeGrids.Interp.findneighbor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function findneighbor(xgrid::T, x; method=:default) where {T}</code></pre><p>Find neighbor grid points and related information for extrapolating the value of x on xgrid.</p><p>#Members:</p><ul><li>xgrid: grid to be interpolated</li><li>x: value to be interpolated</li><li>method: :default use optimized method, :linear use linear interp.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numericalEFT/NumericalEFT.jl/blob/833b1b89245a4763d29836df15be517072fd35ad/src/CompositeGrids/grid/interpolate.jl#L49-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NumericalEFT.CompositeGrids.Interp.integrate1D-Tuple{NumericalEFT.CompositeGrids.Interp.ChebIntegrate, Any, Any}" href="#NumericalEFT.CompositeGrids.Interp.integrate1D-Tuple{NumericalEFT.CompositeGrids.Interp.ChebIntegrate, Any, Any}"><code>NumericalEFT.CompositeGrids.Interp.integrate1D</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function integrate1D(::ChebIntegrate, data, xgrid)</code></pre><p>calculate integration of data[i] on xgrid works for grids that have integration weight stored</p><p>#Arguments:</p><ul><li>xgrid: one-dimensional grid of x</li><li>data: one-dimensional array of data</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numericalEFT/NumericalEFT.jl/blob/833b1b89245a4763d29836df15be517072fd35ad/src/CompositeGrids/grid/interpolate.jl#L656-L665">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NumericalEFT.CompositeGrids.Interp.integrate1D-Tuple{NumericalEFT.CompositeGrids.Interp.CompositeIntegrate, Any, Any}" href="#NumericalEFT.CompositeGrids.Interp.integrate1D-Tuple{NumericalEFT.CompositeGrids.Interp.CompositeIntegrate, Any, Any}"><code>NumericalEFT.CompositeGrids.Interp.integrate1D</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function integrate1D(::CompositeIntegrate, data, xgrid)</code></pre><p>calculate integration of data[i] on xgrid call integrate1D for each subgrid and return the sum.</p><p>#Arguments:</p><ul><li>xgrid: one-dimensional grid of x</li><li>data: one-dimensional array of data</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numericalEFT/NumericalEFT.jl/blob/833b1b89245a4763d29836df15be517072fd35ad/src/CompositeGrids/grid/interpolate.jl#L671-L680">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NumericalEFT.CompositeGrids.Interp.integrate1D-Tuple{NumericalEFT.CompositeGrids.Interp.NoIntegrate, Any, Any}" href="#NumericalEFT.CompositeGrids.Interp.integrate1D-Tuple{NumericalEFT.CompositeGrids.Interp.NoIntegrate, Any, Any}"><code>NumericalEFT.CompositeGrids.Interp.integrate1D</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function integrate1D(::NoIntegrate, data, xgrid)</code></pre><p>calculate integration of data[i] on xgrid works for grids that do not have integration weight stored</p><p>#Arguments:</p><ul><li>xgrid: one-dimensional grid of x</li><li>data: one-dimensional array of data</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numericalEFT/NumericalEFT.jl/blob/833b1b89245a4763d29836df15be517072fd35ad/src/CompositeGrids/grid/interpolate.jl#L610-L619">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NumericalEFT.CompositeGrids.Interp.integrate1D-Tuple{NumericalEFT.CompositeGrids.Interp.WeightIntegrate, Any, Any}" href="#NumericalEFT.CompositeGrids.Interp.integrate1D-Tuple{NumericalEFT.CompositeGrids.Interp.WeightIntegrate, Any, Any}"><code>NumericalEFT.CompositeGrids.Interp.integrate1D</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function integrate1D(::WeightIntegrate, data, xgrid)</code></pre><p>calculate integration of data[i] on xgrid works for grids that have integration weight stored</p><p>#Arguments:</p><ul><li>xgrid: one-dimensional grid of x</li><li>data: one-dimensional array of data</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numericalEFT/NumericalEFT.jl/blob/833b1b89245a4763d29836df15be517072fd35ad/src/CompositeGrids/grid/interpolate.jl#L637-L646">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NumericalEFT.CompositeGrids.Interp.integrate1D-Union{Tuple{T}, Tuple{Any, T, Any}} where T" href="#NumericalEFT.CompositeGrids.Interp.integrate1D-Union{Tuple{T}, Tuple{Any, T, Any}} where T"><code>NumericalEFT.CompositeGrids.Interp.integrate1D</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function integrate1D(data, xgrid, range; axis=1)</code></pre><p>calculate integration of data[i] on xgrid. For 1D data, return a number; for multiple dimension, reduce the given axis.</p><p>#Arguments:</p><ul><li>xgrid: one-dimensional grid of x</li><li>data: one-dimensional array of data</li><li>range: range of integration, [init, fin] within bound of xgrid.</li><li>axis: axis to be integrated in data</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numericalEFT/NumericalEFT.jl/blob/833b1b89245a4763d29836df15be517072fd35ad/src/CompositeGrids/grid/interpolate.jl#L693-L704">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NumericalEFT.CompositeGrids.Interp.integrate1D-Union{Tuple{T}, Tuple{Any, T}} where T" href="#NumericalEFT.CompositeGrids.Interp.integrate1D-Union{Tuple{T}, Tuple{Any, T}} where T"><code>NumericalEFT.CompositeGrids.Interp.integrate1D</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function integrate1D(data, xgrid; axis=1)</code></pre><p>calculate integration of data[i] on xgrid. For 1D data, return a number; for multiple dimension, reduce the given axis.</p><p>#Arguments:</p><ul><li>xgrid: one-dimensional grid of x</li><li>data: one-dimensional array of data</li><li>axis: axis to be integrated in data</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numericalEFT/NumericalEFT.jl/blob/833b1b89245a4763d29836df15be517072fd35ad/src/CompositeGrids/grid/interpolate.jl#L581-L591">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NumericalEFT.CompositeGrids.Interp.interp1D-Tuple{NumericalEFT.CompositeGrids.Interp.ChebInterp, Any, Any, Any}" href="#NumericalEFT.CompositeGrids.Interp.interp1D-Tuple{NumericalEFT.CompositeGrids.Interp.ChebInterp, Any, Any, Any}"><code>NumericalEFT.CompositeGrids.Interp.interp1D</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function interp1D(::ChebInterp, data, xgrid, x)</code></pre><p>linear interpolation of data(x), barycheb for BaryCheb grid</p><p>#Arguments:</p><ul><li>xgrid: one-dimensional grid of x</li><li>data: one-dimensional array of data</li><li>x: x</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numericalEFT/NumericalEFT.jl/blob/833b1b89245a4763d29836df15be517072fd35ad/src/CompositeGrids/grid/interpolate.jl#L448-L457">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NumericalEFT.CompositeGrids.Interp.interp1D-Tuple{NumericalEFT.CompositeGrids.Interp.CompositeInterp, Any, Any, Any}" href="#NumericalEFT.CompositeGrids.Interp.interp1D-Tuple{NumericalEFT.CompositeGrids.Interp.CompositeInterp, Any, Any, Any}"><code>NumericalEFT.CompositeGrids.Interp.interp1D</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function interp1D(::CompositeInterp,data, xgrid, x)</code></pre><p>linear interpolation of data(x), first floor on panel to find subgrid, then call interp1D on subgrid </p><p>#Arguments:</p><ul><li>xgrid: one-dimensional grid of x</li><li>data: one-dimensional array of data</li><li>x: x</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numericalEFT/NumericalEFT.jl/blob/833b1b89245a4763d29836df15be517072fd35ad/src/CompositeGrids/grid/interpolate.jl#L462-L472">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NumericalEFT.CompositeGrids.Interp.interp1D-Tuple{NumericalEFT.CompositeGrids.Interp.LinearInterp, Any, Any, Any}" href="#NumericalEFT.CompositeGrids.Interp.interp1D-Tuple{NumericalEFT.CompositeGrids.Interp.LinearInterp, Any, Any, Any}"><code>NumericalEFT.CompositeGrids.Interp.interp1D</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function interp1D(::LinearInterp,data, xgrid, x)</code></pre><p>linear interpolation of data(x), use floor and linear1D</p><p>#Arguments:</p><ul><li>xgrid: one-dimensional grid of x</li><li>data: one-dimensional array of data</li><li>x: x</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numericalEFT/NumericalEFT.jl/blob/833b1b89245a4763d29836df15be517072fd35ad/src/CompositeGrids/grid/interpolate.jl#L434-L443">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NumericalEFT.CompositeGrids.Interp.interp1D-Union{Tuple{T}, Tuple{Any, T, Any}} where T" href="#NumericalEFT.CompositeGrids.Interp.interp1D-Union{Tuple{T}, Tuple{Any, T, Any}} where T"><code>NumericalEFT.CompositeGrids.Interp.interp1D</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function interp1D(data, xgrid, x; axis=1, method=InterpStyle(T))</code></pre><p>linear interpolation of data(x) with single or multiple dimension. For 1D data, return a number; for multiple dimension, reduce the given axis.</p><p>#Arguments:</p><ul><li>xgrid: one-dimensional grid of x</li><li>data: one-dimensional array of data</li><li>x: x</li><li>axis: axis to be interpolated in data</li><li>method: by default use optimized method; use linear interp if Interp.LinearInterp()</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numericalEFT/NumericalEFT.jl/blob/833b1b89245a4763d29836df15be517072fd35ad/src/CompositeGrids/grid/interpolate.jl#L402-L414">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NumericalEFT.CompositeGrids.Interp.interp1DGrid-Tuple{NumericalEFT.CompositeGrids.Interp.CompositeInterp, Any, Any, Any}" href="#NumericalEFT.CompositeGrids.Interp.interp1DGrid-Tuple{NumericalEFT.CompositeGrids.Interp.CompositeInterp, Any, Any, Any}"><code>NumericalEFT.CompositeGrids.Interp.interp1DGrid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function interp1DGrid(::CompositeInterp, data, xgrid, grid)</code></pre><p>linear interpolation of data(grid[1:end]), return a Vector grid should be sorted.</p><p>#Arguments:</p><ul><li>xgrid: one-dimensional grid of x</li><li>data: one-dimensional array of data</li><li>grid: points to be interpolated on</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numericalEFT/NumericalEFT.jl/blob/833b1b89245a4763d29836df15be517072fd35ad/src/CompositeGrids/grid/interpolate.jl#L523-L533">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NumericalEFT.CompositeGrids.Interp.interp1DGrid-Tuple{Union{NumericalEFT.CompositeGrids.Interp.ChebInterp, NumericalEFT.CompositeGrids.Interp.LinearInterp}, Any, Any, Any}" href="#NumericalEFT.CompositeGrids.Interp.interp1DGrid-Tuple{Union{NumericalEFT.CompositeGrids.Interp.ChebInterp, NumericalEFT.CompositeGrids.Interp.LinearInterp}, Any, Any, Any}"><code>NumericalEFT.CompositeGrids.Interp.interp1DGrid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function interp1DGrid(::Union{LinearInterp,ChebInterp}, data, xgrid, grid)</code></pre><p>linear interpolation of data(grid[1:end]), return a Vector simply call interp1D on each points</p><p>#Arguments:</p><ul><li>xgrid: one-dimensional grid of x</li><li>data: one-dimensional array of data</li><li>grid: points to be interpolated on</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numericalEFT/NumericalEFT.jl/blob/833b1b89245a4763d29836df15be517072fd35ad/src/CompositeGrids/grid/interpolate.jl#L500-L510">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NumericalEFT.CompositeGrids.Interp.interp1DGrid-Union{Tuple{T}, Tuple{Any, T, Any}} where T" href="#NumericalEFT.CompositeGrids.Interp.interp1DGrid-Union{Tuple{T}, Tuple{Any, T, Any}} where T"><code>NumericalEFT.CompositeGrids.Interp.interp1DGrid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function interp1DGrid(data, xgrid, grid; axis=1, method=InterpStyle(T))</code></pre><p>For 1D data, do interpolation of data(grid[1:end]), return a Vector. For ND data, do interpolation of data(grid[1:end]) at given axis, return data of same dimension.</p><p>#Arguments:</p><ul><li>xgrid: one-dimensional grid of x</li><li>data: one-dimensional array of data</li><li>grid: points to be interpolated on</li><li>axis: axis to be interpolated in data</li><li>method: by default use optimized method; use linear interp if :linear</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numericalEFT/NumericalEFT.jl/blob/833b1b89245a4763d29836df15be517072fd35ad/src/CompositeGrids/grid/interpolate.jl#L480-L491">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NumericalEFT.CompositeGrids.Interp.interpsliced-Tuple{Any, Any}" href="#NumericalEFT.CompositeGrids.Interp.interpsliced-Tuple{Any, Any}"><code>NumericalEFT.CompositeGrids.Interp.interpsliced</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function interpsliced(neighbor, data; axis=1)</code></pre><p>Interpolate with given neighbor and sliced data. Assume data already sliced on given axis.</p><p>#Members:</p><ul><li>neighbor: neighbor from findneighbor()</li><li>data: sliced data</li><li>axis: axis sliced and to be interpolated</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numericalEFT/NumericalEFT.jl/blob/833b1b89245a4763d29836df15be517072fd35ad/src/CompositeGrids/grid/interpolate.jl#L141-L149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NumericalEFT.CompositeGrids.Interp.linear1D-Tuple{Any, Any, Any}" href="#NumericalEFT.CompositeGrids.Interp.linear1D-Tuple{Any, Any, Any}"><code>NumericalEFT.CompositeGrids.Interp.linear1D</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function linear1D(data, xgrid, x)</code></pre><p>linear interpolation of data(x)</p><p>#Arguments:</p><ul><li>xgrid: one-dimensional grid of x</li><li>data: one-dimensional array of data</li><li>x: x</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numericalEFT/NumericalEFT.jl/blob/833b1b89245a4763d29836df15be517072fd35ad/src/CompositeGrids/grid/interpolate.jl#L366-L375">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NumericalEFT.CompositeGrids.Interp.linear2D-NTuple{5, Any}" href="#NumericalEFT.CompositeGrids.Interp.linear2D-NTuple{5, Any}"><code>NumericalEFT.CompositeGrids.Interp.linear2D</code></a> — <span class="docstring-category">Method</span></header><section><div><p>linear2D(data, xgrid, ygrid, x, y) </p><p>linear interpolation of data(x, y)</p><p>#Arguments:</p><ul><li>xgrid: one-dimensional grid of x</li><li>ygrid: one-dimensional grid of y</li><li>data: two-dimensional array of data</li><li>x: x</li><li>y: y</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numericalEFT/NumericalEFT.jl/blob/833b1b89245a4763d29836df15be517072fd35ad/src/CompositeGrids/grid/interpolate.jl#L303-L314">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NumericalEFT.CompositeGrids.Interp.linearND-Tuple{Any, Any, Any}" href="#NumericalEFT.CompositeGrids.Interp.linearND-Tuple{Any, Any, Any}"><code>NumericalEFT.CompositeGrids.Interp.linearND</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function linearND(data, xgrids, xs)</code></pre><p>linear interpolation of data(xs)</p><p>#Arguments:</p><ul><li>xgrids: n-dimensional grids, xgrids[i] is a 1D grid</li><li>data: n-dimensional array of data</li><li>xs: list of x, x[i] corresponds to xgrids[i]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numericalEFT/NumericalEFT.jl/blob/833b1b89245a4763d29836df15be517072fd35ad/src/CompositeGrids/grid/interpolate.jl#L212-L221">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../MCintegration/">« Monte Carlo Integrator</a><a class="docs-footer-nextpage" href="../greenfunc/">Green&#39;s Function »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.19 on <span class="colophon-date" title="Friday 17 June 2022 16:13">Friday 17 June 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
