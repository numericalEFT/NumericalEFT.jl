var documenterSearchIndex = {"docs":
[{"location":"lib/compositegrids/#Composite-1D-Grids","page":"Composite 1D Grids","title":"Composite 1D Grids","text":"","category":"section"},{"location":"lib/compositegrids/","page":"Composite 1D Grids","title":"Composite 1D Grids","text":"Modules = [NumericalEFT.CompositeGrids]","category":"page"},{"location":"lib/compositegrids/#Basic-Grids","page":"Composite 1D Grids","title":"Basic Grids","text":"","category":"section"},{"location":"lib/compositegrids/","page":"Composite 1D Grids","title":"Composite 1D Grids","text":"Modules = [CompositeGrids.SimpleG]","category":"page"},{"location":"lib/compositegrids/#NumericalEFT.CompositeGrids.SimpleG","page":"Composite 1D Grids","title":"NumericalEFT.CompositeGrids.SimpleG","text":"Basic grids including common grids like arbitrary grids, uniform grids, log grids, and optimized grids like barycheb for interpolation and gausslegendre for integration.\n\n\n\n\n\n","category":"module"},{"location":"lib/compositegrids/#NumericalEFT.CompositeGrids.SimpleG.AbstractGrid","page":"Composite 1D Grids","title":"NumericalEFT.CompositeGrids.SimpleG.AbstractGrid","text":"All Grids are derived from AbstractGrid; ClosedGrid has bound[1], bound[2] == grid[1], grid[end], while OpenGrid has bound[1]<grid[1]<grid[end]<bound[2]\n\n\n\n\n\n","category":"type"},{"location":"lib/compositegrids/#NumericalEFT.CompositeGrids.SimpleG.Arbitrary","page":"Composite 1D Grids","title":"NumericalEFT.CompositeGrids.SimpleG.Arbitrary","text":"struct Arbitrary{T<:AbstractFloat} <: ClosedGrid\n\nArbitrary grid generated from given sorted grid.\n\n#Members:\n\nbound : boundary of the grid\nsize : number of grid points\ngrid : grid points\nweight : integration weight\n\n#Constructor:\n\nfunction Arbitrary{T}(grid) where {T<:AbstractFloat}\n\n\n\n\n\n","category":"type"},{"location":"lib/compositegrids/#NumericalEFT.CompositeGrids.SimpleG.BaryCheb","page":"Composite 1D Grids","title":"NumericalEFT.CompositeGrids.SimpleG.BaryCheb","text":"struct BaryCheb{T<:AbstractFloat} <: OpenGrid\n\nBaryCheb grid generated on [bound[1], bound[2]] with order N.\n\n#Members:\n\nbound : boundary of the grid\nsize : number of grid points\ngrid : grid points\nweight : interpolation weight\n\n#Constructor:\n\nfunction BaryCheb{T}(bound, size) where {T<:AbstractFloat}\n\n\n\n\n\n","category":"type"},{"location":"lib/compositegrids/#NumericalEFT.CompositeGrids.SimpleG.GaussLegendre","page":"Composite 1D Grids","title":"NumericalEFT.CompositeGrids.SimpleG.GaussLegendre","text":"struct GaussLegendre{T<:AbstractFloat} <: OpenGrid\n\nGaussLegendre grid generated on [bound[1], bound[2]] with order N.\n\n#Members:\n\nbound : boundary of the grid\nsize : number of grid points\ngrid : grid points\nweight : integration weight\n\n#Constructor:\n\nfunction GaussLegendre{T}(bound, size) where {T<:AbstractFloat}\n\n\n\n\n\n","category":"type"},{"location":"lib/compositegrids/#NumericalEFT.CompositeGrids.SimpleG.Log","page":"Composite 1D Grids","title":"NumericalEFT.CompositeGrids.SimpleG.Log","text":"struct Log{T<:AbstractFloat} <: ClosedGrid\n\nLog grid generated on [bound[1], bound[2]] with N grid points. Minimal interval is set to be minterval. Dense to sparse if d2s, vice versa.\n\nOn [0, 1], a typical d2s Log grid looks like [0, λ^(N-1), ..., λ^2, λ, 1].\n\n#Members:\n\nbound : boundary of the grid\nsize : number of grid points\ngrid : grid points\nweight : integration weight\nλ : scale parameter\nd2s : dense to sparse or not\n\n#Constructor:\n\nfunction Log{T}(bound, size, minterval, d2s) where {T<:AbstractFloat}\n\n\n\n\n\n","category":"type"},{"location":"lib/compositegrids/#NumericalEFT.CompositeGrids.SimpleG.Uniform","page":"Composite 1D Grids","title":"NumericalEFT.CompositeGrids.SimpleG.Uniform","text":"struct Uniform{T<:AbstractFloat} <: ClosedGrid\n\nUniform grid generated on [bound[1], bound[2]] with N points\n\n#Members:\n\nbound : boundary of the grid\nsize : number of grid points\ngrid : grid points\nweight : integration weight\n\n#Constructor:\n\nfunction Uniform{T}(bound, size) where {T<:AbstractFloat}\n\n\n\n\n\n","category":"type"},{"location":"lib/compositegrids/#Base.floor-Tuple{NumericalEFT.CompositeGrids.SimpleG.AbstractGrid, Any}","page":"Composite 1D Grids","title":"Base.floor","text":"function Base.floor(grid::AbstractGrid, x) #where {T}\n\nuse basic searchsorted function to find the index of largest grid point smaller than x.\n\nreturn 1 for x<grid[1] and grid.size-1 for x>grid[end].\n\n\n\n\n\n","category":"method"},{"location":"lib/compositegrids/#Base.floor-Union{Tuple{T}, Tuple{NumericalEFT.CompositeGrids.SimpleG.Log{T}, Any}} where T","page":"Composite 1D Grids","title":"Base.floor","text":"function Base.floor(grid::Log{T}, x) where {T}\n\nfind the index of largest grid point smaller than x.\n\nreturn 1 for x<grid[1] and grid.size-1 for x>grid[end].\n\n\n\n\n\n","category":"method"},{"location":"lib/compositegrids/#Base.floor-Union{Tuple{T}, Tuple{NumericalEFT.CompositeGrids.SimpleG.Uniform{T}, Any}} where T","page":"Composite 1D Grids","title":"Base.floor","text":"function Base.floor(grid::Uniform{T}, x) where {T}\n\nfind the index of largest grid point smaller than x.\n\nreturn 1 for x<grid[1] and grid.size-1 for x>grid[end].\n\n\n\n\n\n","category":"method"},{"location":"lib/compositegrids/#Composite-Grids","page":"Composite 1D Grids","title":"Composite Grids","text":"","category":"section"},{"location":"lib/compositegrids/","page":"Composite 1D Grids","title":"Composite 1D Grids","text":"Modules = [CompositeGrids.CompositeG]","category":"page"},{"location":"lib/compositegrids/#NumericalEFT.CompositeGrids.CompositeG","page":"Composite 1D Grids","title":"NumericalEFT.CompositeGrids.CompositeG","text":"Composite grid that has tree structure. The whole interval is first divided by a panel grid, then each interval of a panel grid is divided by a smaller grid in subgrids. Subgrid could also be composite grid.\n\n\n\n\n\n","category":"module"},{"location":"lib/compositegrids/#NumericalEFT.CompositeGrids.CompositeG.Composite","page":"Composite 1D Grids","title":"NumericalEFT.CompositeGrids.CompositeG.Composite","text":"struct Composite{T<:AbstractFloat,PG,SG} <: SimpleG.ClosedGrid\n\nComposite grid generated with panel grid of type PG and subgrids of type SG. PG should always be ClosedGrid, while SG could be any grid.\n\n#Members:\n\nbound : boundary of the grid\nsize : number of grid points\ngrid : grid points\npanel : panel grid\nsubgrids : a vector of subgrids\ninits : index of the first grid point of a subgrid on the whole grid\n\n#Constructor:\n\nfunction Composite{T,PG,SG}(panel, subgrids) where {T<:AbstractFloat,PG,SG}\n\ncreate Composite grid from panel and subgrids. if the boundary grid point of two neighbor subgrids are too close, they will be combined in the whole grid.\n\n\n\n\n\n","category":"type"},{"location":"lib/compositegrids/#Base.floor-Union{Tuple{SG}, Tuple{PG}, Tuple{T}, Tuple{NumericalEFT.CompositeGrids.CompositeG.Composite{T, PG, SG}, Any}} where {T, PG, SG}","page":"Composite 1D Grids","title":"Base.floor","text":"function Base.floor(grid::Composite{T,PG,SG}, x) where {T,PG,SG}\n\nfirst find the corresponding subgrid by flooring on panel grid, then floor on subgrid and collect result. give the floor result on the whole grid. if floor on panel grid is needed, simply call floor(grid.panel, x).\n\nreturn 1 for x<grid[1] and grid.size-1 for x>grid[end].\n\n\n\n\n\n","category":"method"},{"location":"lib/compositegrids/#NumericalEFT.CompositeGrids.CompositeG.CompositeLogGrid","page":"Composite 1D Grids","title":"NumericalEFT.CompositeGrids.CompositeG.CompositeLogGrid","text":"function CompositeLogGrid(type, bound, N, minterval, d2s, order, T=Float64)\n\ncreate a composite grid with a Log grid as panel and subgrids of selected type.\n\n#Members:\n\ntype : type of the subgrids, currently in [:cheb, :gauss, :uniform]\nbound : boundary of the grid\nN : number of grid points of panel grid\nminterval : minimum interval of panel grid\nd2s : panel grid is dense to sparse or not\norder : number of grid points of subgrid\n\n\n\n\n\n","category":"function"},{"location":"lib/compositegrids/#NumericalEFT.CompositeGrids.CompositeG.LogDensedGrid","page":"Composite 1D Grids","title":"NumericalEFT.CompositeGrids.CompositeG.LogDensedGrid","text":"function LogDensedGrid(type, bound, dense_at, N, minterval, order, T=Float64)\n\ncreate a composite grid of CompositeLogGrid as subgrids. the grid is densed at selected points in dense_at, which in the real situation could be [kF,] for fermi k grid and [0, 2kF] for bose k grid, etc. if two densed point is too close to each other, they will be combined.\n\n#Members:\n\ntype : type of the subgrid of subgrid, currently in [:cheb, :gauss, :uniform]\nbound : boundary of the grid\ndense_at : list of points that requires densed grid\nN : number of grid points of panel grid\nminterval : minimum interval of panel grid\norder : number of grid points of subgrid\n\n\n\n\n\n","category":"function"},{"location":"lib/compositegrids/#Interpolation-and-Integration","page":"Composite 1D Grids","title":"Interpolation and Integration","text":"","category":"section"},{"location":"lib/compositegrids/","page":"Composite 1D Grids","title":"Composite 1D Grids","text":"Modules = [CompositeGrids.Interp]","category":"page"},{"location":"lib/compositegrids/#NumericalEFT.CompositeGrids.Interp","page":"Composite 1D Grids","title":"NumericalEFT.CompositeGrids.Interp","text":"Provide interpolation and integration.\n\n\n\n\n\n","category":"module"},{"location":"lib/compositegrids/#NumericalEFT.CompositeGrids.Interp.dataslice-Tuple{Any, Int64, Any}","page":"Composite 1D Grids","title":"NumericalEFT.CompositeGrids.Interp.dataslice","text":"function dataslice(data, axes, indices)\n\nReturn a view of data sliced on given axes with given indices. Works like view(data, (:, ..., :, i1:f1,  :, ..., in:fn, :, ..., :)). Type unstable unless slice dims are constant.\n\n#Members:\n\ndata: data to be sliced.\naxes: axes to be sliced. accept Int or NTuple{DIM, Int} for single or multiple axes. when omitted, assume all axes.\nindices: indices of slicing. accept UnitRange{Int} or Vector of UnitRange{Int} like 2:8 or [2:8, 3:7]\n\n\n\n\n\n","category":"method"},{"location":"lib/compositegrids/#NumericalEFT.CompositeGrids.Interp.differentiate1D-Union{Tuple{T}, Tuple{Any, T, Any}} where T","page":"Composite 1D Grids","title":"NumericalEFT.CompositeGrids.Interp.differentiate1D","text":"function differentiate1D(data, xgrid, x; axis=1)\n\ncalculate integration of data[i] on xgrid. For 1D data, return a number; for multiple dimension, reduce the given axis.\n\n#Arguments:\n\nxgrid: one-dimensional grid of x\ndata: one-dimensional array of data\nx: point to differentiate\naxis: axis to be differentiated in data\n\n\n\n\n\n","category":"method"},{"location":"lib/compositegrids/#NumericalEFT.CompositeGrids.Interp.findneighbor-Union{Tuple{T}, Tuple{T, Any}} where T","page":"Composite 1D Grids","title":"NumericalEFT.CompositeGrids.Interp.findneighbor","text":"function findneighbor(xgrid::T, x; method=:default) where {T}\n\nFind neighbor grid points and related information for extrapolating the value of x on xgrid.\n\n#Members:\n\nxgrid: grid to be interpolated\nx: value to be interpolated\nmethod: :default use optimized method, :linear use linear interp.\n\n\n\n\n\n","category":"method"},{"location":"lib/compositegrids/#NumericalEFT.CompositeGrids.Interp.integrate1D-Tuple{NumericalEFT.CompositeGrids.Interp.ChebIntegrate, Any, Any}","page":"Composite 1D Grids","title":"NumericalEFT.CompositeGrids.Interp.integrate1D","text":"function integrate1D(::ChebIntegrate, data, xgrid)\n\ncalculate integration of data[i] on xgrid works for grids that have integration weight stored\n\n#Arguments:\n\nxgrid: one-dimensional grid of x\ndata: one-dimensional array of data\n\n\n\n\n\n","category":"method"},{"location":"lib/compositegrids/#NumericalEFT.CompositeGrids.Interp.integrate1D-Tuple{NumericalEFT.CompositeGrids.Interp.CompositeIntegrate, Any, Any}","page":"Composite 1D Grids","title":"NumericalEFT.CompositeGrids.Interp.integrate1D","text":"function integrate1D(::CompositeIntegrate, data, xgrid)\n\ncalculate integration of data[i] on xgrid call integrate1D for each subgrid and return the sum.\n\n#Arguments:\n\nxgrid: one-dimensional grid of x\ndata: one-dimensional array of data\n\n\n\n\n\n","category":"method"},{"location":"lib/compositegrids/#NumericalEFT.CompositeGrids.Interp.integrate1D-Tuple{NumericalEFT.CompositeGrids.Interp.NoIntegrate, Any, Any}","page":"Composite 1D Grids","title":"NumericalEFT.CompositeGrids.Interp.integrate1D","text":"function integrate1D(::NoIntegrate, data, xgrid)\n\ncalculate integration of data[i] on xgrid works for grids that do not have integration weight stored\n\n#Arguments:\n\nxgrid: one-dimensional grid of x\ndata: one-dimensional array of data\n\n\n\n\n\n","category":"method"},{"location":"lib/compositegrids/#NumericalEFT.CompositeGrids.Interp.integrate1D-Tuple{NumericalEFT.CompositeGrids.Interp.WeightIntegrate, Any, Any}","page":"Composite 1D Grids","title":"NumericalEFT.CompositeGrids.Interp.integrate1D","text":"function integrate1D(::WeightIntegrate, data, xgrid)\n\ncalculate integration of data[i] on xgrid works for grids that have integration weight stored\n\n#Arguments:\n\nxgrid: one-dimensional grid of x\ndata: one-dimensional array of data\n\n\n\n\n\n","category":"method"},{"location":"lib/compositegrids/#NumericalEFT.CompositeGrids.Interp.integrate1D-Union{Tuple{T}, Tuple{Any, T, Any}} where T","page":"Composite 1D Grids","title":"NumericalEFT.CompositeGrids.Interp.integrate1D","text":"function integrate1D(data, xgrid, range; axis=1)\n\ncalculate integration of data[i] on xgrid. For 1D data, return a number; for multiple dimension, reduce the given axis.\n\n#Arguments:\n\nxgrid: one-dimensional grid of x\ndata: one-dimensional array of data\nrange: range of integration, [init, fin] within bound of xgrid.\naxis: axis to be integrated in data\n\n\n\n\n\n","category":"method"},{"location":"lib/compositegrids/#NumericalEFT.CompositeGrids.Interp.integrate1D-Union{Tuple{T}, Tuple{Any, T}} where T","page":"Composite 1D Grids","title":"NumericalEFT.CompositeGrids.Interp.integrate1D","text":"function integrate1D(data, xgrid; axis=1)\n\ncalculate integration of data[i] on xgrid. For 1D data, return a number; for multiple dimension, reduce the given axis.\n\n#Arguments:\n\nxgrid: one-dimensional grid of x\ndata: one-dimensional array of data\naxis: axis to be integrated in data\n\n\n\n\n\n","category":"method"},{"location":"lib/compositegrids/#NumericalEFT.CompositeGrids.Interp.interp1D-Tuple{NumericalEFT.CompositeGrids.Interp.ChebInterp, Any, Any, Any}","page":"Composite 1D Grids","title":"NumericalEFT.CompositeGrids.Interp.interp1D","text":"function interp1D(::ChebInterp, data, xgrid, x)\n\nlinear interpolation of data(x), barycheb for BaryCheb grid\n\n#Arguments:\n\nxgrid: one-dimensional grid of x\ndata: one-dimensional array of data\nx: x\n\n\n\n\n\n","category":"method"},{"location":"lib/compositegrids/#NumericalEFT.CompositeGrids.Interp.interp1D-Tuple{NumericalEFT.CompositeGrids.Interp.CompositeInterp, Any, Any, Any}","page":"Composite 1D Grids","title":"NumericalEFT.CompositeGrids.Interp.interp1D","text":"function interp1D(::CompositeInterp,data, xgrid, x)\n\nlinear interpolation of data(x), first floor on panel to find subgrid, then call interp1D on subgrid \n\n#Arguments:\n\nxgrid: one-dimensional grid of x\ndata: one-dimensional array of data\nx: x\n\n\n\n\n\n","category":"method"},{"location":"lib/compositegrids/#NumericalEFT.CompositeGrids.Interp.interp1D-Tuple{NumericalEFT.CompositeGrids.Interp.LinearInterp, Any, Any, Any}","page":"Composite 1D Grids","title":"NumericalEFT.CompositeGrids.Interp.interp1D","text":"function interp1D(::LinearInterp,data, xgrid, x)\n\nlinear interpolation of data(x), use floor and linear1D\n\n#Arguments:\n\nxgrid: one-dimensional grid of x\ndata: one-dimensional array of data\nx: x\n\n\n\n\n\n","category":"method"},{"location":"lib/compositegrids/#NumericalEFT.CompositeGrids.Interp.interp1D-Union{Tuple{T}, Tuple{Any, T, Any}} where T","page":"Composite 1D Grids","title":"NumericalEFT.CompositeGrids.Interp.interp1D","text":"function interp1D(data, xgrid, x; axis=1, method=InterpStyle(T))\n\nlinear interpolation of data(x) with single or multiple dimension. For 1D data, return a number; for multiple dimension, reduce the given axis.\n\n#Arguments:\n\nxgrid: one-dimensional grid of x\ndata: one-dimensional array of data\nx: x\naxis: axis to be interpolated in data\nmethod: by default use optimized method; use linear interp if Interp.LinearInterp()\n\n\n\n\n\n","category":"method"},{"location":"lib/compositegrids/#NumericalEFT.CompositeGrids.Interp.interp1DGrid-Tuple{NumericalEFT.CompositeGrids.Interp.CompositeInterp, Any, Any, Any}","page":"Composite 1D Grids","title":"NumericalEFT.CompositeGrids.Interp.interp1DGrid","text":"function interp1DGrid(::CompositeInterp, data, xgrid, grid)\n\nlinear interpolation of data(grid[1:end]), return a Vector grid should be sorted.\n\n#Arguments:\n\nxgrid: one-dimensional grid of x\ndata: one-dimensional array of data\ngrid: points to be interpolated on\n\n\n\n\n\n","category":"method"},{"location":"lib/compositegrids/#NumericalEFT.CompositeGrids.Interp.interp1DGrid-Tuple{Union{NumericalEFT.CompositeGrids.Interp.ChebInterp, NumericalEFT.CompositeGrids.Interp.LinearInterp}, Any, Any, Any}","page":"Composite 1D Grids","title":"NumericalEFT.CompositeGrids.Interp.interp1DGrid","text":"function interp1DGrid(::Union{LinearInterp,ChebInterp}, data, xgrid, grid)\n\nlinear interpolation of data(grid[1:end]), return a Vector simply call interp1D on each points\n\n#Arguments:\n\nxgrid: one-dimensional grid of x\ndata: one-dimensional array of data\ngrid: points to be interpolated on\n\n\n\n\n\n","category":"method"},{"location":"lib/compositegrids/#NumericalEFT.CompositeGrids.Interp.interp1DGrid-Union{Tuple{T}, Tuple{Any, T, Any}} where T","page":"Composite 1D Grids","title":"NumericalEFT.CompositeGrids.Interp.interp1DGrid","text":"function interp1DGrid(data, xgrid, grid; axis=1, method=InterpStyle(T))\n\nFor 1D data, do interpolation of data(grid[1:end]), return a Vector. For ND data, do interpolation of data(grid[1:end]) at given axis, return data of same dimension.\n\n#Arguments:\n\nxgrid: one-dimensional grid of x\ndata: one-dimensional array of data\ngrid: points to be interpolated on\naxis: axis to be interpolated in data\nmethod: by default use optimized method; use linear interp if :linear\n\n\n\n\n\n","category":"method"},{"location":"lib/compositegrids/#NumericalEFT.CompositeGrids.Interp.interpsliced-Tuple{Any, Any}","page":"Composite 1D Grids","title":"NumericalEFT.CompositeGrids.Interp.interpsliced","text":"function interpsliced(neighbor, data; axis=1)\n\nInterpolate with given neighbor and sliced data. Assume data already sliced on given axis.\n\n#Members:\n\nneighbor: neighbor from findneighbor()\ndata: sliced data\naxis: axis sliced and to be interpolated\n\n\n\n\n\n","category":"method"},{"location":"lib/compositegrids/#NumericalEFT.CompositeGrids.Interp.linear1D-Tuple{Any, Any, Any}","page":"Composite 1D Grids","title":"NumericalEFT.CompositeGrids.Interp.linear1D","text":"function linear1D(data, xgrid, x)\n\nlinear interpolation of data(x)\n\n#Arguments:\n\nxgrid: one-dimensional grid of x\ndata: one-dimensional array of data\nx: x\n\n\n\n\n\n","category":"method"},{"location":"lib/compositegrids/#NumericalEFT.CompositeGrids.Interp.linear2D-NTuple{5, Any}","page":"Composite 1D Grids","title":"NumericalEFT.CompositeGrids.Interp.linear2D","text":"linear2D(data, xgrid, ygrid, x, y) \n\nlinear interpolation of data(x, y)\n\n#Arguments:\n\nxgrid: one-dimensional grid of x\nygrid: one-dimensional grid of y\ndata: two-dimensional array of data\nx: x\ny: y\n\n\n\n\n\n","category":"method"},{"location":"lib/compositegrids/#NumericalEFT.CompositeGrids.Interp.linearND-Tuple{Any, Any, Any}","page":"Composite 1D Grids","title":"NumericalEFT.CompositeGrids.Interp.linearND","text":"function linearND(data, xgrids, xs)\n\nlinear interpolation of data(xs)\n\n#Arguments:\n\nxgrids: n-dimensional grids, xgrids[i] is a 1D grid\ndata: n-dimensional array of data\nxs: list of x, x[i] corresponds to xgrids[i]\n\n\n\n\n\n","category":"method"},{"location":"lib/compositegrids/#NumericalEFT.CompositeGrids.Interp.locate-Tuple{NumericalEFT.CompositeGrids.SimpleG.AbstractGrid, Any}","page":"Composite 1D Grids","title":"NumericalEFT.CompositeGrids.Interp.locate","text":"function locate(grid, x)\n\nreturn the index of grid point closest to x. Useful for Monte Carlo algorithm when variable x is continuous while histogram is stored on grid.\n\n#Arguments:\n\ngrid: one-dimensional grid of x\nx: point to locate\n\n\n\n\n\n","category":"method"},{"location":"lib/compositegrids/#NumericalEFT.CompositeGrids.Interp.volume-Tuple{NumericalEFT.CompositeGrids.SimpleG.AbstractGrid, Any}","page":"Composite 1D Grids","title":"NumericalEFT.CompositeGrids.Interp.volume","text":"function volume(grid, i)\n\nreturn the volume of grid point i. The volume is defined as the length/area/volume/... of histogram bar represented by grid point i. In 1D grids of this package, it is defined as the length of interval between (grid[i-1]+grid[i])/2 and (grid[i]+grid[i+1])/2, and for edge points one side is replaced by boundary points. When index i is omitted, the length of the whole grid is returned. It is guaranteed that volume(grid)==sum(volume(grid, i) for i in 1:length(grid)).\n\n#Arguments:\n\ngrid: one-dimensional grid\ni: index of grid point\n\n\n\n\n\n","category":"method"},{"location":"readme/FeynmanDiagram/#FeynmanDiagram","page":"FeynmanDiagram","title":"FeynmanDiagram","text":"","category":"section"},{"location":"readme/FeynmanDiagram/","page":"FeynmanDiagram","title":"FeynmanDiagram","text":"(Image: Stable) (Image: Dev) (Image: Build Status) (Image: Coverage)","category":"page"},{"location":"readme/FeynmanDiagram/","page":"FeynmanDiagram","title":"FeynmanDiagram","text":"This package implements a mini-compiler that compiles generic Feynman diagrams into expression tree representations for fast computation. ","category":"page"},{"location":"readme/FeynmanDiagram/#Infrastructure","page":"FeynmanDiagram","title":"Infrastructure","text":"","category":"section"},{"location":"readme/FeynmanDiagram/","page":"FeynmanDiagram","title":"FeynmanDiagram","text":"In general, Feynman diagrams represents high-order integral. The integrand are propagators/interactions composed by the basis arithmetic operations (multiplication, addition). The sequence of calculating the integrand by combining the propagators/interactions with the arithmetic operatos can be represented as an algebraic expression tree. In this sense, the expression tree provides an intermediate representation (IR) for Feynman diagrams that completely independent of the diagram type. ","category":"page"},{"location":"readme/FeynmanDiagram/","page":"FeynmanDiagram","title":"FeynmanDiagram","text":"(Image: infrastructure)","category":"page"},{"location":"readme/FeynmanDiagram/","page":"FeynmanDiagram","title":"FeynmanDiagram","text":"Base on this observation, we develop a package to compile the integrand of Feynman diagrams into machine code so that one can evaluate the it efficiently. The infrastructure of this package is similar to the modern compiler LLVM for generic programming language. There are three layers: a front-end translates a source code into an IR as an expression tree, then a mid-end optimizes and transforms the IR, and a back-end to compiles the IR to machine code. ","category":"page"},{"location":"readme/FeynmanDiagram/","page":"FeynmanDiagram","title":"FeynmanDiagram","text":"The front-end supports Feynman diagrams from weak coupling expansion or strong coupling expansion. The user can incorprate new types of diagrams by writing their own front-end.\nThe mid-end performs universal optimizations and transformations of one expression tree to another. The possible optimizations of the expression tree includes: remove common nodes/leaves, remove zero-valued nodes/leaves, merge small nodes into a large one. The possible transformations include automatic differentiation (which can be useful to derive the diagrams for the specific heat, RG flow equation, etc.), renormalization of the propagators and the interactions, and analytic Matsubara-frequency integration (work in progress).\nThe back-end provides a universal subroutine to evalue the expression tree efficiently. ","category":"page"},{"location":"readme/FeynmanDiagram/#Supported-Front-end","page":"FeynmanDiagram","title":"Supported Front-end","text":"","category":"section"},{"location":"readme/FeynmanDiagram/#.-Generic-Weak-Coupling-Expansion-based-on-the-Parquet-Algorithm","page":"FeynmanDiagram","title":"1. Generic Weak Coupling Expansion based on the Parquet Algorithm","text":"","category":"section"},{"location":"readme/FeynmanDiagram/","page":"FeynmanDiagram","title":"FeynmanDiagram","text":"This algorithm generates the Feynman diagrams of weak coupling expansion. It supports the diagrams of self-energy, polarization, 3-point vertex function and 4-point vertex function. The internal degrees of freedom can be either the loop variables (e.g., momentum or frequency) or the site variables (e.g., imaginary-time or lattice site).","category":"page"},{"location":"readme/FeynmanDiagram/","page":"FeynmanDiagram","title":"FeynmanDiagram","text":"The main idea of the algorithm is to use the parquet equation to build high-order-vertex-function diagrams from the lower order sub-diagrams. ","category":"page"},{"location":"readme/FeynmanDiagram/","page":"FeynmanDiagram","title":"FeynmanDiagram","text":"The following code is a simple example to generate the one-loop 4-point vertex function diagrams, then visualize the expression tree.","category":"page"},{"location":"readme/FeynmanDiagram/","page":"FeynmanDiagram","title":"FeynmanDiagram","text":"using FeynmanDiagram\n\n# Define a parameter structure for the 4-vertex diagram with one-loop, in the momentum and the imaginary-time representation. Require the diagrams to be green's function irreducible.\npara = DiagParaF64(type = Ver4Diag, innerLoopNum = 1,hasTau = true, filter=[NoHartree, Girreducible,])\npara = DiagParaF64(type = Ver4Diag, innerLoopNum = 1,hasTau = true, filter=[NoHartree, Girreducible,])\n\nver4=Parquet.build(para) #build the diagram tree with the parquet algorithm.\n\nplot_tree(ver4) # visualize the generated diagram tree\n\ntree=ExprTree.build(ver4.diagram) #optimize the diagram tree to get an optimized expression tree","category":"page"},{"location":"readme/FeynmanDiagram/","page":"FeynmanDiagram","title":"FeynmanDiagram","text":"The generated diagram tree is as shown in the following figure. The leaves of the tree are the propagators (labeled with G) and the interactions (labeled with Ins). By default, the interactions is assumed to spin-symmetric. A typical example is the Coulomb interaction. (Image: tree)","category":"page"},{"location":"readme/FeynmanDiagram/#.-Generic-Strong-Coupling-Expansion-(work-in-progress)","page":"FeynmanDiagram","title":"2. Generic Strong Coupling Expansion (work in progress)","text":"","category":"section"},{"location":"readme/FeynmanDiagram/#.-Hand-drawing-Feynman-diagrams-(work-in-progress)","page":"FeynmanDiagram","title":"3. Hand-drawing Feynman diagrams (work in progress)","text":"","category":"section"},{"location":"readme/FeynmanDiagram/#Expression-Tree-visualization","page":"FeynmanDiagram","title":"Expression Tree visualization","text":"","category":"section"},{"location":"readme/FeynmanDiagram/","page":"FeynmanDiagram","title":"FeynmanDiagram","text":"To visualize the diagram tree, you need to install the ete3 python3 package (http://etetoolkit.org/).","category":"page"},{"location":"readme/FeynmanDiagram/","page":"FeynmanDiagram","title":"FeynmanDiagram","text":"Note that we rely on \"PyCall.jl\" to call the ete3 python functions from julia. Therefore, you have to install ete3 python package use the python distribution associated with PyCall. According to the tutorial of PyCall (https://github.com/JuliaPy/PyCall.jl), \"by default on Mac and Windows systems, Pkg.add(\"PyCall\") or Pkg.build(\"PyCall\") will use the Conda.jl package to install a minimal Python distribution (via Miniconda) that is private to Julia (not in your PATH). You can use the Conda Julia package to install more Python packages, and import Conda to print the Conda.PYTHONDIR directory where python was installed. On GNU/Linux systems, PyCall will default to using the python3 program (if any, otherwise python) in your PATH.\"","category":"page"},{"location":"man/MC/#Important-Sampling","page":"Important Sampling","title":"Important Sampling","text":"","category":"section"},{"location":"man/MC/#Introduction","page":"Important Sampling","title":"Introduction","text":"","category":"section"},{"location":"man/MC/","page":"Important Sampling","title":"Important Sampling","text":"This note compares two important sampling approaches for Monte Carlo integration. The first approach introduces a normalization sector and lets the Markov chain jumps between this additional sector and the integrand sector following a calibrated probability density for important sampling. One can infer the integration between the ratio of weights between two sectors. On the other hand, the second approach reweights the original integrand to make it as flat as possible, one then perform a random walk uniformly in the parameter space to calculate the integration. This is the conventional approach used in Vegas algorithm.","category":"page"},{"location":"man/MC/","page":"Important Sampling","title":"Important Sampling","text":"In general, the first approach is more robust than the second one, but less efficient. In many applications, for example, high order Feynman diagrams with a sign alternation, the important sampling probability can't represent the complicated integrand well. Then the first approach is as efficient as the second one, but tends to be much robust.","category":"page"},{"location":"man/MC/","page":"Important Sampling","title":"Important Sampling","text":"We next present a benchmark between two approaches. Consider the MC sampling of an one-dimensional functions f(x) (its sign may oscillate).","category":"page"},{"location":"man/MC/","page":"Important Sampling","title":"Important Sampling","text":"We want to design an efficient algorithm to calculate the integral int_a^b dx f(x). To do that, we normalize the integrand with an ansatz g(x)0 to reduce the variant. ","category":"page"},{"location":"man/MC/","page":"Important Sampling","title":"Important Sampling","text":"Our package supports two important sampling schemes. ","category":"page"},{"location":"man/MC/#Approach-1:-Algorithm-with-a-Normalization-Sector","page":"Important Sampling","title":"Approach 1: Algorithm with a Normalization Sector","text":"","category":"section"},{"location":"man/MC/","page":"Important Sampling","title":"Important Sampling","text":"In this approach, the configuration spaces consist of two sub-spaces: the physical sector with orders nge 1 and the normalization sector with the order n=0. The weight function of the latter, g(x), should be simple enough so that the integral G=int g(x) d x is explicitly known. In our algorithm we use a constant g(x) propto 1 for simplicity. In this setup, the physical sector weight, namely the integral F = int f(x) dx, can be calculated with the equation","category":"page"},{"location":"man/MC/","page":"Important Sampling","title":"Important Sampling","text":"    F=fracF_rm MCG_rm MC G","category":"page"},{"location":"man/MC/","page":"Important Sampling","title":"Important Sampling","text":"where the MC estimators F_rm MC and G_rm MC are measured with ","category":"page"},{"location":"man/MC/","page":"Important Sampling","title":"Important Sampling","text":"F_rm MC =frac1N left sum_i=1^N_f fracf(x_i)rho_f(x_i) + sum_i=1^N_g 0 right","category":"page"},{"location":"man/MC/","page":"Important Sampling","title":"Important Sampling","text":"and","category":"page"},{"location":"man/MC/","page":"Important Sampling","title":"Important Sampling","text":"G_rm MC =frac1N leftsum_i=1^N_f 0 + sum_i=1^N_g fracg(x_i)rho_g(x_i)  right","category":"page"},{"location":"man/MC/","page":"Important Sampling","title":"Important Sampling","text":"The probability density of a given configuration is proportional to rho_f(x)=f(x) and rho_g(x)=g(x), respectively. After N MC updates, the physical sector is sampled for N_f times, and the normalization sector is for N_g times. ","category":"page"},{"location":"man/MC/","page":"Important Sampling","title":"Important Sampling","text":"Now we estimate the statistic error. According to the propagation of uncertainty, the variance of F  is given by","category":"page"},{"location":"man/MC/","page":"Important Sampling","title":"Important Sampling","text":" fracsigma^2_FF^2 =  fracsigma_F_rm MC^2F_MC^2 + fracsigma_G_rm MC^2G_MC^2 ","category":"page"},{"location":"man/MC/","page":"Important Sampling","title":"Important Sampling","text":"where sigma_F_rm MC and sigma_G_rm MC are variance of the MC integration F_rm MC and G_rm MC, respectively. In the Markov chain MC, the variance of F_rm MC can be written as ","category":"page"},{"location":"man/MC/","page":"Important Sampling","title":"Important Sampling","text":"sigma^2_F_rm MC = frac1N left sum_i^N_f left( fracf(x_i)rho_f(x_i)- fracFZright)^2 +sum_j^N_g left(0-fracFZ right)^2  right ","category":"page"},{"location":"man/MC/","page":"Important Sampling","title":"Important Sampling","text":"= int left( fracf(x)rho_f(x) - fracFZ right)^2 fracrho_f(x)Z rm dx + int left( fracFZ right)^2 fracrho_g(x)Z dx ","category":"page"},{"location":"man/MC/","page":"Important Sampling","title":"Important Sampling","text":"=  int fracf^2(x)rho_f(x) fracdxZ -fracF^2Z^2 ","category":"page"},{"location":"man/MC/","page":"Important Sampling","title":"Important Sampling","text":"Here Z=Z_f+Z_g and Z_fg=int rho_fg(x)dx are the partition sums of the corresponding configuration spaces. Due to the detailed balance, one has Z_fZ_g=N_fN_g.  ","category":"page"},{"location":"man/MC/","page":"Important Sampling","title":"Important Sampling","text":"Similarly, the variance of G_rm MC can be written as ","category":"page"},{"location":"man/MC/","page":"Important Sampling","title":"Important Sampling","text":"sigma^2_G_rm MC=  int fracg^2(x)rho_g(x) fracdxZ - fracG^2Z^2","category":"page"},{"location":"man/MC/","page":"Important Sampling","title":"Important Sampling","text":"By substituting rho_f(x)=f(x) and  rho_g(x)=g(x), the variances of F_rm MC and G_rm MC are given by","category":"page"},{"location":"man/MC/","page":"Important Sampling","title":"Important Sampling","text":"sigma^2_F_rm MC= frac1Z^2 left( Z Z_f - F^2 right)","category":"page"},{"location":"man/MC/","page":"Important Sampling","title":"Important Sampling","text":"sigma^2_G_rm MC= frac1Z^2 left( Z Z_g - G^2 right)","category":"page"},{"location":"man/MC/","page":"Important Sampling","title":"Important Sampling","text":"We derive the variance of F as","category":"page"},{"location":"man/MC/","page":"Important Sampling","title":"Important Sampling","text":"fracsigma^2_FF^2 = fracZ cdot Z_fF^2+fracZ cdot Z_gG^2 - 2 ","category":"page"},{"location":"man/MC/","page":"Important Sampling","title":"Important Sampling","text":"Note that g(x)0 indicates Z_g = G,  so that","category":"page"},{"location":"man/MC/","page":"Important Sampling","title":"Important Sampling","text":"fracsigma^2_FF^2 = fracZ_f^2F^2+fracGcdot Z_fF^2+fracZ_fG - 1","category":"page"},{"location":"man/MC/","page":"Important Sampling","title":"Important Sampling","text":"Interestingly, this variance is a function of G instead of a functional of g(x). It is then possible to normalized g(x) with a constant to minimize the variance. The optimal constant makes G to be,","category":"page"},{"location":"man/MC/","page":"Important Sampling","title":"Important Sampling","text":"fracd sigma^2_FdG=0","category":"page"},{"location":"man/MC/","page":"Important Sampling","title":"Important Sampling","text":"which makes G_best = F. The minimized the variance is given by,","category":"page"},{"location":"man/MC/","page":"Important Sampling","title":"Important Sampling","text":"fracsigma^2_FF^2= left(fracZ_fF+1right)^2 - 2ge 0","category":"page"},{"location":"man/MC/","page":"Important Sampling","title":"Important Sampling","text":"The equal sign is achieved when f(x)0 is positively defined.","category":"page"},{"location":"man/MC/","page":"Important Sampling","title":"Important Sampling","text":"It is very important that the above analysis is based on the assumption that the autocorrelation time negligible. The autocorrelation time related to the jump between the normalization and physical sectors is controlled by the deviation of the ratio f(x)g(x) from unity. The variance sigma_F^2 given above will be amplified to sim sigma_F^2 tau where tau is the autocorrelation time.","category":"page"},{"location":"man/MC/#Approach-2:-Conventional-algorithm-(e.g.,-Vegas-algorithm)","page":"Important Sampling","title":"Approach 2: Conventional algorithm (e.g., Vegas algorithm)","text":"","category":"section"},{"location":"man/MC/","page":"Important Sampling","title":"Important Sampling","text":"Important sampling is actually more straightforward than the above approach. One simply sample x with a distribution rho_g(x)=g(x)Z_g, then measure the observable f(x)g(x). Therefore, the mean estimation,","category":"page"},{"location":"man/MC/","page":"Important Sampling","title":"Important Sampling","text":"fracFZ=int dx fracf(x)g(x) rho_g(x)","category":"page"},{"location":"man/MC/","page":"Important Sampling","title":"Important Sampling","text":"the variance of F in this approach is given by,","category":"page"},{"location":"man/MC/","page":"Important Sampling","title":"Important Sampling","text":"sigma_F^2=Z_g^2int dx left( fracf(x)g(x)- fracFZ_gright)^2rho_g(x)","category":"page"},{"location":"man/MC/","page":"Important Sampling","title":"Important Sampling","text":"fracsigma_F^2F^2=fracZ_gF^2int dx fracf(x)^2g(x)- 1","category":"page"},{"location":"man/MC/","page":"Important Sampling","title":"Important Sampling","text":"The optimal g(x) that minimizes the variance is g(x) =f(x),","category":"page"},{"location":"man/MC/","page":"Important Sampling","title":"Important Sampling","text":"fracsigma_F^2F^2=fracZ_f^2F^2-1","category":"page"},{"location":"man/MC/","page":"Important Sampling","title":"Important Sampling","text":"The variance of the conventional approach is a functional of g(x), while that of the previous approach isn't. There are two interesting limit:\nIf the f(x)0, the optimal choice g(x)=f(x) leads to zero variance. In this limit, the conventional approach is clearly much better than the previous approach.\nOn the other hand, if g(x) is far from the optimal choice f(x), say simply setting g(x)=1, one naively expect that the the conventional approach may leads to much larger variance than the previous approach. However,  this statement may not be true. If g(x) is very different from f(x), the normalization and the physical sector in the previous approach mismatch, causing large autocorrelation time and large statistical error . In contrast, the conventional approach doesn't have this problem.","category":"page"},{"location":"man/MC/#Benchmark","page":"Important Sampling","title":"Benchmark","text":"","category":"section"},{"location":"man/MC/","page":"Important Sampling","title":"Important Sampling","text":"To benchmark, we sample the following integral up to 10^8 updates, ","category":"page"},{"location":"man/MC/","page":"Important Sampling","title":"Important Sampling","text":"int_0^beta e^-(x-beta2)^2delta^2dx approx sqrtpidelta","category":"page"},{"location":"man/MC/","page":"Important Sampling","title":"Important Sampling","text":"where beta gg delta.","category":"page"},{"location":"man/MC/","page":"Important Sampling","title":"Important Sampling","text":"g(x)=f(x)","category":"page"},{"location":"man/MC/","page":"Important Sampling","title":"Important Sampling","text":"Normalization Sector:  doesn't lead to exact result, the variance left(fracZ_fF+1right)^2 - 2=2 doesn't change with parameters","category":"page"},{"location":"man/MC/","page":"Important Sampling","title":"Important Sampling","text":"beta 10 100\nresult 0.1771(1) 0.1773(1)","category":"page"},{"location":"man/MC/","page":"Important Sampling","title":"Important Sampling","text":"Conventional: exact result","category":"page"},{"location":"man/MC/","page":"Important Sampling","title":"Important Sampling","text":"g(x)=sqrtpideltabeta1","category":"page"},{"location":"man/MC/","page":"Important Sampling","title":"Important Sampling","text":"beta 10 100\nNormalization 0.1772(4) 0.1767(17)\nConventional 0.1777(3) 0.1767(8)","category":"page"},{"location":"man/MC/","page":"Important Sampling","title":"Important Sampling","text":"g(x)=exp(-(x-beta2+s)^2delta^2) with beta=100","category":"page"},{"location":"man/MC/","page":"Important Sampling","title":"Important Sampling","text":"s delta 2delta 3delta 4delta 5delta\nNormalization 0.1775(8) 0.1767(25) 0.1770(60) 0.176(15) 183(143)\nConventional 0.1776(5) 0.1707(39) 0.1243(174) 0.0204 (64) ","category":"page"},{"location":"man/MC/","page":"Important Sampling","title":"Important Sampling","text":"The conventional algorithm is not ergodic anymore for s=4delta, the acceptance ratio to update x is about 015, while the normalization algorithm becomes non ergodic for s=5delta. So the latter is slightly more stable.","category":"page"},{"location":"man/MC/","page":"Important Sampling","title":"Important Sampling","text":"<!– The code are ![[test.jl]] for the normalization approach and ![[test2.jl]] for the conventional approach. –>","category":"page"},{"location":"man/MC/","page":"Important Sampling","title":"Important Sampling","text":"Reference:  [1] Wang, B.Z., Hou, P.C., Deng, Y., Haule, K. and Chen, K., Fermionic sign structure of high-order Feynman diagrams in a many-fermion system. Physical Review B, 103, 115141 (2021).","category":"page"},{"location":"lib/MCintegration/#Monte-Carlo-Integrator","page":"Monte Carlo Integrator","title":"Monte Carlo Integrator","text":"","category":"section"},{"location":"lib/MCintegration/","page":"Monte Carlo Integrator","title":"Monte Carlo Integrator","text":"Modules = [NumericalEFT.MCIntegration]","category":"page"},{"location":"lib/MCintegration/#NumericalEFT.MCIntegration.Configuration","page":"Monte Carlo Integrator","title":"NumericalEFT.MCIntegration.Configuration","text":"mutable struct Configuration\n\nStruct that contains everything needed for MC.\n\nStatic parameters\n\nseed: seed to initialize random numebr generator, also serves as the unique pid of the configuration\nrng: a MersenneTwister random number generator, seeded by seed\nuserdata: user-defined parameter\nvar: TUPLE of variables, each variable should be derived from the abstract type Variable, see variable.jl for details). Use a tuple rather than a vector improves the performance.\n\nintegrand properties\n\nneighbor::Vector{Tuple{Int, Int}} : vector of tuples that defines the neighboring integrands. Two neighboring integrands are directly connected in the Markov chain.    e.g., [(1, 2), (2, 3)] means the integrand 1 and 2 are neighbor, and 2 and 3 are neighbor.    The neighbor vector defines a undirected graph showing how the integrands are connected. Please make sure all integrands are connected.  By default, we assume the N integrands are in the increase order, meaning the neighbor will be set to [(N+1, 1), (1, 2), (2, 4), ..., (N-1, N)], where the first N entries are for diagram 1, 2, ..., N and the last entry is for the normalization diagram. Only the first diagram is connected to the normalization diagram.  Only highly correlated integrands are not highly correlated should be defined as neighbors. Otherwise, most of the updates between the neighboring integrands will be rejected and wasted.\ndof::Vector{Vector{Int}}: degrees of freedom of each integrand, e.g., [[0, 1], [2, 3]] means the first integrand has zero var#1 and one var#2; while the second integrand has two var#1 and 3 var#2. \nobservable: observables that is required to calculate the integrands, will be used in the measure function call.   It is either an array of any type with the common operations like +-*/^ defined. \nreweight: reweight factors for each integrands. The reweight factor of the normalization diagram is assumed to be 1. Note that you don't need to explicitly add the normalization diagram. \nvisited: how many times this integrand is visited by the Markov chain.\n\ncurrent MC state\n\nstep: the number of MC updates performed up to now\nnorm: the index of the normalization diagram. norm is larger than the index of any user-defined integrands \nnormalization: the accumulated normalization factor. Physical observable = Configuration.observable/Configuration.normalization.\npropose/accept: array to store the proposed and accepted updates for each integrands and variables.  Their shapes are (number of updates X integrand number X max(integrand number, variable number).  The last index will waste some memory, but the dimension is small anyway.\n\n\n\n\n\n","category":"type"},{"location":"lib/MCintegration/#NumericalEFT.MCIntegration.Configuration-Tuple{}","page":"Monte Carlo Integrator","title":"NumericalEFT.MCIntegration.Configuration","text":"function Configuration(;\n    var::Union{Variable,AbstractVector,Tuple}=(Continuous(0.0, 1.0),),\n    dof::Union{Int,AbstractVector,AbstractMatrix}=[ones(Int, length(var)),],\n    type=Float64,  # type of the integrand\n    obs::AbstractVector=zeros(type, length(dof)),\n    reweight::Vector{Float64}=ones(length(dof) + 1),\n    seed::Int=rand(Random.RandomDevice(), 1:1000000),\n    neighbor::Union{Vector{Vector{Int}},Vector{Tuple{Int,Int}},Nothing}=nothing,\n    userdata=nothing,\n    kwargs...\n)\n\nCreate a Configuration struct\n\nArguments\n\nvar: TUPLE of variables, each variable should be derived from the abstract type Variable, see variable.jl for details). Use a tuple rather than a vector improves the performance.\n\nBy default, var = (Continuous(0.0, 1.0),), which is a single continuous variable.\n\ndof::Vector{Vector{Int}}: degrees of freedom of each integrand, e.g., [[0, 1], [2, 3]] means the first integrand has zero var#1 and one var#2; while the second integrand has two var#1 and 3 var#2. \n\nBy default, dof=[ones(length(var)), ], which means that there is only one integrand, and each variable has one degree of freedom.\n\nobs: observables that is required to calculate the integrands, will be used in the measure function call.\n\nIt is either an array of any type with the common operations like +-*/^ defined.  By default, it will be set to 0.0 if there is only one integrand (e.g., length(dof)==1); otherwise, it will be set to zeros(length(dof)).\n\npara: user-defined parameter, set to nothing if not needed\nreweight: reweight factors for each integrands. If not set, then all factors will be initialized with one.\nseed: seed to initialize random numebr generator, also serves as the unique pid of the configuration. If it is nothing, then use RandomDevice() to generate a random seed in [1, 1000_1000]\nneighbor::Vector{Tuple{Int, Int}} : vector of tuples that defines the neighboring integrands. Two neighboring integrands are directly connected in the Markov chain.    e.g., [(1, 2), (2, 3)] means the integrand 1 and 2 are neighbor, and 2 and 3 are neighbor.     The neighbor vector defines a undirected graph showing how the integrands are connected. Please make sure all integrands are connected.   By default, we assume the N integrands are in the increase order, meaning the neighbor will be set to [(N+1, 1), (1, 2), (2, 4), ..., (N-1, N)], where the first N entries are for diagram 1, 2, ..., N and the last entry is for the normalization diagram. Only the first diagram is connected to the normalization diagram.   Only highly correlated integrands are not highly correlated should be defined as neighbors. Otherwise, most of the updates between the neighboring integrands will be rejected and wasted.\nuserdata: User data you want to pass to the integrand and the measurement\n\n\n\n\n\n","category":"method"},{"location":"lib/MCintegration/#NumericalEFT.MCIntegration.Result","page":"Monte Carlo Integrator","title":"NumericalEFT.MCIntegration.Result","text":"struct Result{O,C}\n\nthe returned result of the MC integration.\n\nMembers\n\nmean: mean of the MC integration\nstdev: standard deviation of the MC integration\nchi2: chi-square per dof of the MC integration\nneval: number of evaluations of the integrand\nignore: ignore iterations untill ignore\ndof: degrees of freedom of the MC integration (number of iterations - 1)\nconfig: configuration of the MC integration from the last iteration\niterations: list of tuples [(data, error, Configuration), ...] from each iteration\n\n\n\n\n\n","category":"type"},{"location":"lib/MCintegration/#NumericalEFT.MCIntegration.average","page":"Monte Carlo Integrator","title":"NumericalEFT.MCIntegration.average","text":"function average(history, idx=1; init=1, max=length(history))\n\naverage the history[1:max]. Return the mean, standard deviation and chi2 of the history.\n\nArguments\n\nhistory: a list of tuples, such as [(data, error, Configuration), ...]\nidx: the index of the integral\nmax: the last index of the history to average with\ninit : the first index of the history to average with\n\n\n\n\n\n","category":"function"},{"location":"lib/MCintegration/#NumericalEFT.MCIntegration.integrate-Tuple{Function}","page":"Monte Carlo Integrator","title":"NumericalEFT.MCIntegration.integrate","text":"function integrate(integrand::Function;\n    solver::Symbol=:vegas, # :mcmc, :vegas, or :vegasmc\n    config::Union{Configuration,Nothing}=nothing,\n    neval=1e4, \n    niter=10, \n    block=16, \n    print=-1, \n    gamma=1.0, \n    adapt=true,\n    debug=false, \n    reweight_goal::Union{Vector{Float64},Nothing}=nothing, \n    ignore::Int=adapt ? 1 : 0,\n    measure::Union{Nothing,Function}=nothing,\n    measurefreq::Int=1,\n    kwargs...\n)\n\nCalculate the integrals, collect statistics, and return a Result struct that contains the estimations and errors.\n\nRemarks\n\nUser may run the MC in parallel using MPI. Simply run mpiexec -n N julia userscript.jl where N is the number of workers. In this mode, only the root process returns meaningful results. All other workers return nothing, nothing. User is responsible to handle the returning results properly. If you have multiple number of mpi version, you can use \"mpiexecjl\" in your \"~/.julia/package/MPI/###/bin\" to make sure the version is correct. See https://juliaparallel.github.io/MPI.jl/stable/configuration/ for more detail.\nIn the MC, a normalization diagram is introduced to normalize the MC estimates of the integrands. More information can be found in the link: https://kunyuan.github.io/QuantumStatistics.jl/dev/man/important_sampling/#Important-Sampling. User don't need to explicitly specify this normalization diagram.Internally, normalization diagram will be added to each table that is related to the integrands.\n\nArguments\n\nintegrand:Function call to evaluate the integrand. It should accept an argument of the type Configuration, and return a weight.              Internally, MC only samples the absolute value of the weight. Therefore, it is also important to define Main.abs for the weight if its type is user-defined. \nsolver :  :vegas, :vegasmc, or :mcmc. See Readme for more details.\nconfig:   Configuration object to perform the MC integration. If nothing, it attempts to create a new one with Configuration(; kwargs...).\nneval:    Number of evaluations of the integrand per iteration. \nniter:    Number of iterations. The reweight factor and the variables will be self-adapted after each iteration. \nblock:    Number of blocks. Each block will be evaluated by about neval/block times. Each block is assumed to be statistically independent, and will be used to estimate the error.              In MPI mode, the blocks are distributed among the workers. If the numebr of workers N is larger than block, then block will be set to be N.\nprint:    -2 to not print anything; -1 to print minimal information; 0 to print the iteration history in the end; >0 to print MC configuration for every print seconds and print the iteration history in the end.\ngamma:    Learning rate of the reweight factor after each iteraction. Note that alpha <=1, where alpha = 0 means no reweighting.  \nadapt:    Whether to adapt the grid and the reweight factor.\ndebug:    Whether to print debug information (type instability, float overflow etc.)\nreweight_goal: The expected distribution of visited times for each integrand after reweighting . If not set, then all factors will be initialized with one. Only useful for the :mcmc solver. \nignore:   ignore the iteration until the ignore round. By default, the first iteration is igonred if adapt=true, and non is ignored if adapt=false.\nmeasure:  measurement function, See Vegas.montecarlo, VegasMC.montecarlo and MCMC.montecarlo for more details.\nmeasurefreq: how often perform the measurement for ever measurefreq MC steps. If a measurement is expansive, you may want to make the measurement less frequent.\nkwargs:   Keyword arguments. The supported keywords include,\nmeasure and measurefreq: measurement function and how frequent it is called. \nIf config is nothing, you may need to provide arguments for the Configuration constructor, check Configuration docs for more details.\n\nExamples\n\njulia> integrate((x, c)->(x[1]^2+x[2]^2); var = Continuous(0.0, 1.0), dof = 2, print=-1)\nIntegral 1 = 0.6668625385256122 ± 0.0009960142738129768   (chi2/dof = 1.07)\n\n\n\n\n\n","category":"method"},{"location":"lib/MCintegration/#NumericalEFT.MCIntegration.report","page":"Monte Carlo Integrator","title":"NumericalEFT.MCIntegration.report","text":"function report(result::Result, ignore=result.ignore; pick::Union{Function,AbstractVector}=obs -> first(obs), name=nothing, verbose=0)\n\nprint the summary of the result.  It will first print the configuration from the last iteration, then print the weighted average and standard deviation of the picked observable from each iteration.\n\nArguments\n\nresult: Result object contains the history from each iteration\nignore: the ignore the first # iteractions.\npick: The pick function is used to select one of the observable to be printed. The return value of pick function must be a Number.\nname: name of each picked observable. If name is not given, the index of the pick function will be used.\n\n\n\n\n\n","category":"function"},{"location":"lib/Feynmandiagram/#Feynman-Diagram","page":"Feynman Diagram","title":"Feynman Diagram","text":"","category":"section"},{"location":"lib/Feynmandiagram/#Diagrams-as-an-AbstractTree","page":"Feynman Diagram","title":"Diagrams as an AbstractTree","text":"","category":"section"},{"location":"lib/Feynmandiagram/","page":"Feynman Diagram","title":"Feynman Diagram","text":"Modules = [FeynmanDiagram.DiagTree]","category":"page"},{"location":"lib/Feynmandiagram/#NumericalEFT.FeynmanDiagram.DiagTree.BareGreenNId","page":"Feynman Diagram","title":"NumericalEFT.FeynmanDiagram.DiagTree.BareGreenNId","text":"time-ordered N-point Bare Green's function\n\n\n\n\n\n","category":"type"},{"location":"lib/Feynmandiagram/#NumericalEFT.FeynmanDiagram.DiagTree.BareHoppingId","page":"Feynman Diagram","title":"NumericalEFT.FeynmanDiagram.DiagTree.BareHoppingId","text":"hopping function c⁺c⁻\n\n\n\n\n\n","category":"type"},{"location":"lib/Feynmandiagram/#NumericalEFT.FeynmanDiagram.DiagTree.ConnectedGreenNId","page":"Feynman Diagram","title":"NumericalEFT.FeynmanDiagram.DiagTree.ConnectedGreenNId","text":"time-ordered N-point Composite Green's function\n\n\n\n\n\n","category":"type"},{"location":"lib/Feynmandiagram/#NumericalEFT.FeynmanDiagram.DiagTree.Diagram","page":"Feynman Diagram","title":"NumericalEFT.FeynmanDiagram.DiagTree.Diagram","text":"mutable struct Diagram{W}\n\nstruct of a diagram. A diagram of a sum or produce of various subdiagrams.\n\nMembers\n\nhash::Int          : the unique hash number to identify the diagram\nname::Symbol       : name of the diagram\nid::DiagramId      : diagram id \noperator::Operator : operation, support Sum() and Prod()\nfactor::W          : additional factor of the diagram\nsubdiagram::Vector{Diagram{W}}   : vector of sub-diagrams\nweight::W          : weight of the diagram\n\n\n\n\n\n","category":"type"},{"location":"lib/Feynmandiagram/#NumericalEFT.FeynmanDiagram.DiagTree.DiagramId","page":"Feynman Diagram","title":"NumericalEFT.FeynmanDiagram.DiagTree.DiagramId","text":"abstract type DiagramId end\n\nThe abstract type of all diagrams/subdiagrams/bare propagators\n\n\n\n\n\n","category":"type"},{"location":"lib/Feynmandiagram/#NumericalEFT.FeynmanDiagram.DiagTree.GreenNId","page":"Feynman Diagram","title":"NumericalEFT.FeynmanDiagram.DiagTree.GreenNId","text":"time-ordered N-point Composite Green's function\n\n\n\n\n\n","category":"type"},{"location":"lib/Feynmandiagram/#NumericalEFT.FeynmanDiagram.DiagTree.PropagatorId","page":"Feynman Diagram","title":"NumericalEFT.FeynmanDiagram.DiagTree.PropagatorId","text":"abstract type PropagatorId <: DiagramId end\n\nThe abstract type of all bare propagators\n\n\n\n\n\n","category":"type"},{"location":"lib/Feynmandiagram/#NumericalEFT.FeynmanDiagram.DiagTree.derivative-Union{Tuple{ID}, Tuple{Union{Tuple, AbstractVector}, Type{ID}, Int64}} where ID<:PropagatorId","page":"Feynman Diagram","title":"NumericalEFT.FeynmanDiagram.DiagTree.derivative","text":"function derivative(diags::Union{Diagram,Tuple,AbstractVector}, ::Type{ID}, order::Int) where {ID<:PropagatorId}\n\nAutomatic differentiation derivative on the diagrams\n\nArguments\n\ndiags      : diagrams to take derivative\nID         : DiagramId to apply the differentiation\norder::Int : derivative order\n\n\n\n\n\n","category":"method"},{"location":"lib/Feynmandiagram/#NumericalEFT.FeynmanDiagram.DiagTree.derivative-Union{Tuple{ID}, Tuple{W}, Tuple{Union{Tuple, AbstractVector}, Type{ID}}} where {W, ID<:PropagatorId}","page":"Feynman Diagram","title":"NumericalEFT.FeynmanDiagram.DiagTree.derivative","text":"function derivative(diags::Union{Tuple,AbstractVector}, ::Type{ID}; index::Int=index(ID)) where {W,ID<:PropagatorId}\nfunction derivative(diags::Vector{Diagram{W}}, ::Type{ID}; index::Int=index(ID)) where {W,ID<:PropagatorId}\n\nAutomatic differentiation derivative on the diagrams\n\nArguments\n\ndiags     : diagrams to take derivative\nID        : DiagramId to apply the differentiation\nindex     : index of the id.order array element to increase the order\n\n\n\n\n\n","category":"method"},{"location":"lib/Feynmandiagram/#NumericalEFT.FeynmanDiagram.DiagTree.plot_tree-Tuple{Diagram}","page":"Feynman Diagram","title":"NumericalEFT.FeynmanDiagram.DiagTree.plot_tree","text":"function plot_tree(diag::Diagram; verbose = 0, maxdepth = 6)\n\nVisualize the diagram tree using ete3 python package\n\n#Arguments\n\ndiag        : the Diagram struct to visualize\nverbose=0   : the amount of information to show\nmaxdepth=6  : deepest level of the diagram tree to show\n\n\n\n\n\n","category":"method"},{"location":"lib/Feynmandiagram/#NumericalEFT.FeynmanDiagram.DiagTree.removeDuplicatedLeaves!-Union{Tuple{Array{Diagram{W}, 1}}, Tuple{W}} where W","page":"Feynman Diagram","title":"NumericalEFT.FeynmanDiagram.DiagTree.removeDuplicatedLeaves!","text":"removeDuplicatedLeaves!(diags::AbstractVector; verbose = 0)\n\nremove duplicated nodes such as:  ---> ver4 ---> InteractionId. Leaf will not be touched!\n\n\n\n\n\n","category":"method"},{"location":"lib/Feynmandiagram/#NumericalEFT.FeynmanDiagram.DiagTree.removeHartreeFock!-Union{Tuple{Diagram{W}}, Tuple{W}} where W","page":"Feynman Diagram","title":"NumericalEFT.FeynmanDiagram.DiagTree.removeHartreeFock!","text":"function removeHartreeFock!(diag::Diagram{W}) where {W}\nfunction removeHartreeFock!(diags::Union{Tuple,AbstractVector})\n\nRemove the Hartree-Fock insertions that without any derivatives on the propagator and the interaction.\n\nArguments\n\ndiags      : diagrams to remove the Fock insertion\n\nRemarks\n\nThe operations removeHartreeFock! and taking derivatives doesn't commute with each other! \nIf the input diagram is a Hartree-Fock diagram, then the overall weight will become zero! \nThe return value is always nothing\n\n\n\n\n\n","category":"method"},{"location":"lib/Feynmandiagram/#NumericalEFT.FeynmanDiagram.DiagTree.removeOneChildParent!-Union{Tuple{Array{Diagram{W}, 1}}, Tuple{W}} where W","page":"Feynman Diagram","title":"NumericalEFT.FeynmanDiagram.DiagTree.removeOneChildParent!","text":"removeOneChildParent!(diags::AbstractVector; verbose = 0)\n\nremove duplicated nodes such as:  ---> ver4 ---> InteractionId. Leaf will not be touched!\n\n\n\n\n\n","category":"method"},{"location":"lib/Feynmandiagram/#Diagrams-as-an-Expression-Tree","page":"Feynman Diagram","title":"Diagrams as an Expression Tree","text":"","category":"section"},{"location":"lib/Feynmandiagram/","page":"Feynman Diagram","title":"Feynman Diagram","text":"Modules = [FeynmanDiagram.ExprTree]","category":"page"},{"location":"lib/Feynmandiagram/#NumericalEFT.FeynmanDiagram.ExprTree.CachedPool","page":"Feynman Diagram","title":"NumericalEFT.FeynmanDiagram.ExprTree.CachedPool","text":"struct CachedPool{O,T}\n\n    Use this pool to host the objects that are heavy to evaluate so that one wants to cache their status.\n    The user should defines a compare\n\nMembers\n\nname::Symbol : name of the pool\nobject::O    : object\ncurrent::T      : current status\nnew::T       : the new status wants to assign later\nversion::Int128 : the current version\nexcited::Bool   : if set to excited, then the current status needs to be replaced with the new status\n\n\n\n\n\n","category":"type"},{"location":"lib/Feynmandiagram/#NumericalEFT.FeynmanDiagram.ExprTree.ExpressionTree","page":"Feynman Diagram","title":"NumericalEFT.FeynmanDiagram.ExprTree.ExpressionTree","text":"mutable struct ExpressionTree{V,PARA,F,W}\n\nDiagram Object represents a set of Feynman diagrams in an experssion tree (forest) structure\n\nMembers\n\nname::Symbol                     : Name of the tree\nloopBasis::V                     : Tuple of pools of cached basis  in a format of (BasisPool1, BasisPool2, ...)\nnode::CachedPool{Node{PARA,F},W} : Pool of the nodes in the diagram tree\nroot::Vector{Int}                : indices of the cached nodes that are the root(s) of the diagram tree. Each element corresponds to one root.\n\n\n\n\n\n","category":"type"},{"location":"lib/Feynmandiagram/#NumericalEFT.FeynmanDiagram.ExprTree.LoopPool","page":"Feynman Diagram","title":"NumericalEFT.FeynmanDiagram.ExprTree.LoopPool","text":"struct LoopPool{T}\n\nPool of loop basis. Each loop basis corresponds to a loop variable.\nA loop variable is a linear combination of N independent loops. The combination coefficients is what we call a loop basis.\nFor example, if a loop is a momentum K, then\n\nvaribale_i = K_1*basis[1, i] + K_2*basis[2, i] + K_3*basis[3, i] + ...\n\nMembers\n\nname::Symbol : name of the pool\ndim::Int     : dimension of a loop variable (for example, the dimension of a momentum-frequency loop variable is (d+1) where d is the spatial dimension)\nN::Int       : number of independent loops (dimension of loop basis)\nbasis::Matrix{T}    : Matrix of (N x Nb) that stores the loop basis, where Nb is the number of loop basis (or number of loop variables).\ncurrent::Matrix{T}  : Matrix of (dim x Nb) that stores the loop variables, where Nb is the number of loop basis (or number of loop variables).\n\n\n\n\n\n","category":"type"},{"location":"lib/Feynmandiagram/#NumericalEFT.FeynmanDiagram.ExprTree.Node","page":"Feynman Diagram","title":"NumericalEFT.FeynmanDiagram.ExprTree.Node","text":"mutable struct Node{PARA,F}\n\nNode Object, which is the building block of the diagram tree. Each node is a collection of CACHED proapgator objects and other child CACHED node objects\n\nMembers\n\npara::PARA     : user-defined parameters, which will be used to evaluate the factor and the weight of the node (e.g., if the node represents a vertex function, then the parameter may be the momentum basis of the external legs)\noperation::Int : #1: multiply, 2: add, ...\nfactor::F      : additional factor of the node\ncomponents::Vector{Vector{Int}}  : Index to the cached propagators stored in certain pools. Each Vector{Int} is for one kind of propagator.\nchildNodes::Vector{Int}  : Indices to the cached nodes stored in certain pool. They are the child of the current node in the diagram tree.\nparent::Int : Index to the cached nodes which is the parent of the current node.\n\n\n\n\n\n","category":"type"},{"location":"lib/Feynmandiagram/#NumericalEFT.FeynmanDiagram.ExprTree.addnode!-Union{Tuple{W}, Tuple{F}, Tuple{PARA}, Tuple{V}, Tuple{ExpressionTree{V, PARA, F, W}, Any, Any, Union{Tuple, AbstractVector}}, Tuple{ExpressionTree{V, PARA, F, W}, Any, Any, Union{Tuple, AbstractVector}, Any}} where {V, PARA, F, W}","page":"Feynman Diagram","title":"NumericalEFT.FeynmanDiagram.ExprTree.addnode!","text":"function addnode!(diag::ExpressionTree{V,PARA,F,W}, operator, name, children::Union{Tuple, AbstractVector}, factor = 1.0; para = nothing) where {V,PARA,F,W}\n\nAdd a node into the expression tree.\n\nArguments\n\ndiag::ExpressionTree  : diagrammatic experssion tree.\noperator::Int         : #1: multiply, 2: add, ...\nname                  : name of the node\nchildren              : Indices to the cached nodes stored in certain pool. They are the child of the current node in the diagram tree. It should be in the format of Vector{Int}.\nfactor = 1.0          : Factor of the node\npara = nothing        : Additional paramenter required to evaluate the node. Set to nothing by default.\n\n\n\n\n\n","category":"method"},{"location":"lib/Feynmandiagram/#NumericalEFT.FeynmanDiagram.ExprTree.addpropagator!-Union{Tuple{W}, Tuple{F}, Tuple{PARA}, Tuple{V}, Tuple{ExpressionTree{V, PARA, F, W}, Any}, Tuple{ExpressionTree{V, PARA, F, W}, Any, Any}} where {V, PARA, F, W}","page":"Feynman Diagram","title":"NumericalEFT.FeynmanDiagram.ExprTree.addpropagator!","text":"function addPropagator!(diag::ExpressionTree, name, factor = 1.0; site = [], loop = nothing, para = nothing, order::Int = 0)\n\nAdd a propagator into the diagram tree.\n\nArguments\n\ndiag           : diagrammatic experssion tree.\norder::Int = 0 : Order of the propagator.\nname = :none   : name of the propagator.\nfactor = 1     : Factor of the propagator.\nsite = []      : site basis (e.g, time and space coordinate) of the propagator.\nloop = nothing : loop basis (e.g, momentum and frequency) of the propagator.\npara = nothing : Additional paramenter required to evaluate the propagator.\n\n\n\n\n\n","category":"method"},{"location":"lib/Feynmandiagram/#NumericalEFT.FeynmanDiagram.ExprTree.getNode-Tuple{Any, Int64}","page":"Feynman Diagram","title":"NumericalEFT.FeynmanDiagram.ExprTree.getNode","text":"function getNode(diag::Diagrams, nidx::Int)\n\nget Node in the diag with the index nidx.\n\n\n\n\n\n","category":"method"},{"location":"lib/Feynmandiagram/#NumericalEFT.FeynmanDiagram.ExprTree.getNodeWeight-Tuple{Any, Int64}","page":"Feynman Diagram","title":"NumericalEFT.FeynmanDiagram.ExprTree.getNodeWeight","text":"function getNodeWeight(tree, nidx::Int)\n\nget Node weight in the diagram experssion tree with the index nidx.\n\n\n\n\n\n","category":"method"},{"location":"lib/Feynmandiagram/#NumericalEFT.FeynmanDiagram.ExprTree.showTree-Tuple{ExpressionTree, Int64}","page":"Feynman Diagram","title":"NumericalEFT.FeynmanDiagram.ExprTree.showTree","text":"showTree(diag::Diagrams, _root = diag.root[end]; verbose = 0, depth = 999)\n\nVisualize the diagram tree using ete3 python package\n\n#Arguments\n\ndiag: the Diagrams struct to visualize\n_root: the index of the root node to visualize\nverbose=0: the amount of information to show\ndepth=999: deepest level of the diagram tree to show\n\n\n\n\n\n","category":"method"},{"location":"lib/Feynmandiagram/#Parquet-Algorithm-to-Build-Diagrams","page":"Feynman Diagram","title":"Parquet Algorithm to Build Diagrams","text":"","category":"section"},{"location":"lib/Feynmandiagram/","page":"Feynman Diagram","title":"Feynman Diagram","text":"Modules = [FeynmanDiagram.Parquet]","category":"page"},{"location":"lib/Feynmandiagram/#NumericalEFT.FeynmanDiagram.Parquet.ParquetBlocks","page":"Feynman Diagram","title":"NumericalEFT.FeynmanDiagram.Parquet.ParquetBlocks","text":"struct ParquetBlocks\n\nThe channels of the left and right sub-vertex4 of a bubble diagram in the parquet equation\n\n#Members\n\nphi   : channels of left sub-vertex for the particle-hole and particle-hole-exchange bubbles\nppi   : channels of left sub-vertex for the particle-particle bubble\nΓ4   : channels of right sub-vertex of all channels\n\n\n\n\n\n","category":"type"},{"location":"lib/Feynmandiagram/#NumericalEFT.FeynmanDiagram.Parquet.green-Union{Tuple{DiagPara{W}}, Tuple{W}, Tuple{DiagPara{W}, Any}, Tuple{DiagPara{W}, Any, Any}, Tuple{DiagPara{W}, Any, Any, Any}} where W","page":"Feynman Diagram","title":"NumericalEFT.FeynmanDiagram.Parquet.green","text":"green(para::DiagPara, extK = DiagTree.getK(para.totalLoopNum, 1), extT = para.hasTau ? (1, 2) : (0, 0), subdiagram = false;\n    name = :G, resetuid = false, blocks::ParquetBlocks=ParquetBlocks())\n\nBuild composite Green's function.\nBy definition, para.firstTauIdx is the first Tau index of the left most self-energy subdiagram.\n\nArguments\n\npara            : parameters. It should provide internalLoopNum, interactionTauNum, firstTauIdx\nextK            : basis of external loop. \nextT: [Tau index of the left leg, Tau index of the right leg]\nsubdiagram      : a sub-vertex or not\nname            : name of the diagram\nresetuid        : restart uid count from 1\nblocks          : building blocks of the Parquet equation. See the struct ParquetBlocks for more details.\n\nOutput\n\nA Diagram object or nothing if the Green's function is illegal. \n\n\n\n\n\n","category":"method"},{"location":"lib/Feynmandiagram/#NumericalEFT.FeynmanDiagram.Parquet.polarization-Union{Tuple{DiagPara{W}}, Tuple{W}, Tuple{DiagPara{W}, Any}, Tuple{DiagPara{W}, Any, Any}} where W","page":"Feynman Diagram","title":"NumericalEFT.FeynmanDiagram.Parquet.polarization","text":"function polarization(para, extK = DiagTree.getK(para.totalLoopNum, 1), subdiagram = false; name = :Π, resetuid = false, blocks::ParquetBlocks=ParquetBlocks())\n\nGenerate polarization diagrams using Parquet Algorithm.\n\nArguments\n\npara            : parameters. It should provide internalLoopNum, interactionTauNum, firstTauIdx\nextK            : basis of external loop. \nsubdiagram      : a sub-vertex or not\nname            : name of the vertex\nresetuid        : restart uid count from 1\nblocks          : building blocks of the Parquet equation. See the struct ParquetBlocks for more details.\n\nOutput\n\nA DataFrame with fields :response, :diagram, :hash. \nAll polarization share the same external Tau index. With imaginary-time variables, they are extT = (para.firstTauIdx, para.firstTauIdx+1)\n\n\n\n\n\n","category":"method"},{"location":"lib/Feynmandiagram/#NumericalEFT.FeynmanDiagram.Parquet.sigma-Union{Tuple{DiagPara{W}}, Tuple{W}, Tuple{DiagPara{W}, Any}, Tuple{DiagPara{W}, Any, Any}} where W","page":"Feynman Diagram","title":"NumericalEFT.FeynmanDiagram.Parquet.sigma","text":"function sigma(para, extK = DiagTree.getK(para.totalLoopNum, 1), subdiagram = false; name = :Σ, resetuid = false, blocks::ParquetBlocks=ParquetBlocks())\n\nBuild sigma diagram. \nWhen sigma is created as a subdiagram, then no Fock diagram is generated if para.filter contains NoFock, and no sigma diagram is generated if para.filter contains Girreducible\n\nArguments\n\npara            : parameters. It should provide internalLoopNum, interactionTauNum, firstTauIdx\nextK            : basis of external loop. \nsubdiagram      : a sub-vertex or not\nname            : name of the diagram\nresetuid        : restart uid count from 1\nblocks          : building blocks of the Parquet equation. See the struct ParquetBlocks for more details.\n\nOutput\n\nA DataFrame with fields :type, :extT, :diagram, :hash\nAll sigma share the same incoming Tau index, but not the outgoing one\n\n\n\n\n\n","category":"method"},{"location":"lib/Feynmandiagram/#NumericalEFT.FeynmanDiagram.Parquet.vertex3-Union{Tuple{DiagPara{WW}}, Tuple{WW}, Tuple{DiagPara{WW}, Any}, Tuple{DiagPara{WW}, Any, Any}} where WW","page":"Feynman Diagram","title":"NumericalEFT.FeynmanDiagram.Parquet.vertex3","text":"function vertex3(para, extK = [DiagTree.getK(para.totalLoopNum, 1), DiagTree.getK(para.totalLoopNum, 2)],\n    subdiagram = false; name = :Γ3, chan = [PHr, PHEr, PPr, Alli], resetuid = false, \n    blocks::ParquetBlocks=ParquetBlocks()\n    )\n\nGenerate 3-vertex diagrams using Parquet Algorithm.\nWith imaginary-time variables, all vertex3 generated has the same bosonic Tidx ``extT[1]=para.firstTauIdx`` and the incoming fermionic Tidx ``extT[2]=para.firstTauIdx+1``.\n\n#Arguments\n\npara            : parameters. It should provide internalLoopNum, interactionTauNum, firstTauIdx\nextK            : basis of external loops as a vector [bosonic leg, fermionic in, fermionic out]. \nsubdiagram      : a sub-vertex or not\nname            : name of the vertex\nchan            : vector of channels of the current 4-vertex. \nresetuid        : restart uid count from 1\nblocks          : building blocks of the Parquet equation. See the struct ParquetBlocks for more details.\n\nOutput\n\nA DataFrame with fields :response, :extT, :diagram, :hash. \n\n\n\n\n\n","category":"method"},{"location":"lib/Feynmandiagram/#NumericalEFT.FeynmanDiagram.Parquet.vertex4-Union{Tuple{DiagPara{W}}, Tuple{W}, Tuple{DiagPara{W}, Any}, Tuple{DiagPara{W}, Any, AbstractVector}, Tuple{DiagPara{W}, Any, AbstractVector, Any}} where W","page":"Feynman Diagram","title":"NumericalEFT.FeynmanDiagram.Parquet.vertex4","text":"vertex4(para::DiagPara,\n    extK = [DiagTree.getK(para.totalLoopNum, 1), DiagTree.getK(para.totalLoopNum, 2), DiagTree.getK(para.totalLoopNum, 3)],\n    chan::AbstractVector = [PHr, PHEr, PPr, Alli],\n    subdiagram = false;\n    level = 1, name = :none, resetuid = false,\n    subchannel::Symbol=:All, #:All, :W, :Lver3, :Rver3, :RPA\n    blocks::ParquetBlocks=ParquetBlocks(),\n    blockstoplevel::ParquetBlocks=blocks\n    )\n\nGenerate 4-vertex diagrams using Parquet Algorithm\n\nArguments\n\npara            : parameters. It should provide internalLoopNum, interactionTauNum, firstTauIdx\nextK            : basis of external loops as a vector [left in, left out, right in, right out]. \nchan            : vector of channels of the current 4-vertex. \nsubdiagram      : a sub-vertex or not\nname            : name of the vertex\nlevel           : level in the diagram tree\nresetuid        : restart uid count from 1\nsubchannel      : :All, :W, :Lver3, :Rver3, :RPA to select all, W-interaction, left-vertex-correction, right-vertex-correction or RPA-interaction diagrams\nblocks          : building blocks of the Parquet equation. See the struct ParquetBlocks for more details.\nblockstoplevel  : building blocks of the Parquet equation at the toplevel. See the struct ParquetBlocks for more details.\n\nOutput\n\nA DataFrame with fields :response, :type, :extT, :diagram, :hash\n\n\n\n\n\n","category":"method"},{"location":"lib/Feynmandiagram/#Usage","page":"Feynman Diagram","title":"Usage","text":"","category":"section"},{"location":"lib/Feynmandiagram/","page":"Feynman Diagram","title":"Feynman Diagram","text":"using FeynmanDiagram\npara = GenericPara(diagType = Ver4Diag, innerLoopNum = 1, hasTau = true);\nParquet.vertex4(para)\n\npara = GenericPara(diagType = Ver3Diag, innerLoopNum = 1, hasTau = true);\nParquet.vertex3(para)\n\npara = GenericPara(diagType = SigmaDiag, innerLoopNum = 1, hasTau = true);\nParquet.sigma(para)\n\npara = GenericPara(diagType = PolarDiag, innerLoopNum = 1, hasTau = true);\nParquet.polarization(para)","category":"page"},{"location":"man/DLR/","page":"Discrete Lehmann Representation","title":"Discrete Lehmann Representation","text":"CurrentModule = Lehmann","category":"page"},{"location":"man/DLR/#Lehmann.jl","page":"Discrete Lehmann Representation","title":"Lehmann.jl","text":"","category":"section"},{"location":"man/DLR/","page":"Discrete Lehmann Representation","title":"Discrete Lehmann Representation","text":"Documentation for Lehmann.jl.","category":"page"},{"location":"man/DLR/#Discrete-Lehmann-Representation-(DLR)","page":"Discrete Lehmann Representation","title":"Discrete Lehmann Representation (DLR)","text":"","category":"section"},{"location":"man/DLR/","page":"Discrete Lehmann Representation","title":"Discrete Lehmann Representation","text":"This package provides subroutines to represent and manuipulate Green's functions in the imaginary-time or in the Matsubara-frequency domain. ","category":"page"},{"location":"man/DLR/","page":"Discrete Lehmann Representation","title":"Discrete Lehmann Representation","text":"Imaginary-time Green's functions encode the thermodynamic properties of quantum many-body systems. At low temperature, they are typically very singular and hard to deal with in numerical calculations. ","category":"page"},{"location":"man/DLR/","page":"Discrete Lehmann Representation","title":"Discrete Lehmann Representation","text":"The physical Green's functions always have the analytic structure specified by the Lehmann representation,","category":"page"},{"location":"man/DLR/","page":"Discrete Lehmann Representation","title":"Discrete Lehmann Representation","text":"G(tau)=int_-infty^infty K(tau omega) rho(omega) d omega","category":"page"},{"location":"man/DLR/","page":"Discrete Lehmann Representation","title":"Discrete Lehmann Representation","text":"where tau is the imaginary time, omega is the real frequency. While the spectral density rho(omega) depends on the details of the quantum many-body system, the convolution kernel K(tau omega) is universal and is roughly an exponential function exp(-omega tau). ","category":"page"},{"location":"man/DLR/","page":"Discrete Lehmann Representation","title":"Discrete Lehmann Representation","text":"If one cares about the thermodynamic quantities, one only needs to manipulate the Green's functions. Then DLR allows us to represent the Green's function up to an accuracy epsilon with a fake spectral function only has a handful poles,","category":"page"},{"location":"man/DLR/","page":"Discrete Lehmann Representation","title":"Discrete Lehmann Representation","text":"G(tau) approx G_mathrmDLR(tau) equiv sum_k=1^r Kleft(tau omega_kright) widehatrho_k","category":"page"},{"location":"man/DLR/","page":"Discrete Lehmann Representation","title":"Discrete Lehmann Representation","text":"where r is called the rank of DLR. It is of the order,","category":"page"},{"location":"man/DLR/","page":"Discrete Lehmann Representation","title":"Discrete Lehmann Representation","text":"r sim log fracE_uvT log frac1ϵ","category":"page"},{"location":"man/DLR/","page":"Discrete Lehmann Representation","title":"Discrete Lehmann Representation","text":"where T is the temperature, E_uv is the ultraviolet energy scale beyond which the physical spectral function decays away, epsilon is the accuracy.","category":"page"},{"location":"man/DLR/","page":"Discrete Lehmann Representation","title":"Discrete Lehmann Representation","text":"The hallmarks of DLR are the following,","category":"page"},{"location":"man/DLR/","page":"Discrete Lehmann Representation","title":"Discrete Lehmann Representation","text":"In typical use cases, only dozens of coefficients are needed to represent the Green's functions up to the accuracy 1e-10.\nThe basis functions K(tau omega_i) are simple, explicit and analytic functions. It makes the Green's function manipulation (interpolation, fourier transform, convolution) rather simple in DLR.","category":"page"},{"location":"man/DLR/#Main-Features","page":"Discrete Lehmann Representation","title":"Main Features","text":"","category":"section"},{"location":"man/DLR/","page":"Discrete Lehmann Representation","title":"Discrete Lehmann Representation","text":"We provide the following components to ease the numerical manipulation of the Green's functions:","category":"page"},{"location":"man/DLR/","page":"Discrete Lehmann Representation","title":"Discrete Lehmann Representation","text":"Algorithms to generate the discrete Lehamnn representation (DLR), which is a generic and compact representation of Green's functions proposed in the Ref. [1]. In this package, two algorithms are provided: one algorithm is based on conventional QR algorithm, another is based on a functional QR algorithm. The latter extends DLR to extremely low temperature.\nDedicated DLR for Green's functions with the particle-hole symmetry (e.g. phonon propagator) or with the particle-hole antisymmetry (e.g. superconductor gap function).\nFast and accurate Fourier transform between the imaginary-time domain and the Matsubara-frequency domain with a cost sim O(log(1T)log(1ϵ)) and an accuracy ~100ϵ.\nFast and accurate Green's function interpolation with a cost sim O(log(1T)log(1ϵ)) and an accuracy ~100ϵ.\nFit a Green's function with noisy.","category":"page"},{"location":"man/DLR/#Reference","page":"Discrete Lehmann Representation","title":"Reference","text":"","category":"section"},{"location":"man/DLR/","page":"Discrete Lehmann Representation","title":"Discrete Lehmann Representation","text":"If this library helps you to create software or publications, please let us know, and cite","category":"page"},{"location":"man/DLR/","page":"Discrete Lehmann Representation","title":"Discrete Lehmann Representation","text":"[1] \"Discrete Lehmann representation of imaginary time Green's functions\", Jason Kaye, Kun Chen, and Olivier Parcollet, arXiv:2107.13094","category":"page"},{"location":"man/DLR/","page":"Discrete Lehmann Representation","title":"Discrete Lehmann Representation","text":"[2] \"libdlr: Efficient imaginary time calculations using the discrete Lehmann representation\", Jason Kaye and Hugo U.R. Strand, arXiv:2110.06765","category":"page"},{"location":"lib/fastmath/#Fast-Math-Functions","page":"Fast Math Functions","title":"Fast Math Functions","text":"","category":"section"},{"location":"lib/fastmath/","page":"Fast Math Functions","title":"Fast Math Functions","text":"Modules = [NumericalEFT.FastMath]","category":"page"},{"location":"lib/fastmath/#NumericalEFT.FastMath","page":"Fast Math Functions","title":"NumericalEFT.FastMath","text":"Provide a set of fast math functions\n\n\n\n\n\n","category":"module"},{"location":"lib/fastmath/#NumericalEFT.FastMath.invsqrt-Tuple{Float64}","page":"Fast Math Functions","title":"NumericalEFT.FastMath.invsqrt","text":"invsqrt(x)\n\nThe Legendary Fast Inverse Square Root See the following links: wikipedia and thesis\n\n\n\n\n\n","category":"method"},{"location":"man/tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"man/tutorial/#Numerical-Effective-Field-Theory","page":"Tutorial","title":"Numerical Effective Field Theory","text":"","category":"section"},{"location":"readme/Atom/#Atom","page":"Atom","title":"Atom","text":"","category":"section"},{"location":"readme/Atom/","page":"Atom","title":"Atom","text":"(Image: Stable) (Image: Dev) (Image: Build Status) (Image: Coverage)","category":"page"},{"location":"man/kernel/#Convention","page":"Lehmann representation convention","title":"Convention","text":"","category":"section"},{"location":"man/kernel/","page":"Lehmann representation convention","title":"Lehmann representation convention","text":"The kernel in the Lehammn representation is a function that only depends on the statistics of the quantum particles, and the symmetry of the Green's function. It is universal in the sense that it doesn't depend on the microscopic details of the quantum many-body system. ","category":"page"},{"location":"man/kernel/","page":"Lehmann representation convention","title":"Lehmann representation convention","text":"The definition of the kernel is not unique. Here we give the defintion in this package.","category":"page"},{"location":"man/kernel/","page":"Lehmann representation convention","title":"Lehmann representation convention","text":"We use the following conventions:","category":"page"},{"location":"man/kernel/","page":"Lehmann representation convention","title":"Lehmann representation convention","text":"Temperature T .\nInverse temperature beta= 1T.\nReal frequency omega.\nImaginary time tau.\nMatsubara frequancy iomega_n. \nFor the fermonic case, omega_n = (2n+1)pi T. \nFor the bosonic case,  omega_n = 2npi T\nFermionic Green's function is antiperiodic G(tau)=-G(beta+tau). \nBosonic one is periodic G(tau)=G(beta+tau). \nDon't confuse the periodicity with the time-reversal symmetry (a.k.a, particle-hole symmetry). \nFourier transform follows the convention in the book \"Quantum Many-particle Systems\" by J. Negele and H. Orland, Page 95,","category":"page"},{"location":"man/kernel/","page":"Lehmann representation convention","title":"Lehmann representation convention","text":"G(tau) = frac1beta sum_n G(iomega_n) texte^-iomega_n tau","category":"page"},{"location":"man/kernel/","page":"Lehmann representation convention","title":"Lehmann representation convention","text":"G(iomega_n) = int_0^beta G(tau) texte^iomega_n tau dtau","category":"page"},{"location":"man/kernel/#Fermion-without-Symmetry","page":"Lehmann representation convention","title":"Fermion without Symmetry","text":"","category":"section"},{"location":"man/kernel/","page":"Lehmann representation convention","title":"Lehmann representation convention","text":"Imaginary time ","category":"page"},{"location":"man/kernel/","page":"Lehmann representation convention","title":"Lehmann representation convention","text":"K(τ ω) = frace^-ωτ1+e^-ωβ","category":"page"},{"location":"man/kernel/","page":"Lehmann representation convention","title":"Lehmann representation convention","text":"Matusbara frequency ","category":"page"},{"location":"man/kernel/","page":"Lehmann representation convention","title":"Lehmann representation convention","text":"K(iω_n ω) = -frac1iω_n-ω","category":"page"},{"location":"man/kernel/#Boson-without-Symmetry","page":"Lehmann representation convention","title":"Boson without Symmetry","text":"","category":"section"},{"location":"man/kernel/","page":"Lehmann representation convention","title":"Lehmann representation convention","text":"We use a bosonic kernel with a regularator near omega =. The imaginary-time kernel happens to be the same as the fermionic kernel. The details can be found in Appendix A of this DLR paper. ","category":"page"},{"location":"man/kernel/","page":"Lehmann representation convention","title":"Lehmann representation convention","text":"Imaginary time ","category":"page"},{"location":"man/kernel/","page":"Lehmann representation convention","title":"Lehmann representation convention","text":"K(τ ω) = frace^-ωτ1+e^-ωβ","category":"page"},{"location":"man/kernel/","page":"Lehmann representation convention","title":"Lehmann representation convention","text":"Matusbara frequency ","category":"page"},{"location":"man/kernel/","page":"Lehmann representation convention","title":"Lehmann representation convention","text":"K(iω_n ω) = -frac1iω_n-ωfrac1-e^-ωβ1+e^-ωβ","category":"page"},{"location":"man/kernel/#Fermion-with-the-Particle-hole-Symmetry","page":"Lehmann representation convention","title":"Fermion with the Particle-hole Symmetry","text":"","category":"section"},{"location":"man/kernel/","page":"Lehmann representation convention","title":"Lehmann representation convention","text":"Particle-hole symmetry means the time reversal symmetry, so that G(tau)=G(beta-tau).","category":"page"},{"location":"man/kernel/","page":"Lehmann representation convention","title":"Lehmann representation convention","text":"Imaginary time","category":"page"},{"location":"man/kernel/","page":"Lehmann representation convention","title":"Lehmann representation convention","text":"K(τ ω) = e^-ωτ+e^-ω(β-τ)","category":"page"},{"location":"man/kernel/","page":"Lehmann representation convention","title":"Lehmann representation convention","text":"Matusbara frequency","category":"page"},{"location":"man/kernel/","page":"Lehmann representation convention","title":"Lehmann representation convention","text":"K(iω_n ω) = frac2iω_nω^2+ω_n^2(1+e^-ωβ)","category":"page"},{"location":"man/kernel/#Boson-with-the-Particle-hole-Symmetry","page":"Lehmann representation convention","title":"Boson with the Particle-hole Symmetry","text":"","category":"section"},{"location":"man/kernel/","page":"Lehmann representation convention","title":"Lehmann representation convention","text":"Particle-hole symmetry means the time reversal symmetry, so that G(tau)=G(beta-tau).","category":"page"},{"location":"man/kernel/","page":"Lehmann representation convention","title":"Lehmann representation convention","text":"Imaginary time","category":"page"},{"location":"man/kernel/","page":"Lehmann representation convention","title":"Lehmann representation convention","text":"K(τ ω) = e^-ωτ+e^-ω(β-τ)","category":"page"},{"location":"man/kernel/","page":"Lehmann representation convention","title":"Lehmann representation convention","text":"Matusbara frequency","category":"page"},{"location":"man/kernel/","page":"Lehmann representation convention","title":"Lehmann representation convention","text":"K(iω_n ω) = frac2ωω^2+ω_n^2(1-e^-ωβ)","category":"page"},{"location":"man/kernel/#Fermion-with-the-Particle-hole-Anti-Symmetry","page":"Lehmann representation convention","title":"Fermion with the Particle-hole Anti-Symmetry","text":"","category":"section"},{"location":"man/kernel/","page":"Lehmann representation convention","title":"Lehmann representation convention","text":"Particle-hole antisymmetry means the time reversal symmetry, so that G(tau)=-G(beta-tau).","category":"page"},{"location":"man/kernel/","page":"Lehmann representation convention","title":"Lehmann representation convention","text":"Imaginary time","category":"page"},{"location":"man/kernel/","page":"Lehmann representation convention","title":"Lehmann representation convention","text":"K(τ ω) = e^-ωτ-e^-ω(β-τ)","category":"page"},{"location":"man/kernel/","page":"Lehmann representation convention","title":"Lehmann representation convention","text":"Matusbara frequency","category":"page"},{"location":"man/kernel/","page":"Lehmann representation convention","title":"Lehmann representation convention","text":"K(iω_n ω) = frac2ωω^2+ω_n^2(1+e^-ωβ)","category":"page"},{"location":"man/kernel/#Boson-with-the-Particle-hole-Anti-Symmetry","page":"Lehmann representation convention","title":"Boson with the Particle-hole Anti-Symmetry","text":"","category":"section"},{"location":"man/kernel/","page":"Lehmann representation convention","title":"Lehmann representation convention","text":"Particle-hole antisymmetry means the time reversal symmetry, so that G(tau)=-G(beta-tau).","category":"page"},{"location":"man/kernel/","page":"Lehmann representation convention","title":"Lehmann representation convention","text":"Imaginary time","category":"page"},{"location":"man/kernel/","page":"Lehmann representation convention","title":"Lehmann representation convention","text":"K(τ ω) = e^-ωτ-e^-ω(β-τ)","category":"page"},{"location":"man/kernel/","page":"Lehmann representation convention","title":"Lehmann representation convention","text":"Matusbara frequency","category":"page"},{"location":"man/kernel/","page":"Lehmann representation convention","title":"Lehmann representation convention","text":"K(iω_n ω) = frac2iω_nω^2+ω_n^2(1-e^-ωβ)","category":"page"},{"location":"readme/CompositeGrids/","page":"CompositeGrids","title":"CompositeGrids","text":"(Image: img) (Image: img) (Image: img)","category":"page"},{"location":"readme/CompositeGrids/#Introduction","page":"CompositeGrids","title":"Introduction","text":"","category":"section"},{"location":"readme/CompositeGrids/","page":"CompositeGrids","title":"CompositeGrids","text":"CompositeGrids gives a unified interface to generate various common 1D grids and also the composite grids that is a combination of basic grids, together with the floor function, interpolation function and also integration function that is optimized for some of the grids.","category":"page"},{"location":"readme/CompositeGrids/#Quick-Start","page":"CompositeGrids","title":"Quick Start","text":"","category":"section"},{"location":"readme/CompositeGrids/","page":"CompositeGrids","title":"CompositeGrids","text":"In the following example we show how to generate a &tau; grid from 0 to &beta;, log-densed at 0 and &beta;, and optimized for integration. The description is attached in the comments in the code.","category":"page"},{"location":"readme/CompositeGrids/","page":"CompositeGrids","title":"CompositeGrids","text":"    using CompositeGrids\n    β = 10\n    \n    # Generating a log densed composite grid with LogDensedGrid()\n    tgrid = CompositeGrid.LogDensedGrid(\n        :gauss,# The top layer grid is :gauss, optimized for integration. For interpolation use :cheb\n        [0.0, β],# The grid is defined on [0.0, β]\n        [0.0, β],# and is densed at 0.0 and β, as given by 2nd and 3rd parameter.\n        5,# N of log grid\n        0.005, # minimum interval length of log grid\n        5 # N of bottom layer\n    )\n    # The grid has 3 layers.\n    # The top layer is defined by the boundary and densed points. In this case its:\n    println(\"Top layer:\",tgrid.panel.grid)\n    # The middle layer is a log grid with 4 points and minimum interval length 0.001:\n    println(\"First subgrid of middle layer:\",tgrid.subgrids[1].panel.grid)\n    # The bottom layer is a Gauss-Legendre grid with 5 points:\n    println(\"First subgrid of bottom layer:\",tgrid.subgrids[1].subgrids[1].grid)\n    \n    # function to be integrated:\n    f(t) = exp(t)+exp(β-t)\n    # numerical value on grid points:\n    data = [f(t) for (ti, t) in enumerate(tgrid.grid)]\n    \n    # integrate with integrate1D():\n    int_result = Interp.integrate1D(data, tgrid)\n    \n    println(\"result=\",int_result)\n    println(\"comparing to:\",2*(exp(β)-1))","category":"page"},{"location":"readme/CompositeGrids/","page":"CompositeGrids","title":"CompositeGrids","text":"    Top layer:[0.0, 5.0, 10.0]\n    First subgrid of middle layer:[0.0, 0.005000000000000001, 0.05000000000000001, 0.5, 5.0]\n    First subgrid of bottom layer:[0.00023455038515334025, 0.0011538267247357924, 0.0025000000000000005, 0.0038461732752642086, 0.004765449614846661]\n    result=44050.91248775534\n    comparing to:44050.931589613436","category":"page"},{"location":"readme/CompositeGrids/#Installation","page":"CompositeGrids","title":"Installation","text":"","category":"section"},{"location":"readme/CompositeGrids/","page":"CompositeGrids","title":"CompositeGrids","text":"Static version could be installed via standard package manager with Pkg.add(\"CompositeGrids\").","category":"page"},{"location":"readme/CompositeGrids/","page":"CompositeGrids","title":"CompositeGrids","text":"For developing version, git clone this repo and add with Pkg.develop(\"directory/of/the/repo\").","category":"page"},{"location":"readme/CompositeGrids/#Manual","page":"CompositeGrids","title":"Manual","text":"","category":"section"},{"location":"readme/CompositeGrids/#Basics","page":"CompositeGrids","title":"Basics","text":"","category":"section"},{"location":"readme/CompositeGrids/","page":"CompositeGrids","title":"CompositeGrids","text":"The grids are provided in two modules, SimpleGrid and CompositeGrid. SimpleGrid consists of several common 1D grids that is defined straightforward and has simple structure. CompositeGrid defines a general type of grids composed by a panel grid and a set of subgrids. The common interface of grids are the following:","category":"page"},{"location":"readme/CompositeGrids/","page":"CompositeGrids","title":"CompositeGrids","text":"g.bound gives the boundary of the interval of the grid.\ng.size gives the total number of grid points.\ng.grid gives the array of grid points.\ng[i] returns the i-th grid point, same as g.grid[i].\nfloor(g, x) returns the largest index of grid point where g[i]<x. Return 1 for x<g[1] and (grid.size-1) for x>g[end], so that both floor() and (floor()+1) are valid grid indices.","category":"page"},{"location":"readme/CompositeGrids/","page":"CompositeGrids","title":"CompositeGrids","text":"Interpolation and integration are also provided, with different implemented functions for different grids.","category":"page"},{"location":"readme/CompositeGrids/#Simple-Grids","page":"CompositeGrids","title":"Simple Grids","text":"","category":"section"},{"location":"readme/CompositeGrids/","page":"CompositeGrids","title":"CompositeGrids","text":"Various basic grids are designed for use and also as components of composite grids, including: Arbitrary, Uniform, Log, BaryCheb, and GaussLegendre.","category":"page"},{"location":"readme/CompositeGrids/","page":"CompositeGrids","title":"CompositeGrids","text":"Arbitrary grid is the most general basic grid, which takes an array and turn it into a grid. An O(ln(N)) floor function based on searchsortedfirst() is provided.","category":"page"},{"location":"readme/CompositeGrids/","page":"CompositeGrids","title":"CompositeGrids","text":"Uniform grid is defined by the boundary and number of grid points. An O(1) floor function is provided.","category":"page"},{"location":"readme/CompositeGrids/","page":"CompositeGrids","title":"CompositeGrids","text":"Log grid is defined by the boundary, number of grid points, minimum interval, and also the direction. A log densed grid is generated according to the parameters provided. For example:","category":"page"},{"location":"readme/CompositeGrids/","page":"CompositeGrids","title":"CompositeGrids","text":"    using CompositeGrids\n    loggrid = SimpleGrid.Log{Float64}([0.0,1.0], 6, 0.0001, true)\n    println(loggrid.grid)","category":"page"},{"location":"readme/CompositeGrids/","page":"CompositeGrids","title":"CompositeGrids","text":"    [0.0, 0.00010000000000000005, 0.0010000000000000002, 0.010000000000000002, 0.1, 1.0]","category":"page"},{"location":"readme/CompositeGrids/","page":"CompositeGrids","title":"CompositeGrids","text":"An O(1) floor function is provided.","category":"page"},{"location":"readme/CompositeGrids/","page":"CompositeGrids","title":"CompositeGrids","text":"BaryCheb grid is designed for interpolation. It's defined by the boundary and number of grid points, but the grid points are not distributed uniformly. The floor function is not optimized so the O(ln(N)) function will be used, but the interpolation is based on an optimized algorithm.","category":"page"},{"location":"readme/CompositeGrids/","page":"CompositeGrids","title":"CompositeGrids","text":"GaussLegendre grid is designed for integration. It's defined by the boundary and number of grid points, but the grid points are not distributed uniformly. The floor function is not optimized so the O(ln(N)) function will be used. The 1D integration is optimized.","category":"page"},{"location":"readme/CompositeGrids/","page":"CompositeGrids","title":"CompositeGrids","text":"Also notice that there's open grids and closed grids. Closed grids means that the boundary points are also grid points, while open grids means the opposite. Only BaryCheb and GaussLegendre are open.","category":"page"},{"location":"readme/CompositeGrids/","page":"CompositeGrids","title":"CompositeGrids","text":"A detailed manual can be found here.","category":"page"},{"location":"readme/CompositeGrids/#Composite-Grids","page":"CompositeGrids","title":"Composite Grids","text":"","category":"section"},{"location":"readme/CompositeGrids/","page":"CompositeGrids","title":"CompositeGrids","text":"Composite grid is a general type of grids where the whole interval is first divided by a panel grid, then each interval of a panel grid is divided by a smaller grid in subgrids. Subgrid could also be composite grid.","category":"page"},{"location":"readme/CompositeGrids/","page":"CompositeGrids","title":"CompositeGrids","text":"LogDensedGrid is a useful generator of CompositeGrid which gives a general solution when an 1D grid on an interval is needed to be log-densed around several points. For example, &tau; grids need to be densed around 0 and &beta;, and momentum grids need to be densed around Fermi momentum. The grid is defined as a three-layer composite grid with the top layer being an Arbitrary grid defined by the boundary and densed points, the middle layer a Log grid which is densed at the points required, and the bottom layer a grid of three options. Three types are :cheb, :gauss, and :uniform, which corresponds to BaryCheb grid for interpolation, GaussLegendre grid for integration, and Uniform grid for general use. The floor function is defined recursively, i.e. the floor function of the panel grid is called to find the corresponding subgrid, and then the floor function of the subgrid is called to find the result. Since the subgrids could also be CompositeGrid, this process continues until the lowest level of the subgrids is reached.","category":"page"},{"location":"readme/CompositeGrids/","page":"CompositeGrids","title":"CompositeGrids","text":"A detailed manual can be found here.","category":"page"},{"location":"readme/CompositeGrids/#Interpolation-and-Integration","page":"CompositeGrids","title":"Interpolation and Integration","text":"","category":"section"},{"location":"readme/CompositeGrids/","page":"CompositeGrids","title":"CompositeGrids","text":"Interpolation gives an estimate of the function value at x with given grid and function value on the grid. For most of the simple grids the interpolation is given by linear interpolation with the floor function to find the corresponding grid points. BaryCheb uses an optimized algorithm for interpolation which makes use of the information of all grid points, and thus gives a more precise interpolation with the same number of grid points, given the condition that the function itself is smooth enough. For composite grids, the interpolation is done recursively, so that the final result depends on the type of lowest level grid. Interpolation for higher dimension where the data is defined on a list of grids is also given, but only linear interpolation is implemented, even when some of the grids are BaryCheb.","category":"page"},{"location":"readme/CompositeGrids/","page":"CompositeGrids","title":"CompositeGrids","text":"Integration over 1D grid is also provided. For most of simple grids it's given by linear integral, while for GaussLegendre grid it's optimized. For composite grids it's again recursively done so that the method depends on the type of lowest level grids.","category":"page"},{"location":"readme/CompositeGrids/","page":"CompositeGrids","title":"CompositeGrids","text":"A detailed manual can be found here.","category":"page"},{"location":"readme/GreenFunc/#GreenFunc","page":"GreenFunc","title":"GreenFunc","text":"","category":"section"},{"location":"readme/GreenFunc/","page":"GreenFunc","title":"GreenFunc","text":"(Image: Stable) (Image: Dev) (Image: Build Status) (Image: Coverage)","category":"page"},{"location":"readme/GreenFunc/","page":"GreenFunc","title":"GreenFunc","text":"This library provides structures of different types of Green's function. Here we give a introduction of these Green's function.","category":"page"},{"location":"readme/GreenFunc/#Features","page":"GreenFunc","title":"Features","text":"","category":"section"},{"location":"readme/GreenFunc/","page":"GreenFunc","title":"GreenFunc","text":"We provide the following containers to save different Green's functions:","category":"page"},{"location":"readme/GreenFunc/","page":"GreenFunc","title":"GreenFunc","text":"-One body Green's function that has a built-in discrete Lehamnn representation (DLR),  which is a generic and  compact representation of Green's functions proposed in the Ref. [1]. ","category":"page"},{"location":"readme/GreenFunc/","page":"GreenFunc","title":"GreenFunc","text":"For all Green's functions we provide the following manipulations:","category":"page"},{"location":"readme/GreenFunc/","page":"GreenFunc","title":"GreenFunc","text":"Fast and accurate Fourier transform between the imaginary-time domain and the Matsubara-frequency domain.\nFast and accurate Green's function interpolation.","category":"page"},{"location":"readme/GreenFunc/#Installation","page":"GreenFunc","title":"Installation","text":"","category":"section"},{"location":"readme/GreenFunc/","page":"GreenFunc","title":"GreenFunc","text":"This package has been registered. So, simply type import Pkg; Pkg.add(\"GreenFunc\") in the Julia REPL to install.","category":"page"},{"location":"readme/GreenFunc/#Basic-Usage","page":"GreenFunc","title":"Basic Usage","text":"","category":"section"},{"location":"man/important_sampling/#Important-Sampling","page":"Important Sampling","title":"Important Sampling","text":"","category":"section"},{"location":"man/important_sampling/#Introduction","page":"Important Sampling","title":"Introduction","text":"","category":"section"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"This note compares two important sampling approaches for Monte Carlo integration. The first approach introduces a normalization sector and lets the Markov chain jumps between this additional sector and the integrand sector following a calibrated probability density for important sampling. One can infer the integration between the ratio of weights between two sectors. On the other hand, the second approach reweights the original integrand to make it as flat as possible, one then perform a random walk uniformly in the parameter space to calculate the integration. This is the conventional approach used in Vegas algorithm.","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"In general, the first approach is more robust than the second one, but less efficient. In many applications, for example, high order Feynman diagrams with a sign alternation, the important sampling probability can't represent the complicated integrand well. Then the first approach is as efficient as the second one, but tends to be much robust.","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"We next present a benchmark between two approaches. Consider the MC sampling of an one-dimensional functions f(x) (its sign may oscillate).","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"We want to design an efficient algorithm to calculate the integral int_a^b dx f(x). To do that, we normalize the integrand with an ansatz g(x)0 to reduce the variant. ","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"Our package supports two important sampling schemes. ","category":"page"},{"location":"man/important_sampling/#Approach-1:-Algorithm-with-a-Normalization-Sector","page":"Important Sampling","title":"Approach 1: Algorithm with a Normalization Sector","text":"","category":"section"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"In this approach, the configuration spaces consist of two sub-spaces: the physical sector with orders nge 1 and the normalization sector with the order n=0. The weight function of the latter, g(x), should be simple enough so that the integral G=int g(x) d x is explicitly known. In our algorithm we use a constant g(x) propto 1 for simplicity. In this setup, the physical sector weight, namely the integral F = int f(x) dx, can be calculated with the equation","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"    F=fracF_rm MCG_rm MC G","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"where the MC estimators F_rm MC and G_rm MC are measured with ","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"F_rm MC =frac1N left sum_i=1^N_f fracf(x_i)rho_f(x_i) + sum_i=1^N_g 0 right","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"and","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"G_rm MC =frac1N leftsum_i=1^N_f 0 + sum_i=1^N_g fracg(x_i)rho_g(x_i)  right","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"The probability density of a given configuration is proportional to rho_f(x)=f(x) and rho_g(x)=g(x), respectively. After N MC updates, the physical sector is sampled for N_f times, and the normalization sector is for N_g times. ","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"Now we estimate the statistic error. According to the propagation of uncertainty, the variance of F  is given by","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":" fracsigma^2_FF^2 =  fracsigma_F_rm MC^2F_MC^2 + fracsigma_G_rm MC^2G_MC^2 ","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"where sigma_F_rm MC and sigma_G_rm MC are variance of the MC integration F_rm MC and G_rm MC, respectively. In the Markov chain MC, the variance of F_rm MC can be written as ","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"sigma^2_F_rm MC = frac1N left sum_i^N_f left( fracf(x_i)rho_f(x_i)- fracFZright)^2 +sum_j^N_g left(0-fracFZ right)^2  right ","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"= int left( fracf(x)rho_f(x) - fracFZ right)^2 fracrho_f(x)Z rm dx + int left( fracFZ right)^2 fracrho_g(x)Z dx ","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"=  int fracf^2(x)rho_f(x) fracdxZ -fracF^2Z^2 ","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"Here Z=Z_f+Z_g and Z_fg=int rho_fg(x)dx are the partition sums of the corresponding configuration spaces. Due to the detailed balance, one has Z_fZ_g=N_fN_g.  ","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"Similarly, the variance of G_rm MC can be written as ","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"sigma^2_G_rm MC=  int fracg^2(x)rho_g(x) fracdxZ - fracG^2Z^2","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"By substituting rho_f(x)=f(x) and  rho_g(x)=g(x), the variances of F_rm MC and G_rm MC are given by","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"sigma^2_F_rm MC= frac1Z^2 left( Z Z_f - F^2 right)","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"sigma^2_G_rm MC= frac1Z^2 left( Z Z_g - G^2 right)","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"We derive the variance of F as","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"fracsigma^2_FF^2 = fracZ cdot Z_fF^2+fracZ cdot Z_gG^2 - 2 ","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"Note that g(x)0 indicates Z_g = G,  so that","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"fracsigma^2_FF^2 = fracZ_f^2F^2+fracGcdot Z_fF^2+fracZ_fG - 1","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"Interestingly, this variance is a function of G instead of a functional of g(x). It is then possible to normalized g(x) with a constant to minimize the variance. The optimal constant makes G to be,","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"fracd sigma^2_FdG=0","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"which makes G_best = F. The minimized the variance is given by,","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"fracsigma^2_FF^2= left(fracZ_fF+1right)^2 - 2ge 0","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"The equal sign is achieved when f(x)0 is positively defined.","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"It is very important that the above analysis is based on the assumption that the autocorrelation time negligible. The autocorrelation time related to the jump between the normalization and physical sectors is controlled by the deviation of the ratio f(x)g(x) from unity. The variance sigma_F^2 given above will be amplified to sim sigma_F^2 tau where tau is the autocorrelation time.","category":"page"},{"location":"man/important_sampling/#Approach-2:-Conventional-algorithm-(e.g.,-Vegas-algorithm)","page":"Important Sampling","title":"Approach 2: Conventional algorithm (e.g., Vegas algorithm)","text":"","category":"section"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"Important sampling is actually more straightforward than the above approach. One simply sample x with a distribution rho_g(x)=g(x)Z_g, then measure the observable f(x)g(x). Therefore, the mean estimation,","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"fracFZ=int dx fracf(x)g(x) rho_g(x)","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"the variance of F in this approach is given by,","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"sigma_F^2=Z_g^2int dx left( fracf(x)g(x)- fracFZ_gright)^2rho_g(x)","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"fracsigma_F^2F^2=fracZ_gF^2int dx fracf(x)^2g(x)- 1","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"The optimal g(x) that minimizes the variance is g(x) =f(x),","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"fracsigma_F^2F^2=fracZ_f^2F^2-1","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"The variance of the conventional approach is a functional of g(x), while that of the previous approach isn't. There are two interesting limit:\nIf the f(x)0, the optimal choice g(x)=f(x) leads to zero variance. In this limit, the conventional approach is clearly much better than the previous approach.\nOn the other hand, if g(x) is far from the optimal choice f(x), say simply setting g(x)=1, one naively expect that the the conventional approach may leads to much larger variance than the previous approach. However,  this statement may not be true. If g(x) is very different from f(x), the normalization and the physical sector in the previous approach mismatch, causing large autocorrelation time and large statistical error . In contrast, the conventional approach doesn't have this problem.","category":"page"},{"location":"man/important_sampling/#Benchmark","page":"Important Sampling","title":"Benchmark","text":"","category":"section"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"To benchmark, we sample the following integral up to 10^8 updates, ","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"int_0^beta e^-(x-beta2)^2delta^2dx approx sqrtpidelta","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"where beta gg delta.","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"g(x)=f(x)","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"Normalization Sector:  doesn't lead to exact result, the variance left(fracZ_fF+1right)^2 - 2=2 doesn't change with parameters","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"beta 10 100\nresult 0.1771(1) 0.1773(1)","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"Conventional: exact result","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"g(x)=sqrtpideltabeta1","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"beta 10 100\nNormalization 0.1772(4) 0.1767(17)\nConventional 0.1777(3) 0.1767(8)","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"g(x)=exp(-(x-beta2+s)^2delta^2) with beta=100","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"s delta 2delta 3delta 4delta 5delta\nNormalization 0.1775(8) 0.1767(25) 0.1770(60) 0.176(15) 183(143)\nConventional 0.1776(5) 0.1707(39) 0.1243(174) 0.0204 (64) ","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"The conventional algorithm is not ergodic anymore for s=4delta, the acceptance ratio to update x is about 015, while the normalization algorithm becomes non ergodic for s=5delta. So the latter is slightly more stable.","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"<!– The code are ![[test.jl]] for the normalization approach and ![[test2.jl]] for the conventional approach. –>","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"Reference:  [1] Wang, B.Z., Hou, P.C., Deng, Y., Haule, K. and Chen, K., Fermionic sign structure of high-order Feynman diagrams in a many-fermion system. Physical Review B, 103, 115141 (2021).","category":"page"},{"location":"lib/greenfunc/#Green's-Function","page":"Green's Function","title":"Green's Function","text":"","category":"section"},{"location":"lib/greenfunc/","page":"Green's Function","title":"Green's Function","text":"Modules = [NumericalEFT.GreenFunc]","category":"page"},{"location":"lib/greenfunc/#NumericalEFT.GreenFunc.Green2DLR","page":"Green's Function","title":"NumericalEFT.GreenFunc.Green2DLR","text":"Green's function with two external legs that has in-built Discrete Lehmann Representation. #Parameters:\n\n'T': type of data\n'TType': type of time domain, TType<:TimeDomain\n'TGT': type of time grid\n'SGT': type of space grid\n\n#Members:\n\n'name': Name of green's function\n'color': Number of different species of Green's function (such as different spin values)\n'dlrGrid': In-built Discrete Lehmann Representation\n'timeGrid': Time or Frequency grid\n'spaceType': Whether the Green's function is in coordinate space/momentum space\n'spaceGrid': Coordinate or momentum grid\n'instant': Instantaneous part of Green's function that is proportional to δ(τ) in τ space.\n'dynamic': Dynamic part of Green's function\n'instantError': Error of instantaneous part\n'dynamicError': Error of dynamic part\n\n\n\n\n\n","category":"type"},{"location":"lib/greenfunc/#NumericalEFT.GreenFunc.GreenSym2DLR","page":"Green's Function","title":"NumericalEFT.GreenFunc.GreenSym2DLR","text":"Symmetrized Green's function with two external legs that has in-built Discrete Lehmann Representation. The real and imaginary parts are saved separately on corresponding symmetrized DLR grids.  #Parameters:\n\n'T': type of data\n'TType': type of time domain, TType<:TimeDomain\n'TGT': type of time grid\n'SGT': type of space grid\n\n#Members:\n\n'name': Name of green's function\n'color': Number of different species of Green's function (such as different spin values)\n'dlrGrid': In-built Discrete Lehmann Representation\n'timeGrid': Time or Frequency grid\n'spaceType': Whether the Green's function is in coordinate space/momentum space\n'spaceGrid': Coordinate or momentum grid\n'instant': Instantaneous part of Green's function that is proportional to δ(τ) in τ space.\n'dynamic': Dynamic part of Green's function\n'instantError': Error of instantaneous part\n'dynamicError': Error of dynamic part\n\n\n\n\n\n","category":"type"},{"location":"lib/greenfunc/#NumericalEFT.GreenFunc._dynamic-Union{Tuple{SGT}, Tuple{TGT}, Tuple{TT}, Tuple{DT}, Tuple{Any, Any}} where {DT, TT, TGT<:NumericalEFT.CompositeGrids.SimpleG.AbstractGrid, SGT<:NumericalEFT.CompositeGrids.SimpleG.AbstractGrid}","page":"Green's Function","title":"NumericalEFT.GreenFunc._dynamic","text":"function dynamic(green::Union{Green2DLR{DT,TT,TGT,SGT},GreenSym2DLR{DT,TT,TGT,SGT}}, time, space, color1::Int, color2::Int, timeMethod::TM , spaceMethod::SM) where {DT,TT,TGT<:CompositeGrids.AbstractGrid,SGT<:CompositeGrids.AbstractGrid,TM,SM}\n\nFind value of Green's function's dynamic part at given color and k/x by interpolation. Interpolation method is by default depending on the grid, but could also be chosen to be linear.\n\n#Argument\n\n'green': Green's function\n'time': Target τ/ω_n point\n'space': Target k/x point\n'color1': Target color1\n'color2': Target color2\n'timeMethod': Method of interpolation for time\n'spaceMethod': Method of interpolation for space \n\n\n\n\n\n","category":"method"},{"location":"lib/greenfunc/#NumericalEFT.GreenFunc.instant-Union{Tuple{}, Tuple{SM}, Tuple{SGT}, Tuple{TGT}, Tuple{TT}, Tuple{DT}} where {DT, TT, TGT, SGT, SM}","page":"Green's Function","title":"NumericalEFT.GreenFunc.instant","text":"function instant(green::Green2DLR{DT,TT,TGT,SGT}, space, color1::Int, color2::Int=color1; spaceMethod::SM = DEFAULTINTERP) where {DT,TT,TGT,SGT,SM}\n\nFind value of Green's function's instant part at given color and k/x by interpolation. Interpolation method is by default depending on the grid, but could also be chosen to be linear.\n\n#Argument\n\n'green': Green's function\n'space': Target k/x point\n'color1': Target color1\n'color2': Target color2\n'spaceMethod': Method of interpolation for space. \n\n\n\n\n\n","category":"method"},{"location":"lib/greenfunc/#NumericalEFT.GreenFunc.toDLR-Tuple{Green2DLR}","page":"Green's Function","title":"NumericalEFT.GreenFunc.toDLR","text":"function toDLR(green::Green2DLR)\n\nConvert Green's function to dlr space.\n\n#Arguements\n\n'green': Original Green's function\n\n\n\n\n\n","category":"method"},{"location":"lib/greenfunc/#NumericalEFT.GreenFunc.toDLR-Tuple{GreenSym2DLR}","page":"Green's Function","title":"NumericalEFT.GreenFunc.toDLR","text":"function toDLR(green::Green2DLR)\n\nConvert Green's function to dlr space.\n\n#Arguements\n\n'green': Original Green's function\n\n\n\n\n\n","category":"method"},{"location":"lib/greenfunc/#NumericalEFT.GreenFunc.toMatFreq","page":"Green's Function","title":"NumericalEFT.GreenFunc.toMatFreq","text":"function toMatFreq(green::Green2DLR, targetGrid =  green.dlrGrid.n)\n\nConvert Green's function to matfreq space by Fourier transform. If green is already in matfreq space then it will be interpolated to the new grid.\n\n#Arguements\n\n'green': Original Green's function\n'targetGrid': Grid of outcome Green's function. Default: DLR n grid\n\n\n\n\n\n","category":"function"},{"location":"lib/greenfunc/#NumericalEFT.GreenFunc.toMatFreq-2","page":"Green's Function","title":"NumericalEFT.GreenFunc.toMatFreq","text":"function toMatFreq(green::Green2DLR, targetGrid =  green.dlrGrid.n)\n\nConvert Green's function to matfreq space by Fourier transform. If green is already in matfreq space then it will be interpolated to the new grid.\n\n#Arguements\n\n'green': Original Green's function\n'targetGrid': Grid of outcome Green's function. Default: DLR n grid\n\n\n\n\n\n","category":"function"},{"location":"lib/greenfunc/#NumericalEFT.GreenFunc.toTau","page":"Green's Function","title":"NumericalEFT.GreenFunc.toTau","text":"function toTau(green::Green2DLR, targetGrid =  green.dlrGrid.τ)\n\nConvert Green's function to τ space by Fourier transform. If green is already in τ space then it will be interpolated to the new grid.\n\n#Arguements\n\n'green': Original Green's function\n'targetGrid': Grid of outcome Green's function. Default: DLR τ grid\n\n\n\n\n\n","category":"function"},{"location":"lib/greenfunc/#NumericalEFT.GreenFunc.toTau-2","page":"Green's Function","title":"NumericalEFT.GreenFunc.toTau","text":"function toTau(green::Green2DLR, targetGrid =  green.dlrGrid.τ)\n\nConvert Green's function to τ space by Fourier transform. If green is already in τ space then it will be interpolated to the new grid.\n\n#Arguements\n\n'green': Original Green's function\n'targetGrid': Grid of outcome Green's function. Default: DLR τ grid\n\n\n\n\n\n","category":"function"},{"location":"lib/atom/#Atom","page":"Atom","title":"Atom","text":"","category":"section"},{"location":"lib/atom/#Many-body-Green's-Functions","page":"Atom","title":"Many-body Green's Functions","text":"","category":"section"},{"location":"lib/atom/","page":"Atom","title":"Atom","text":"Modules = [Atom.Green]","category":"page"},{"location":"lib/atom/#NumericalEFT.Atom.Green.GreenN","page":"Atom","title":"NumericalEFT.Atom.Green.GreenN","text":"GreenN(m::Model, τ, orbital, isfermi=true)\n\nConstruct struct to store the variables to evaulate N-body Green's functions. The leg index is assumed to be [1, 2, 3, ...,2N], where the incoming legs are 1:N, and the outgoing legs are N+1:2N The full Green's function is defined as,\n\nG_2N=leftmathcalT c_2Nc_2N-1c_N+1c^+_Nc^+_2c^+_1right\n\ne.g.,\n\n1->------->-3\n    | G4 |        \n2->------->-4\n\nAll other Green's function are derived from the above full Green's function\n\n#Arguments\n\nm: Model struct\nτ: array stores the imaginary-time of legs\norbital: array stores the orbital/spin of legs\nN: particle number (Note that the leg numebr is 2N)\n\n\n\n\n\n","category":"type"},{"location":"lib/atom/#NumericalEFT.Atom.Green.Model","page":"Atom","title":"NumericalEFT.Atom.Green.Model","text":"Model(H::Operator, c⁺::Vector{Operator}, c⁻::Vector{Operator})\n\nConstruct a model.  All input operators are in the Fock space. But all members of Model struct is in the eigenspace. Operator should be a matrix type.\n\nArguments:\n\nβ: inverse temperature\nH: Hamiltonian in the Fock space\nc⁺, c⁻: creation/anniliation operators for each orbital, all in the Fock space\n\n\n\n\n\n","category":"type"},{"location":"lib/atom/#NumericalEFT.Atom.Green.Gn-Tuple{NumericalEFT.Atom.Green.Model, NumericalEFT.Atom.Green.GreenN}","page":"Atom","title":"NumericalEFT.Atom.Green.Gn","text":"@inline function Gn(m::Model, g::GreenN)\n\nEvaluate the full N-body Green's function.\n\nG_2N=leftmathcalT c_2Nc_2N-1c_N+1c^+_Nc^+_2c^+_1right\n\ne.g.,\n\n1->------->-3\n    | G4 |        \n2->------->-4\n\n\n\n\n\n","category":"method"},{"location":"lib/atom/#NumericalEFT.Atom.Green.Gnc-Tuple{NumericalEFT.Atom.Green.Model, NumericalEFT.Atom.Green.GreenN}","page":"Atom","title":"NumericalEFT.Atom.Green.Gnc","text":"function Gnc(m::Model, g::GreenN)\n\nEvaluate the connected N-body Green's function.\n\ne.g., G4c(43;21) =     1->–––->-4       1->–––->-4     1->–-   –->-4         | G4 |      -                  +         X        2->–––->-3       2->–––->-3     2->–-   –->-3\n\n\n\n\n\n","category":"method"},{"location":"lib/atom/#NumericalEFT.Atom.Green.Heisenberg-Tuple{Matrix{Float64}, Any, Any}","page":"Atom","title":"NumericalEFT.Atom.Green.Heisenberg","text":"Heisenberg(o::Operator, E, τ)\n\nTransform operator o into Heisenberg picture\n\n    exp(Hτ)cdot o cdot exp(-Hτ)\n\n\n\n\n\n","category":"method"},{"location":"lib/atom/#Hilbert-Space","page":"Atom","title":"Hilbert Space","text":"","category":"section"},{"location":"lib/atom/","page":"Atom","title":"Atom","text":"Modules = [Atom.Hilbert]","category":"page"},{"location":"lib/atom/#NumericalEFT.Atom.Hilbert.BinaryFock","page":"Atom","title":"NumericalEFT.Atom.Hilbert.BinaryFock","text":"Fock Basis for fermion and hard-core boson, each site has two states with occupation number 0 and 1 e.g. |101>↓|100>↑ means a 3-site fock state, site 1: one up one down, site 2: no particle, site 3: one down \n\n\n\n\n\n","category":"type"},{"location":"lib/atom/#Exact-Diagonalization-of-Hubbard-Model","page":"Atom","title":"Exact Diagonalization of Hubbard Model","text":"","category":"section"},{"location":"lib/atom/","page":"Atom","title":"Atom","text":"Modules = [Atom.Hubbard]","category":"page"},{"location":"lib/utility/#Utility","page":"Utility","title":"Utility","text":"","category":"section"},{"location":"lib/utility/","page":"Utility","title":"Utility","text":"This module provides some utility subroutines.","category":"page"},{"location":"lib/utility/","page":"Utility","title":"Utility","text":"Modules = [NumericalEFT.Utility]","category":"page"},{"location":"lib/utility/#NumericalEFT.Utility","page":"Utility","title":"NumericalEFT.Utility","text":"Utility data structures and functions\n\n\n\n\n\n","category":"module"},{"location":"lib/utility/#NumericalEFT.Utility.StopWatch","page":"Utility","title":"NumericalEFT.Utility.StopWatch","text":"StopWatch(start, interval, callback)\n\nInitialize a stopwatch. \n\nArguments\n\nstart::Float64: initial time (in seconds)\ninterval::Float64 : interval to click (in seconds)\ncallback : callback function after each click (interval seconds)\n\n\n\n\n\n","category":"type"},{"location":"lib/utility/#NumericalEFT.Utility.check-Tuple{NumericalEFT.Utility.StopWatch, Vararg{Any}}","page":"Utility","title":"NumericalEFT.Utility.check","text":"check(stopwatch, parameter...)\n\nCheck stopwatch. If it clicks, call the callback function with the unpacked parameter\n\n\n\n\n\n","category":"method"},{"location":"lib/utility/#NumericalEFT.Utility.progressBar-Tuple{Any, Any}","page":"Utility","title":"NumericalEFT.Utility.progressBar","text":"progressBar(step, total)\n\nReturn string of progressBar (step/total*100%)\n\n\n\n\n\n","category":"method"},{"location":"readme/MCIntegration/#MCIntegration","page":"MCIntegration","title":"MCIntegration","text":"","category":"section"},{"location":"readme/MCIntegration/","page":"MCIntegration","title":"MCIntegration","text":"Robust and efficient Monte Carlo calculator for high-dimensional integral.","category":"page"},{"location":"readme/MCIntegration/","page":"MCIntegration","title":"MCIntegration","text":"(Image: Stable) (Image: Dev) (Image: Build Status) (Image: Coverage)","category":"page"},{"location":"readme/MCIntegration/","page":"MCIntegration","title":"MCIntegration","text":"MCIntegration.jl provides several Monte Carlo algorithms to calculate regular/singular integrals in finite or inifinite dimensions.  ","category":"page"},{"location":"readme/MCIntegration/#Quick-start","page":"MCIntegration","title":"Quick start","text":"","category":"section"},{"location":"readme/MCIntegration/","page":"MCIntegration","title":"MCIntegration","text":"The following examples demonstrate the basic usage of this package. ","category":"page"},{"location":"readme/MCIntegration/#One-dimensional-integral","page":"MCIntegration","title":"One-dimensional integral","text":"","category":"section"},{"location":"readme/MCIntegration/","page":"MCIntegration","title":"MCIntegration","text":"We first show an example of highly singular integral. The following command evaluates ∫_0^1 log(x)/√x dx = 4.","category":"page"},{"location":"readme/MCIntegration/","page":"MCIntegration","title":"MCIntegration","text":"julia> res = integrate((x, c)->log(x[1])/sqrt(x[1]), solver=:vegas) \nIntegral 1 = -3.997980772652019 ± 0.0013607691354676158   (chi2/dof = 1.93)\n\njulia> report(res) #print out the iteration history\n====================================     Integral 1    ==========================================\n  iter              integral                            wgt average                      chi2/dof\n-------------------------------------------------------------------------------------------------\nignore        -3.8394711 ± 0.12101621              -3.8394711 ± 0.12101621                 0.0000\n     2         -3.889894 ± 0.04161423              -3.8394711 ± 0.12101621                 0.0000\n     3        -4.0258398 ± 0.016628525              -4.007122 ± 0.015441393                9.2027\n     4        -4.0010193 ± 0.0097242712            -4.0027523 ± 0.0082285382               4.6573\n     5         -3.990754 ± 0.0055248673            -3.9944823 ± 0.0045868638               3.5933\n     6         -4.000744 ± 0.0025751679            -3.9992433 ± 0.0022454867               3.0492\n     7        -4.0021542 ± 0.005940518             -3.9996072 ± 0.0021004392               2.4814\n     8        -3.9979708 ± 0.0034603885            -3.9991666 ± 0.0017955468               2.0951\n     9         -3.994137 ± 0.0026675679            -3.9975984 ± 0.0014895459               2.1453\n    10        -3.9999099 ± 0.0033455927            -3.9979808 ± 0.0013607691               1.9269\n-------------------------------------------------------------------------------------------------","category":"page"},{"location":"readme/MCIntegration/","page":"MCIntegration","title":"MCIntegration","text":"By default, the function performs 10 iterations and each iteraction costs about 1e4 evaluations. You may reset these values with niter and neval keywords arguments.\nThe final result is obtained by inverse-variance-weighted averge of all the iterations except the first one (there is no important sampling yet!). They are stored in the return valueres, which is a struct Result. You can access the statistics with res.mean, res.stdev, res.chi2, res.dof and res.iterations for all the iterations. \nIf you want to exclude more iterations, say the first three iterations, you can get a new result with the call Result(res, 3).  \nInternally, the integrate function optimizes the important sampling after each iteration. The results generally improves with iteractions. As long as neval is sufficiently large, the estimations from different iteractions should be statistically independent. This will justify an average of different iterations weighted by the inverse variance. The assumption of statically independence can be explicitly checked with chi-square test, namely chi2/dof should be about one. \nYou can pass the keyword arguemnt solver to the integrate functoin to specify the Monte Carlo algorithm. The above examples uses the Vegas algorithm with :vegas. In addition, this package provides two Markov-chain Monte Carlo algorithms for numerical integration. You can call them with :vegasmc or :mcmc. Check the Algorithm section for more details. \nFor the :vegas and vegasmc algorithms, the user-defined integrand evaluation function requires two arguments (x, c), where x is the integration variable, while c is a struct stores the MC configuration. The latter contains additional information which may be needed for integrand evalution.  \nThe 'Configuration' struct stores the essential state information for the Monte Carlo sampling. Two particularly relavent members are\nuserdata : if you pass a keyword argument userdata to the integrate function, then it will be stored here, so that you can access it in your integrand evaluation function. \nvar : A tuple of variables. In the above example, var = (x, ) so that var[1] === x. \nThe result returned by the integrate function contains the configuration after integration. If you want a detailed report, call report(res.config). This configuration stores the optimized random variable distributions for the important sampling, which could be useful to evaluate other integrals with similar integrands. To use the optimized distributions, you can either call integrate(..., config = res.config, ...) to pass the entire configuration, or call integrate(..., var = (res.config.var[1], ...), ...) to pass one or more selected variables.","category":"page"},{"location":"readme/MCIntegration/#Multi-dimensional-integral","page":"MCIntegration","title":"Multi-dimensional integral","text":"","category":"section"},{"location":"readme/MCIntegration/","page":"MCIntegration","title":"MCIntegration","text":"The following example first defines a pool of variables in [0, 1), then evaluates the area of a quarter unit circle (π/4 = 0.785398...).","category":"page"},{"location":"readme/MCIntegration/","page":"MCIntegration","title":"MCIntegration","text":"julia> X=Continuous(0.0, 1.0) #Create a pool of continuous variables. \nAdaptive continuous variable in the domain [0.0, 1.0). Max variable number = 16. Learning rate = 2.0.\n\njulia> res = integrate((X, c)->(X[1]^2+X[2]^2<1.0); var = X, dof = 2) \nIntegral 1 = 0.7860119307731648 ± 0.002323473435947719   (chi2/dof = 2.14)","category":"page"},{"location":"readme/MCIntegration/","page":"MCIntegration","title":"MCIntegration","text":"Here we suppress the output information by print=-1. If you want to see more information after the calculation, simply call report(res). If you want to check the MC configuration, you may call report(res.config).","category":"page"},{"location":"readme/MCIntegration/#Multiple-Integrands-Simultaneously","page":"MCIntegration","title":"Multiple Integrands Simultaneously","text":"","category":"section"},{"location":"readme/MCIntegration/","page":"MCIntegration","title":"MCIntegration","text":"You can calculate multiple integrals simultaneously. If the integrands are similar to each other, evaluating the integrals simultaneously sigificantly reduces cost. The following example calculate the area of a quarter circle and the volume of one-eighth sphere.","category":"page"},{"location":"readme/MCIntegration/","page":"MCIntegration","title":"MCIntegration","text":"julia> integrate((X, c)->(X[1]^2+X[2]^2<1.0, X[1]^2+X[2]^2+X[3]^2<1.0); var = Continuous(0.0, 1.0), dof = [[2,],[3,]])\nIntegral 1 = 0.7823432452235586 ± 0.003174967010742156   (chi2/dof = 2.82)\nIntegral 2 = 0.5185515421806122 ± 0.003219487569949905   (chi2/dof = 1.41)","category":"page"},{"location":"readme/MCIntegration/","page":"MCIntegration","title":"MCIntegration","text":"Here dof defines how many (degrees of freedom) variables of each type. For example, [[n1, n2], [m1, m2], ...] means the first integral involves n1 varibales of type 1, and n2 variables of type2, while the second integral involves m1 variables of type 1 and m2 variables of type 2. The dof of the integrals can be quite different, the program will figure out how to optimally padding the integrands to match the degrees of freedom. ","category":"page"},{"location":"readme/MCIntegration/","page":"MCIntegration","title":"MCIntegration","text":"You can also use the julia do-syntax to improve the readability of the above example,","category":"page"},{"location":"readme/MCIntegration/","page":"MCIntegration","title":"MCIntegration","text":"julia> integrate(var = Continuous(0.0, 1.0), dof = [[2,], [3,]]) do X, c\n           r1 = (X[1]^2 + X[2]^2 < 1.0) ? 1.0 : 0.0\n           r2 = (X[1]^2 + X[2]^2 + X[3]^2 < 1.0) ? 1.0 : 0.0\n           return (r1, r2)\n       end","category":"page"},{"location":"readme/MCIntegration/#Measure-Histogram","page":"MCIntegration","title":"Measure Histogram","text":"","category":"section"},{"location":"readme/MCIntegration/","page":"MCIntegration","title":"MCIntegration","text":"You may want to study how an integral changes with a tuning parameter. The following example is how to solve the histogram measurement problem.","category":"page"},{"location":"readme/MCIntegration/","page":"MCIntegration","title":"MCIntegration","text":"julia> N = 20;\n\njulia> grid = [i / N for i in 1:N];\n\njulia> function integrand(vars, config)\n            grid = config.userdata # radius\n            x, bin = vars #unpack the variables\n            r = grid[bin[1]] # binned variable in [0, 1)\n            r1 = x[1]^2 + r^2 < 1 # circle\n            r2 = x[1]^2 + x[2]^2 + r^2 < 1 # sphere\n            return r1, r2\n        end;\n\njulia> function measure(vars, obs, weights, config) \n       # obs: prototype of the observables for each integral\n           x, bin = vars #unpack the variables\n           obs[1][bin[1]] += weights[1] # circle\n           obs[2][bin[1]] += weights[2] # sphere\n       end;\n\njulia> res = integrate(integrand;\n                measure = measure, # measurement function\n                var = (Continuous(0.0, 1.0), Discrete(1, N)), # a continuous and a discrete variable pool \n                dof = [[1,1], [2,1]], \n                # integral-1: one continuous and one discrete variables, integral-2: two continous and one discrete variables\n                obs = [zeros(N), zeros(N)], #  observable prototypes of each integral\n                userdata = grid, neval = 1e5)\nIntegral 1 = 0.9957805541613277 ± 0.008336657854575344   (chi2/dof = 1.15)\nIntegral 2 = 0.7768105610812656 ± 0.006119386106596811   (chi2/dof = 1.4)","category":"page"},{"location":"readme/MCIntegration/","page":"MCIntegration","title":"MCIntegration","text":"You can visualize the returned result res with Plots.jl. The commands res.mean[i] and res.stdev[i] give the mean and stdev of the histogram of the i-th integral.","category":"page"},{"location":"readme/MCIntegration/","page":"MCIntegration","title":"MCIntegration","text":"julia> using Plots\n\njulia> plt = plot(grid, res.mean[1], yerror = res.stdev[1], xlabel=\"R\", label=\"circle\", aspect_ratio=1.0, xlim=[0.0, 1.0])\n\njulia> plot!(plt, grid, res.mean[2], yerror = res.stdev[2], label=\"sphere\")","category":"page"},{"location":"readme/MCIntegration/","page":"MCIntegration","title":"MCIntegration","text":"(Image: histogram)","category":"page"},{"location":"readme/MCIntegration/#Algorithm","page":"MCIntegration","title":"Algorithm","text":"","category":"section"},{"location":"readme/MCIntegration/","page":"MCIntegration","title":"MCIntegration","text":"This package provides three solvers.","category":"page"},{"location":"readme/MCIntegration/","page":"MCIntegration","title":"MCIntegration","text":"Vegas algorithm (:vegas): A Monte Carlo algorithm that uses importance sampling as a variance-reduction technique. Vegas iteratively builds up a piecewise constant weight function, represented","category":"page"},{"location":"readme/MCIntegration/","page":"MCIntegration","title":"MCIntegration","text":"on a rectangular grid. Each iteration consists of a sampling step followed by a refinement of the grid. The exact details of the algorithm can be found in G.P. Lepage, J. Comp. Phys. 27 (1978) 192, 3 and G.P. Lepage, Report CLNS-80/447, Cornell Univ., Ithaca, N.Y., 1980. ","category":"page"},{"location":"readme/MCIntegration/","page":"MCIntegration","title":"MCIntegration","text":"Vegas algorithm based on Markov-chain Monte Carlo (:vegasmc): A markov-chain Monte Carlo algorithm that uses the Vegas variance-reduction technique. It is as accurate as the vanilla Vegas algorithm, meanwhile tends to be more robust. For complicated high-dimensional integral, the vanilla Vegas algorithm can fail to learn the piecewise constant weight function. This algorithm uses Metropolis–Hastings algorithm to sample the integrand and improves the weight function learning.\nMarkov-chain Monte Carlo (:mcmc): This algorithm is useful for calculating bundled integrands that are too many to calculate at once. Examples are the path-integral of world lines of quantum particles, which involves hundreds and thousands of nested spacetime integrals. This algorithm uses the Metropolis-Hastings algorithm to jump between different integrals so that you only need to evaluate one integrand at each Monte Carlo step. Just as :vegas and :vegasmc, this algorithm also learns a piecewise constant weight function to reduce the variance. However, because it assumes you can access one integrand at each step, it tends to be less accurate than the other two algorithms for low-dimensional integrals.   ","category":"page"},{"location":"readme/MCIntegration/","page":"MCIntegration","title":"MCIntegration","text":"The signature of the integrand and measure functions of the :mcmc solver receices an additional index argument than that of the :vegas and :vegasmc solvers. As shown in the above examples, the integrand and measure functions of the latter two solvers should be like integrand(vars, config) and measure(vars, obs, weights, config), where weights is a vectors carries the values of the integrands at the current MC step. On the other hand, the :mcmc solver requires something like integrand(idx, vars, config) and measure(idx, vars, weight, config), where idx is the index of the integrand of the current step, and the argument weight is a scalar carries the value of the current integrand being sampled.","category":"page"},{"location":"readme/MCIntegration/#Variables","page":"MCIntegration","title":"Variables","text":"","category":"section"},{"location":"readme/MCIntegration/","page":"MCIntegration","title":"MCIntegration","text":"The package supports a couple of common types random variables. You can create them using the following constructors,","category":"page"},{"location":"readme/MCIntegration/","page":"MCIntegration","title":"MCIntegration","text":"Continous(lower, upper[; adapt = true, alpha = 3.0, ...]): Continuous real-valued variables on the domain [lower, upper). MC will learn the distribution using the Vegas algorithm and then perform an imporant sampling accordingly.\nDiscrete(lower::Int, upper::Int[; adapt = true, alpha = 3.0, ...]): Integer variables in the closed set [lower, upper]. MC will learn the distribution and perform an imporant sampling accordingly.","category":"page"},{"location":"readme/MCIntegration/","page":"MCIntegration","title":"MCIntegration","text":"After each iteration, the code will try to optimize how the variables are sampled, so that the most important regimes of the integrals will be sampled most frequently. Setting alpha to be true/false will turn on/off this distribution learning. The parameter alpha controls the learning rate.","category":"page"},{"location":"readme/MCIntegration/","page":"MCIntegration","title":"MCIntegration","text":"When you call the above constructor, it creates an unlimited pool of random variables of a given type. The size of the pool will be dynamically determined when you call a solver. All variables in this pool will be sampled with the same distribution. In many high-dimensional integrals, many integration variables may contribute to the integral in a similar way; then they can be sampled from the same variable pool. For example, in the above code example, the integral for the circle area and the sphere volume both involve the variable type Continuous. The former has dof=2, while the latter has dof=3. To evaluate a given integrand, you only need to choose some of the variables to evaluate a given integral. The rest of the variables in the pool serve as dummy ones. They will not cause any computational overhead.","category":"page"},{"location":"readme/MCIntegration/","page":"MCIntegration","title":"MCIntegration","text":"The variable pool trick will significantly reduce the cost of learning their distribution. It also opens the possibility of calculating integrals with infinite dimensions (for example, the path-integral of particle worldlines in quantum many-body physics). ","category":"page"},{"location":"readme/MCIntegration/","page":"MCIntegration","title":"MCIntegration","text":"If some of the variables are paired with each other (for example, the three continuous variables (r, θ, ϕ) representing a 3D vector), then you can pack them into a joint random variable, which can be constructed with the following constructor,","category":"page"},{"location":"readme/MCIntegration/","page":"MCIntegration","title":"MCIntegration","text":"CompositeVar(var1, var2, ...[; adapt = true, alpha = 3.0, ...]): A product of different types of random variables. It samples var1, var2, ... with their producted distribution. ","category":"page"},{"location":"readme/MCIntegration/","page":"MCIntegration","title":"MCIntegration","text":"The packed variables will be sampled all together in the Markov-chain based solvers (:vegasmc and :mcmc). Such updates will generate more independent samples compared to the unpacked version. Sometimes, it could reduce the auto-correlation time of the Markov chain and make the algorithm more efficient.","category":"page"},{"location":"readme/MCIntegration/","page":"MCIntegration","title":"MCIntegration","text":"Moreover, packed variables usually indicate nontrivial correlations between their distributions. In the future, it will be interesting to learn such correlation so that one can sample the packed variables more efficiently.","category":"page"},{"location":"readme/MCIntegration/#Parallelization","page":"MCIntegration","title":"Parallelization","text":"","category":"section"},{"location":"readme/MCIntegration/","page":"MCIntegration","title":"MCIntegration","text":"MCIntegration supports MPI parallelization. To run your code in MPI mode, simply use the command","category":"page"},{"location":"readme/MCIntegration/","page":"MCIntegration","title":"MCIntegration","text":"mpiexec julia -n #NCPU ./your_script.jl","category":"page"},{"location":"readme/MCIntegration/","page":"MCIntegration","title":"MCIntegration","text":"where #NCPU is the number of workers. Internally, the MC sampler will send the blocks (controlled by the argument Nblock, see above example code) to different workers, then collect the estimates in the root node. ","category":"page"},{"location":"readme/MCIntegration/","page":"MCIntegration","title":"MCIntegration","text":"Note that you need to install the package MPI.jl to use the MPI mode. See this link for the instruction on the configuration.","category":"page"},{"location":"readme/MCIntegration/","page":"MCIntegration","title":"MCIntegration","text":"The user essentially doesn't need to write additional code to support the parallelization. The only tricky part is the output: only the function MCIntegratoin.integrate of the root node returns meaningful estimates, while other workers simply returns nothing.","category":"page"},{"location":"lib/Lehmann/#Discrete-Lehmann-representation","page":"Discrete Lehmann representation","title":"Discrete Lehmann representation","text":"","category":"section"},{"location":"lib/Lehmann/#Main-Module","page":"Discrete Lehmann representation","title":"Main Module","text":"","category":"section"},{"location":"lib/Lehmann/","page":"Discrete Lehmann representation","title":"Discrete Lehmann representation","text":"Modules = [Lehmann]","category":"page"},{"location":"lib/Lehmann/#NumericalEFT.Lehmann.DLRGrid","page":"Discrete Lehmann representation","title":"NumericalEFT.Lehmann.DLRGrid","text":"struct DLRGrid\n\nDLR grids for imaginary-time/Matsubara frequency correlators\n\n#Members:\n\nisFermi: bool is fermionic or bosonic\nsymmetry: particle-hole symmetric :ph, or particle-hole asymmetric :pha, or :none\nEuv : the UV energy scale of the spectral density \nβ or beta : inverse temeprature\nΛ or lambda: cutoff = UV Energy scale of the spectral density * inverse temperature\nrtol: tolerance absolute error\nsize : number of DLR basis\nω or omega : selected representative real-frequency grid\nn : selected representative Matsubara-frequency grid (integer)\nωn or omegaN : (2n+1)π/β\nτ or tau : selected representative imaginary-time grid\n\n\n\n\n\n","category":"type"},{"location":"lib/Lehmann/#Base.size-Tuple{DLRGrid}","page":"Discrete Lehmann representation","title":"Base.size","text":"Base.size(dlrGrid::DLRGrid) = length(dlrGrid.ω) Base.length(dlrGrid::DLRGrid) = length(dlrGrid.ω) rank(dlrGrid::DLRGrid) = length(dlrGrid.ω)\n\nget the rank of the DLR grid, namely the number of the DLR coefficients.\n\n\n\n\n\n","category":"method"},{"location":"lib/Lehmann/#NumericalEFT.Lehmann.dlr2matfreq","page":"Discrete Lehmann representation","title":"NumericalEFT.Lehmann.dlr2matfreq","text":"function dlr2matfreq(dlrGrid::DLRGrid, dlrcoeff, nGrid = dlrGrid.n; axis = 1, verbose = true)\n\nDLR representation to Matsubara-frequency representation\n\n#Members:\n\ndlrGrid  : DLRGrid\ndlrcoeff : DLR coefficients\nnGrid    : expected fine Matsubara-freqeuncy grids (integer)\naxis     : Matsubara-frequency axis in the data dlrcoeff\nverbose  : true to print warning information\n\n\n\n\n\n","category":"function"},{"location":"lib/Lehmann/#NumericalEFT.Lehmann.dlr2tau","page":"Discrete Lehmann representation","title":"NumericalEFT.Lehmann.dlr2tau","text":"function dlr2tau(dlrGrid::DLRGrid, dlrcoeff, τGrid = dlrGrid.τ; axis = 1, verbose = true)\n\nDLR representation to imaginary-time representation\n\n#Members:\n\ndlrGrid  : DLRGrid\ndlrcoeff : DLR coefficients\nτGrid    : expected fine imaginary-time grids \naxis     : imaginary-time axis in the data dlrcoeff\nverbose  : true to print warning information\n\n\n\n\n\n","category":"function"},{"location":"lib/Lehmann/#NumericalEFT.Lehmann.matfreq2dlr","page":"Discrete Lehmann representation","title":"NumericalEFT.Lehmann.matfreq2dlr","text":"function matfreq2dlr(dlrGrid::DLRGrid, green, nGrid = dlrGrid.n; error = nothing, axis = 1, sumrule = nothing, verbose = true)\n\nMatsubara-frequency representation to DLR representation\n\n#Members:\n\ndlrGrid  : DLRGrid struct.\ngreen    : green's function in Matsubara-frequency domain\nnGrid    : the n grid that Green's function is defined on. \nerror    : error the Green's function. \naxis     : the Matsubara-frequency axis in the data green\nsumrule  : enforce the sum rule \nverbose  : true to print warning information\n\n\n\n\n\n","category":"function"},{"location":"lib/Lehmann/#NumericalEFT.Lehmann.matfreq2matfreq","page":"Discrete Lehmann representation","title":"NumericalEFT.Lehmann.matfreq2matfreq","text":"function matfreq2matfreq(dlrGrid, green, nNewGrid, nGrid = dlrGrid.n; error = nothing, axis = 1, sumrule = nothing, verbose = true)\n\nFourier transform from Matsubara-frequency to imaginary-time using the DLR representation\n\n#Members:\n\ndlrGrid  : DLRGrid\ngreen    : green's function in Matsubara-freqeuncy repsentation\nnNewGrid : expected fine Matsubara-freqeuncy grids (integer)\nnGrid    : the n grid that Green's function is defined on. \nerror    : error the Green's function. \naxis     : Matsubara-frequency axis in the data green\nsumrule  : enforce the sum rule \nverbose  : true to print warning information\n\n\n\n\n\n","category":"function"},{"location":"lib/Lehmann/#NumericalEFT.Lehmann.matfreq2tau","page":"Discrete Lehmann representation","title":"NumericalEFT.Lehmann.matfreq2tau","text":"function matfreq2tau(dlrGrid, green, τNewGrid = dlrGrid.τ, nGrid = dlrGrid.n; error = nothing, axis = 1, sumrule = nothing, verbose = true)\n\nFourier transform from Matsubara-frequency to imaginary-time using the DLR representation\n\n#Members:\n\ndlrGrid  : DLRGrid\ngreen    : green's function in Matsubara-freqeuncy repsentation\nτNewGrid : expected fine imaginary-time grids\nnGrid    : the n grid that Green's function is defined on. \nerror    : error the Green's function. \naxis     : Matsubara-frequency axis in the data green\nsumrule  : enforce the sum rule \nverbose  : true to print warning information\n\n\n\n\n\n","category":"function"},{"location":"lib/Lehmann/#NumericalEFT.Lehmann.tau2dlr","page":"Discrete Lehmann representation","title":"NumericalEFT.Lehmann.tau2dlr","text":"function tau2dlr(dlrGrid::DLRGrid, green, τGrid = dlrGrid.τ; error = nothing, axis = 1, sumrule = nothing, verbose = true)\n\nimaginary-time domain to DLR representation\n\n#Members:\n\ndlrGrid  : DLRGrid struct.\ngreen    : green's function in imaginary-time domain.\nτGrid    : the imaginary-time grid that Green's function is defined on. \nerror    : error the Green's function. \naxis     : the imaginary-time axis in the data green.\nsumrule  : enforce the sum rule \nverbose  : true to print warning information\n\n\n\n\n\n","category":"function"},{"location":"lib/Lehmann/#NumericalEFT.Lehmann.tau2matfreq","page":"Discrete Lehmann representation","title":"NumericalEFT.Lehmann.tau2matfreq","text":"function tau2matfreq(dlrGrid, green, nNewGrid = dlrGrid.n, τGrid = dlrGrid.τ; error = nothing, axis = 1, sumrule = nothing, verbose = true)\n\nFourier transform from imaginary-time to Matsubara-frequency using the DLR representation\n\n#Members:\n\ndlrGrid  : DLRGrid\ngreen    : green's function in imaginary-time domain\nnNewGrid : expected fine Matsubara-freqeuncy grids (integer)\nτGrid    : the imaginary-time grid that Green's function is defined on. \nerror    : error the Green's function. \naxis     : the imaginary-time axis in the data green\nsumrule  : enforce the sum rule \nverbose  : true to print warning information\n\n\n\n\n\n","category":"function"},{"location":"lib/Lehmann/#NumericalEFT.Lehmann.tau2tau","page":"Discrete Lehmann representation","title":"NumericalEFT.Lehmann.tau2tau","text":"function tau2tau(dlrGrid, green, τNewGrid, τGrid = dlrGrid.τ; error = nothing, axis = 1, sumrule = nothing, verbose = true)\n\nInterpolation from the old imaginary-time grid to a new grid using the DLR representation\n\n#Members:\n\ndlrGrid  : DLRGrid\ngreen    : green's function in imaginary-time domain\nτNewGrid : expected fine imaginary-time grids\nτGrid    : the imaginary-time grid that Green's function is defined on. \nerror    : error the Green's function. \naxis     : the imaginary-time axis in the data green\nsumrule  : enforce the sum rule \nverbose  : true to print warning information\n\n\n\n\n\n","category":"function"},{"location":"lib/Lehmann/#Spectral-functions","page":"Discrete Lehmann representation","title":"Spectral functions","text":"","category":"section"},{"location":"lib/Lehmann/","page":"Discrete Lehmann representation","title":"Discrete Lehmann representation","text":"This module defines the kernels of Lehmann representation for different particles and symmetries.","category":"page"},{"location":"lib/Lehmann/","page":"Discrete Lehmann representation","title":"Discrete Lehmann representation","text":"Modules = [Lehmann.Spectral]","category":"page"},{"location":"lib/Lehmann/#NumericalEFT.Lehmann.Spectral","page":"Discrete Lehmann representation","title":"NumericalEFT.Lehmann.Spectral","text":"Spectral representation related functions\n\n\n\n\n\n","category":"module"},{"location":"lib/Lehmann/#NumericalEFT.Lehmann.Spectral.boseEinstein-Union{Tuple{T}, Tuple{T, T}} where T<:AbstractFloat","page":"Discrete Lehmann representation","title":"NumericalEFT.Lehmann.Spectral.boseEinstein","text":"boseEinstein(ω)\n\nCompute the Fermi Dirac function. Assume k_B Thbar=1\n\nf(ω) = 1(e^ωβ-1)\n\nArguments\n\nω: frequency\nβ: the inverse temperature \n\n\n\n\n\n","category":"method"},{"location":"lib/Lehmann/#NumericalEFT.Lehmann.Spectral.density-Union{Tuple{T}, Tuple{Bool, T, T}} where T<:AbstractFloat","page":"Discrete Lehmann representation","title":"NumericalEFT.Lehmann.Spectral.density","text":"density(isFermi::Bool, ω, β)\n\nCompute the imaginary-time kernel of different type. Assume k_B Thbar=1\n\nArguments\n\nisFermi: fermionic or bosonic\nω: energy \nβ: the inverse temperature \n\n\n\n\n\n","category":"method"},{"location":"lib/Lehmann/#NumericalEFT.Lehmann.Spectral.fermiDirac-Union{Tuple{T}, Tuple{T, T}} where T<:AbstractFloat","page":"Discrete Lehmann representation","title":"NumericalEFT.Lehmann.Spectral.fermiDirac","text":"fermiDirac(ω)\n\nCompute the Fermi Dirac function. Assume k_B Thbar=1\n\nf(ω) = 1(e^ωβ+1)\n\nArguments\n\nω: frequency\nβ: the inverse temperature \n\n\n\n\n\n","category":"method"},{"location":"lib/Lehmann/#NumericalEFT.Lehmann.Spectral.kernelBoseT-Union{Tuple{T}, Tuple{T, T, T}} where T<:AbstractFloat","page":"Discrete Lehmann representation","title":"NumericalEFT.Lehmann.Spectral.kernelBoseT","text":"kernelBoseT(τ, ω, β)\n\nCompute the imaginary-time bosonic kernel. Machine accuracy ~eps(g) is guaranteed``\n\ng(τ0) = e^-ωτ(1-e^-ωβ) g(τ0) = -e^-ωτ(1-e^ωβ)\n\nArguments\n\nτ: the imaginary time, must be (-β, β]\nω: frequency\nβ: the inverse temperature \n\n\n\n\n\n","category":"method"},{"location":"lib/Lehmann/#NumericalEFT.Lehmann.Spectral.kernelBoseT_PH-Union{Tuple{T}, Tuple{T, T}, Tuple{T, T, Any}} where T<:AbstractFloat","page":"Discrete Lehmann representation","title":"NumericalEFT.Lehmann.Spectral.kernelBoseT_PH","text":"kernelBoseT_PH(τ, ω, β)\n\nCompute the imaginary-time kernel for correlation function O(τ)O(0). Machine accuracy ~eps(C) is guaranteed``\n\nK(τ) = e^-ωτ+e^-ω(β-τ)\n\nArguments\n\nτ: the imaginary time, must be (-β, β]\nω: frequency, ω>=0\nβ: the inverse temperature \n\n\n\n\n\n","category":"method"},{"location":"lib/Lehmann/#NumericalEFT.Lehmann.Spectral.kernelBoseT_PHA-Union{Tuple{T}, Tuple{T, T, T}} where T<:AbstractFloat","page":"Discrete Lehmann representation","title":"NumericalEFT.Lehmann.Spectral.kernelBoseT_PHA","text":"kernelBoseT_PHA(τ, ω, β)\n\nCompute the imaginary-time kernel for correlation function O(τ)O(0). Machine accuracy ~eps(C) is guaranteed``\n\nK(τ) = e^-ωτ-e^-ω(β-τ)\n\nArguments\n\nτ: the imaginary time, must be (0, β]\nω: frequency, ω>=0\nβ: the inverse temperature \n\n\n\n\n\n","category":"method"},{"location":"lib/Lehmann/#NumericalEFT.Lehmann.Spectral.kernelBoseT_regular-Union{Tuple{T}, Tuple{T, T, T}} where T<:AbstractFloat","page":"Discrete Lehmann representation","title":"NumericalEFT.Lehmann.Spectral.kernelBoseT_regular","text":"kernelBoseT_regular(τ, ω, β)\n\nCompute the imaginary-time bosonic kernel with a regulator near ω=0. Machine accuracy ~eps(g) is guaranteed``\n\ng(τ0) = e^-ωτ(1+e^-ωβ) g(τ0) = e^-ωτ(1+e^ωβ)\n\nArguments\n\nτ: the imaginary time, must be (-β, β]\nω: frequency\nβ: the inverse temperature \n\n\n\n\n\n","category":"method"},{"location":"lib/Lehmann/#NumericalEFT.Lehmann.Spectral.kernelBoseΩ-Union{Tuple{T}, Tuple{Int64, T, T}} where T<:AbstractFloat","page":"Discrete Lehmann representation","title":"NumericalEFT.Lehmann.Spectral.kernelBoseΩ","text":"kernelBoseΩ(n::Int, ω::T, β::T) where {T <: AbstractFloat}\n\nCompute the bosonic kernel with Matsubara frequency.\n\ng(iω_n) = -1(iω_n-ω)\n\nwhere ω_n=2nπβ. The convention here is consist with the book \"Quantum Many-particle Systems\" by J. Negele and H. Orland, Page 95\n\nArguments\n\nn: index of the Matsubara frequency\nω: energy \nβ: the inverse temperature \n\n\n\n\n\n","category":"method"},{"location":"lib/Lehmann/#NumericalEFT.Lehmann.Spectral.kernelBoseΩ_PH-Union{Tuple{T}, Tuple{Int64, T, T}} where T<:AbstractFloat","page":"Discrete Lehmann representation","title":"NumericalEFT.Lehmann.Spectral.kernelBoseΩ_PH","text":"kernelBoseΩ_PH(n::Int, ω::T, β::T) where {T <: AbstractFloat}\n\nCompute the Matsubara-frequency kernel for a correlator O(τ)O(0)_iω_n.\n\nK(iω_n) = frac2ωω^2+ω_n^2(1-e^-ωβ)\n\nwhere ω_n=2nπβ. The convention here is consist with the book \"Quantum Many-particle Systems\" by J. Negele and H. Orland, Page 95\n\nArguments\n\nn: index of the Matsubara frequency\nω: energy \nβ: the inverse temperature \n\n\n\n\n\n","category":"method"},{"location":"lib/Lehmann/#NumericalEFT.Lehmann.Spectral.kernelBoseΩ_PHA-Union{Tuple{T}, Tuple{Int64, T, T}} where T<:AbstractFloat","page":"Discrete Lehmann representation","title":"NumericalEFT.Lehmann.Spectral.kernelBoseΩ_PHA","text":"kernelBoseΩ_PHA(n::Int, ω::T, β::T) where {T <: AbstractFloat}\n\nCompute the Matsubara-frequency kernel for a anormalous fermionic correlator with particle-hole symmetry.\n\nK(iω_n) = -frac2iω_nω^2+ω_n^2(1-e^-ωβ)\n\nwhere ω_n=2nπβ. The convention here is consist with the book \"Quantum Many-particle Systems\" by J. Negele and H. Orland, Page 95\n\nArguments\n\nn: index of the fermionic Matsubara frequency\nω: energy \nβ: the inverse temperature \n\n\n\n\n\n","category":"method"},{"location":"lib/Lehmann/#NumericalEFT.Lehmann.Spectral.kernelBoseΩ_regular-Union{Tuple{T}, Tuple{Int64, T, T}} where T<:AbstractFloat","page":"Discrete Lehmann representation","title":"NumericalEFT.Lehmann.Spectral.kernelBoseΩ_regular","text":"kernelBoseΩ_regular(n::Int, ω::T, β::T) where {T <: AbstractFloat}\n\nCompute the bosonic kernel in Matsubara frequency with a regulartor near ω=0\n\ng(iω_n) = -(1-e^-ωβ)(1+e^-ωβ)(iω_n-ω)\n\nwhere ω_n=2nπβ. The convention here is consist with the book \"Quantum Many-particle Systems\" by J. Negele and H. Orland, Page 95\n\nArguments\n\nn: index of the Matsubara frequency\nω: energy \nβ: the inverse temperature \n\n\n\n\n\n","category":"method"},{"location":"lib/Lehmann/#NumericalEFT.Lehmann.Spectral.kernelFermiT-Union{Tuple{T}, Tuple{T, T, T}} where T<:AbstractFloat","page":"Discrete Lehmann representation","title":"NumericalEFT.Lehmann.Spectral.kernelFermiT","text":"kernelFermiT(τ, ω, β)\n\nCompute the imaginary-time fermionic kernel.  Machine accuracy ~eps(g) is guaranteed``\n\ng(τ0) = e^-ωτ(1+e^-ωβ) g(τ0) = -e^-ωτ(1+e^ωβ)\n\nArguments\n\nτ: the imaginary time, must be (-β, β]\nω: frequency\nβ: the inverse temperature \n\n\n\n\n\n","category":"method"},{"location":"lib/Lehmann/#NumericalEFT.Lehmann.Spectral.kernelFermiT_PH-Union{Tuple{T}, Tuple{T, T}, Tuple{T, T, Any}} where T<:AbstractFloat","page":"Discrete Lehmann representation","title":"NumericalEFT.Lehmann.Spectral.kernelFermiT_PH","text":"kernelFermiT_PH(τ, ω, β)\n\nCompute the imaginary-time kernel for correlation function O(τ)O(0). Machine accuracy ~eps(C) is guaranteed``\n\nK(τ) = e^-ωτ+e^-ω(β-τ)\n\nArguments\n\nτ: the imaginary time, must be (-β, β]\nω: frequency, ω>=0\nβ: the inverse temperature \n\n\n\n\n\n","category":"method"},{"location":"lib/Lehmann/#NumericalEFT.Lehmann.Spectral.kernelFermiT_PHA-Union{Tuple{T}, Tuple{T, T, T}} where T<:AbstractFloat","page":"Discrete Lehmann representation","title":"NumericalEFT.Lehmann.Spectral.kernelFermiT_PHA","text":"kernelFermiT_PHA(τ, ω, β)\n\nCompute the imaginary-time kernel for correlation function O(τ)O(0). Machine accuracy ~eps(C) is guaranteed``\n\nK(τ) = e^-ωτ-e^-ω(β-τ)\n\nArguments\n\nτ: the imaginary time, must be (0, β]\nω: frequency, ω>=0\nβ: the inverse temperature \n\n\n\n\n\n","category":"method"},{"location":"lib/Lehmann/#NumericalEFT.Lehmann.Spectral.kernelFermiΩ-Union{Tuple{T}, Tuple{Int64, T, T}} where T<:AbstractFloat","page":"Discrete Lehmann representation","title":"NumericalEFT.Lehmann.Spectral.kernelFermiΩ","text":"kernelFermiΩ(n::Int, ω::T, β::T) where {T <: AbstractFloat}\n\nCompute the fermionic kernel with Matsubara frequency.\n\ng(iω_n) = -1(iω_n-ω)\n\nwhere ω_n=(2n+1)πβ. The convention here is consist with the book \"Quantum Many-particle Systems\" by J. Negele and H. Orland, Page 95\n\nArguments\n\nn: index of the Matsubara frequency\nω: energy \nβ: the inverse temperature \n\n\n\n\n\n","category":"method"},{"location":"lib/Lehmann/#NumericalEFT.Lehmann.Spectral.kernelFermiΩ_PH-Union{Tuple{T}, Tuple{Int64, T, T}} where T<:AbstractFloat","page":"Discrete Lehmann representation","title":"NumericalEFT.Lehmann.Spectral.kernelFermiΩ_PH","text":"kernelFermiΩ_PH(n::Int, ω::T, β::T) where {T <: AbstractFloat}\n\nCompute the Matsubara-frequency kernel for a correlator O(τ)O(0)_iω_n.\n\nK(iω_n) = -frac2iω_nω^2+ω_n^2(1+e^-ωβ)\n\nwhere ω_n=(2n+1)πβ. The convention here is consist with the book \"Quantum Many-particle Systems\" by J. Negele and H. Orland, Page 95\n\nArguments\n\nn: index of the Matsubara frequency\nω: energy \nβ: the inverse temperature \n\n\n\n\n\n","category":"method"},{"location":"lib/Lehmann/#NumericalEFT.Lehmann.Spectral.kernelFermiΩ_PHA-Union{Tuple{T}, Tuple{Int64, T, T}} where T<:AbstractFloat","page":"Discrete Lehmann representation","title":"NumericalEFT.Lehmann.Spectral.kernelFermiΩ_PHA","text":"kernelFermiΩ_PHA(n::Int, ω::T, β::T) where {T <: AbstractFloat}\n\nCompute the Matsubara-frequency kernel for a anormalous fermionic correlator with particle-hole symmetry.\n\nK(iω_n) = frac2ωω^2+ω_n^2(1+e^-ωβ)\n\nwhere ω_n=(2n+1)πβ. The convention here is consist with the book \"Quantum Many-particle Systems\" by J. Negele and H. Orland, Page 95\n\nArguments\n\nn: index of the fermionic Matsubara frequency\nω: energy \nβ: the inverse temperature \n\n\n\n\n\n","category":"method"},{"location":"lib/Lehmann/#NumericalEFT.Lehmann.Spectral.kernelT-Union{Tuple{T}, Tuple{Any, Any, AbstractVector{T}, AbstractVector{T}, T}, Tuple{Any, Any, AbstractVector{T}, AbstractVector{T}, T, Bool}} where T<:AbstractFloat","page":"Discrete Lehmann representation","title":"NumericalEFT.Lehmann.Spectral.kernelT","text":"kernelT(isFermi, symmetry, τGrid::AbstractVector{T}, ωGrid::AbstractVector{T}, β::T, regularized::Bool = false; type = T) where {T<:AbstractFloat}\n\nCompute kernel with given τ and ω grids.\n\n\n\n\n\n","category":"method"},{"location":"lib/Lehmann/#NumericalEFT.Lehmann.Spectral.kernelT-Union{Tuple{symmetry}, Tuple{isFermi}, Tuple{T}, Tuple{Val{isFermi}, Val{symmetry}, T, T, T}, Tuple{Val{isFermi}, Val{symmetry}, T, T, T, Bool}} where {T<:AbstractFloat, isFermi, symmetry}","page":"Discrete Lehmann representation","title":"NumericalEFT.Lehmann.Spectral.kernelT","text":"kernelT(::Val{isFermi}, ::Val{symmetry}, τ::T, ω::T, β::T, regularized::Bool = false) where {T<:AbstractFloat}\n\nCompute the imaginary-time kernel of different type.\n\nArguments\n\nisFermi: fermionic or bosonic. It should be wrapped as Val(isFermi).\nsymmetry: :ph, :pha, or :none. It should be wrapped as Val(symmetry).\nτ: the imaginary time, must be (-β, β]\nω: energy \nβ: the inverse temperature \nregularized: use regularized kernel or not\n\n\n\n\n\n","category":"method"},{"location":"lib/Lehmann/#NumericalEFT.Lehmann.Spectral.kernelΩ-Union{Tuple{T}, Tuple{Any, Any, Vector{Int64}, Vector{T}, T}, Tuple{Any, Any, Vector{Int64}, Vector{T}, T, Bool}} where T<:AbstractFloat","page":"Discrete Lehmann representation","title":"NumericalEFT.Lehmann.Spectral.kernelΩ","text":"kernelΩ(isFermi, symmetry, nGrid::Vector{Int}, ωGrid::Vector{T}, β::T, regularized::Bool = false; type = Complex{T}) where {T<:AbstractFloat}\n\nCompute kernel matrix with given ωn (integer!) and ω grids.\n\n\n\n\n\n","category":"method"},{"location":"lib/Lehmann/#NumericalEFT.Lehmann.Spectral.kernelΩ-Union{Tuple{symmetry}, Tuple{isFermi}, Tuple{T}, Tuple{Val{isFermi}, Val{symmetry}, Int64, T, T}, Tuple{Val{isFermi}, Val{symmetry}, Int64, T, T, Bool}} where {T<:AbstractFloat, isFermi, symmetry}","page":"Discrete Lehmann representation","title":"NumericalEFT.Lehmann.Spectral.kernelΩ","text":"kernelΩ(::Val{isFermi}, ::Val{symmetry}, n::Int, ω::T, β::T, regularized::Bool = false) where {T<:AbstractFloat}\n\nCompute the imaginary-time kernel of different type. Assume k_B Thbar=1\n\nArguments\n\nisFermi: fermionic or bosonic. It should be wrapped as Val(isFermi).\nsymmetry: :ph, :pha, or :none. It should be wrapped as Val(symmetry).\nn: index of the Matsubara frequency\nω: energy \nβ: the inverse temperature \nregularized: use regularized kernel or not\n\n\n\n\n\n","category":"method"},{"location":"lib/Lehmann/#Sample-Green's-Function-Builder","page":"Discrete Lehmann representation","title":"Sample Green's Function Builder","text":"","category":"section"},{"location":"lib/Lehmann/","page":"Discrete Lehmann representation","title":"Discrete Lehmann representation","text":"This module provides subroutines to generate Green's function samples. ","category":"page"},{"location":"lib/Lehmann/","page":"Discrete Lehmann representation","title":"Discrete Lehmann representation","text":"Modules = [Lehmann.Sample]","category":"page"},{"location":"lib/Lehmann/#NumericalEFT.Lehmann.Sample.MultiPole","page":"Discrete Lehmann representation","title":"NumericalEFT.Lehmann.Sample.MultiPole","text":"MultiPole(β, isFermi::Bool, symmetry::Symbol, Grid, type::Symbol, poles, regularized::Bool = true)\nMultiPole(dlr, type::Symbol, poles, Grid = dlrGrid(dlr, type); regularized::Bool = true)\n\nGenerate Green's function from a spectral density with delta peaks specified by the argument poles.  Return the function on Grid and the systematic error.\n\n#Arguments\n\ndlr: dlrGrid struct\nβ : inverse temperature\nisFermi: is fermionic or bosonic\nsymmetry: particle-hole symmetric :ph, particle-hole antisymmetric :pha, or :none\nGrid: grid to evalute on\ntype: imaginary-time with :τ, or Matsubara-frequency with :n\npoles: a list of frequencies for the delta functions\nregularized: use regularized bosonic kernel if symmetry = :none\n\n\n\n\n\n","category":"function"},{"location":"lib/Lehmann/#NumericalEFT.Lehmann.Sample.SemiCircle","page":"Discrete Lehmann representation","title":"NumericalEFT.Lehmann.Sample.SemiCircle","text":"SemiCircle(Euv, β, isFermi::Bool, Grid, type::Symbol, symmetry::Symbol = :none; rtol = nothing, degree = 24, regularized::Bool = true)\nSemiCircle(dlr, type::Symbol, Grid = dlrGrid(dlr, type); degree = 24, regularized::Bool = true)\n\nGenerate Green's function from a semicircle spectral density.  Return the function on Grid and the systematic error.\n\n#Arguments\n\ndlr: dlrGrid struct\nEuv : ultraviolet energy cutoff\nβ : inverse temperature\nisFermi: is fermionic or bosonic\nGrid: grid to evalute on\ntype: imaginary-time with :τ, or Matsubara-frequency with :n\nsymmetry: particle-hole symmetric :ph, particle-hole antisymmetric :pha, or :none\nrtol: accuracy to achieve\ndegree: polynomial degree for integral\nregularized: use regularized bosonic kernel if symmetry = :none\n\n\n\n\n\n","category":"function"},{"location":"lib/Lehmann/#Discrete-DLR-builder","page":"Discrete Lehmann representation","title":"Discrete DLR builder","text":"","category":"section"},{"location":"lib/Lehmann/","page":"Discrete Lehmann representation","title":"Discrete Lehmann representation","text":"This module provides a DLR builder based on the conventional QR algorithm. ","category":"page"},{"location":"lib/Lehmann/","page":"Discrete Lehmann representation","title":"Discrete Lehmann representation","text":"Modules = [Lehmann.Discrete]","category":"page"},{"location":"lib/Lehmann/#NumericalEFT.Lehmann.Discrete.build","page":"Discrete Lehmann representation","title":"NumericalEFT.Lehmann.Discrete.build","text":"function build(dlrGrid, print::Bool = true)     Construct discrete Lehmann representation\n\n#Arguments:\n\ndlrGrid: struct that contains the information to construct the DLR grid. The following entries are required:  Λ: the dimensionless scale β*Euv, rtol: the required relative accuracy, isFermi: fermionic or bosonic, symmetry: particle-hole symmetry/antisymmetry or none\nprint: print the internal information or not\n\n\n\n\n\n","category":"function"},{"location":"lib/Lehmann/#NumericalEFT.Lehmann.Discrete.preciseKernelT","page":"Discrete Lehmann representation","title":"NumericalEFT.Lehmann.Discrete.preciseKernelT","text":"function preciseKernelT(dlrGrid, τ, ω, print::Bool = true)\n\nCalculate the kernel matrix(τ, ω) for given τ, ω grids\n\nArguments\n\nτ: a CompositeChebyshevGrid struct or a simple one-dimensional array\nω: a CompositeChebyshevGrid struct or a simple one-dimensional array\nprint: print information or not\n\n\n\n\n\n","category":"function"},{"location":"lib/Lehmann/#Functional-DLR-builder","page":"Discrete Lehmann representation","title":"Functional DLR builder","text":"","category":"section"},{"location":"lib/Lehmann/","page":"Discrete Lehmann representation","title":"Discrete Lehmann representation","text":"This module provides a DLR builder based on a functional QR algorithm. It can generate DLR at extremely low temperature.","category":"page"},{"location":"lib/Lehmann/","page":"Discrete Lehmann representation","title":"Discrete Lehmann representation","text":"Modules = [Lehmann.Functional]","category":"page"},{"location":"lib/Lehmann/#NumericalEFT.Lehmann.Functional.build","page":"Discrete Lehmann representation","title":"NumericalEFT.Lehmann.Functional.build","text":"function build(dlrGrid, print::Bool = true)     Construct discrete Lehmann representation\n\n#Arguments:\n\ndlrGrid: struct that contains the information to construct the DLR grid. The following entries are required:  Λ: the dimensionless scale β*Euv, rtol: the required relative accuracy, isFermi: fermionic or bosonic, symmetry: particle-hole symmetry/antisymmetry or none\nprint: print the internal information or not\n\n\n\n\n\n","category":"function"},{"location":"lib/Lehmann/#NumericalEFT.Lehmann.Functional.kernel-Tuple{BigFloat}","page":"Discrete Lehmann representation","title":"NumericalEFT.Lehmann.Functional.kernel","text":"(1-exp(-Λ*x)/x\n\n\n\n\n\n","category":"method"},{"location":"lib/Lehmann/#NumericalEFT.Lehmann.Functional.mGramSchmidt-Tuple{Any, Any, BigFloat}","page":"Discrete Lehmann representation","title":"NumericalEFT.Lehmann.Functional.mGramSchmidt","text":"modified Gram-Schmidt process\n\n\n\n\n\n","category":"method"},{"location":"lib/Lehmann/#NumericalEFT.Lehmann.Functional.projKernel-Tuple{Any, Any}","page":"Discrete Lehmann representation","title":"NumericalEFT.Lehmann.Functional.projKernel","text":"<K(gi), K(gj)>\n\n\n\n\n\n","category":"method"},{"location":"lib/Lehmann/#NumericalEFT.Lehmann.Functional.projPHA_τ-Tuple{BigFloat, BigFloat, BigFloat}","page":"Discrete Lehmann representation","title":"NumericalEFT.Lehmann.Functional.projPHA_τ","text":"particle-hole asymmetric kernel: K(ω, τ)=e^{-ωτ}-e^{-ω(β-τ)}\n\nKK=int_0^{Λ} dτ K(ω,t1)*K(ω2,t2)=(1-e^{t1+t2})/(t1+t2)+(1-e^{2β-t1-t2})/(2β-t1-t2)-(1-e^{β+t1-t2})/(β+t1-t2)-(1-e^{β-t1+t2})/(β-t1+t2)\n\n\n\n\n\n","category":"method"},{"location":"lib/Lehmann/#NumericalEFT.Lehmann.Functional.projPHA_ω-Tuple{BigFloat, BigFloat, BigFloat}","page":"Discrete Lehmann representation","title":"NumericalEFT.Lehmann.Functional.projPHA_ω","text":"particle=hole asymmetric kernel: K(ω, τ)=e^{-ωτ}-e^{-ω(β-τ)}\n\nKK=int_0^{1/2} dτ K(ω1,τ)*K(ω2,τ)=(1-e^{ω1+ω2})/(ω1+ω2)-(e^{-ω2}-e^{-ω1})/(ω1-ω2)\n\n\n\n\n\n","category":"method"},{"location":"lib/Lehmann/#NumericalEFT.Lehmann.Functional.projPH_τ-Tuple{BigFloat, BigFloat, BigFloat}","page":"Discrete Lehmann representation","title":"NumericalEFT.Lehmann.Functional.projPH_τ","text":"particle-hole symmetric kernel: K(ω, τ)=e^{-ωτ}+e^{-ω(β-τ)}\n\nKK=int_0^{Λ} dτ K(ω,t1)*K(ω2,t2)=(1-e^{t1+t2})/(t1+t2)+(1-e^{2β-t1-t2})/(2β-t1-t2)+(1-e^{β+t1-t2})/(β+t1-t2)+(1-e^{β-t1+t2})/(β-t1+t2)\n\n\n\n\n\n","category":"method"},{"location":"lib/Lehmann/#NumericalEFT.Lehmann.Functional.projPH_ω-Tuple{BigFloat, BigFloat, BigFloat}","page":"Discrete Lehmann representation","title":"NumericalEFT.Lehmann.Functional.projPH_ω","text":"particle-hole symmetric kernel: K(ω, τ)=e^{-ωτ}+e^{-ω(β-τ)}\n\nKK=int_0^{1/2} dτ K(ω1,τ)*K(ω2,τ)=(1-e^{ω1+ω2})/(ω1+ω2)+(e^{-ω2}-e^{-ω1})/(ω1-ω2)\n\n\n\n\n\n","category":"method"},{"location":"lib/Lehmann/#NumericalEFT.Lehmann.Functional.projqq-Tuple{Any, Vector{BigFloat}, Vector{BigFloat}}","page":"Discrete Lehmann representation","title":"NumericalEFT.Lehmann.Functional.projqq","text":"q1=sumj cj Kj q2=sumk dk Kk return <q1, q2> = sumjk cj*dk <Kj, K_k>\n\n\n\n\n\n","category":"method"},{"location":"lib/Lehmann/#Utility","page":"Discrete Lehmann representation","title":"Utility","text":"","category":"section"},{"location":"lib/Lehmann/","page":"Discrete Lehmann representation","title":"Discrete Lehmann representation","text":"This module provides the utility subroutines for other DLR modules.","category":"page"},{"location":"lib/Lehmann/","page":"Discrete Lehmann representation","title":"Discrete Lehmann representation","text":"Modules = [Lehmann.Interp]","category":"page"},{"location":"lib/Lehmann/#NumericalEFT.Lehmann.Interp.barycheb-NTuple{5, Any}","page":"Discrete Lehmann representation","title":"NumericalEFT.Lehmann.Interp.barycheb","text":"function barycheb(n, x, f, wc, xc)\n\nBarycentric Lagrange interpolation at Chebyshev nodes Reference: Berrut, J.P. and Trefethen, L.N., 2004. Barycentric lagrange interpolation. SIAM review, 46(3), pp.501-517.\n\nArguments\n\nn: order of the Chebyshev interpolation\nx: coordinate to interpolate\nf: array of size n, function at the Chebyshev nodes\nwc: array of size n, Barycentric Lagrange interpolation weights\nxc: array of size n, coordinates of Chebyshev nodes\n\nReturns\n\nInterpolation result\n\n\n\n\n\n","category":"method"},{"location":"lib/Lehmann/#NumericalEFT.Lehmann.Interp.barychebinit-Tuple{Any}","page":"Discrete Lehmann representation","title":"NumericalEFT.Lehmann.Interp.barychebinit","text":"barychebinit(n)\n\nGet Chebyshev nodes of first kind and corresponding barycentric Lagrange interpolation weights.  Reference: Berrut, J.P. and Trefethen, L.N., 2004. Barycentric lagrange interpolation. SIAM review, 46(3), pp.501-517.\n\nArguments\n\nn: order of the Chebyshev interpolation\n\nReturns\n\nChebyshev nodes\nBarycentric Lagrange interpolation weights\n\n\n\n\n\n","category":"method"},{"location":"readme/Lehmann/","page":"Lehmann","title":"Lehmann","text":"CurrentModule = Lehmann","category":"page"},{"location":"readme/Lehmann/#Lehmann.jl","page":"Lehmann","title":"Lehmann.jl","text":"","category":"section"},{"location":"readme/Lehmann/","page":"Lehmann","title":"Lehmann","text":"Documentation for Lehmann.jl.","category":"page"},{"location":"readme/Lehmann/#Discrete-Lehmann-Representation-(DLR)","page":"Lehmann","title":"Discrete Lehmann Representation (DLR)","text":"","category":"section"},{"location":"readme/Lehmann/","page":"Lehmann","title":"Lehmann","text":"This package provides subroutines to represent and manuipulate Green's functions in the imaginary-time or in the Matsubara-frequency domain. ","category":"page"},{"location":"readme/Lehmann/","page":"Lehmann","title":"Lehmann","text":"Imaginary-time Green's functions encode the thermodynamic properites of quantum many-body systems. At low temperature, they are typically very singular and hard to deal with in numerical calculations. ","category":"page"},{"location":"readme/Lehmann/","page":"Lehmann","title":"Lehmann","text":"The physical Green's functions always have the analytic structure specified by the Lehmann representation,","category":"page"},{"location":"readme/Lehmann/","page":"Lehmann","title":"Lehmann","text":"G(tau)=-int_-infty^infty K(tau omega) rho(omega) d omega","category":"page"},{"location":"readme/Lehmann/","page":"Lehmann","title":"Lehmann","text":"where tau is the imaginary time, omega is the real frequency. While the spectral density rho(omega) depends on the details of the quantum many-body system, the convolution kernel K(tau omega) is universal and is roughly an exponential function exp(-omega tau). ","category":"page"},{"location":"readme/Lehmann/","page":"Lehmann","title":"Lehmann","text":"If one cares about the thermodynamic quantities, one only needs to manipulate the Green's functions. Then DLR allows us to represent the Green's function up to an accuracy epsilon with a fake spectral function only has a handful poles,","category":"page"},{"location":"readme/Lehmann/","page":"Lehmann","title":"Lehmann","text":"G(tau) approx G_mathrmDLR(tau) equiv sum_k=1^r Kleft(tau omega_kright) widehatrho_k","category":"page"},{"location":"readme/Lehmann/","page":"Lehmann","title":"Lehmann","text":"where r is called the rank of DLR. It is of the order,","category":"page"},{"location":"readme/Lehmann/","page":"Lehmann","title":"Lehmann","text":"r sim log fracE_uvT log frac1ϵ","category":"page"},{"location":"readme/Lehmann/","page":"Lehmann","title":"Lehmann","text":"where T is the temperature, E_uv is the ultraviolet energy scale beyond which the physical spectral function decays away, epsilon is the accuracy.","category":"page"},{"location":"readme/Lehmann/","page":"Lehmann","title":"Lehmann","text":"The hallmarks of DLR are the following,","category":"page"},{"location":"readme/Lehmann/","page":"Lehmann","title":"Lehmann","text":"In typical use cases, only dozens of coefficients are needed to represent the Green's functions up to the accuracy 1e-10.\nThe basis functions K(tau omega_i) are simple, explicit and analytic functions. It makes the Green's function manipulation (interpolation, fourier transform, convolution) rather simple in DLR.","category":"page"},{"location":"readme/Lehmann/#Main-Features","page":"Lehmann","title":"Main Features","text":"","category":"section"},{"location":"readme/Lehmann/","page":"Lehmann","title":"Lehmann","text":"We provide the following components to ease the numerical manipulation of the Green's functions:","category":"page"},{"location":"readme/Lehmann/","page":"Lehmann","title":"Lehmann","text":"Algorithms to generate the discrete Lehamnn representation (DLR), which is a generic and compact representation of Green's functions proposed in the Ref. [1]. In this package, two algorithms are provided: one algorithm is based on conventional QR algorithm, another is based on a functional QR algorithm. The latter extends DLR to extremely low temperature.\nDedicated DLR for Green's functions with the particle-hole symmetry (e.g. phonon propagator) or with the particle-hole antisymmetry (e.g. superconductor gap function).\nFast and accurate Fourier transform between the imaginary-time domain and the Matsubara-frequency domain with a cost sim O(log(1T)log(1ϵ)) and an accuracy ~100ϵ.\nFast and accurate Green's function interpolation with a cost sim O(log(1T)log(1ϵ)) and an accuracy ~100ϵ.\nFit a Green's function with noisy.","category":"page"},{"location":"readme/Lehmann/#Reference","page":"Lehmann","title":"Reference","text":"","category":"section"},{"location":"readme/Lehmann/","page":"Lehmann","title":"Lehmann","text":"If this library helps you to create software or publications, please let us know, and cite","category":"page"},{"location":"readme/Lehmann/","page":"Lehmann","title":"Lehmann","text":"[1] \"Discrete Lehmann representation of imaginary time Green's functions\", Jason Kaye, Kun Chen, and Olivier Parcollet, arXiv:2107.13094","category":"page"},{"location":"readme/Lehmann/","page":"Lehmann","title":"Lehmann","text":"[2] \"libdlr: Efficient imaginary time calculations using the discrete Lehmann representation\", Jason Kaye and Hugo U.R. Strand, arXiv:2110.06765","category":"page"},{"location":"#NumericalEFT","page":"Home","title":"NumericalEFT","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Numerical effective field theory toolbox for quantum many-body problem.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Stable) (Image: Dev) (Image: Build Status) (Image: codecov)","category":"page"},{"location":"#Motivation","page":"Home","title":"Motivation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Effective field theory (EFT) models the correlation functions of quantum many-body systems with an effective action defined below a certain energy/momentum scale. EFT has been widely used in high-energy physics, nuclear physics, and condensed matter physics. Originally, EFT was developed assuming the principle of locality, which states that an object is influenced directly only by its immediate surroundings. If one observes a long-range interaction between two particles (say, the Coulomb interaction between two electrons), then such interaction must be mediated by an intermediate particle called a gauge boson (the photon in the previous example).","category":"page"},{"location":"","page":"Home","title":"Home","text":"All known theories of the elementary particles in our universe are local theories, but it does not mean the local EFT rules everything. Below the energy scales most relevant for human life, the speed of light can be safely assumed to be infinite so that effective physical laws are governed by an absolute Newtonian time. In those systems, an event at one point can cause a simultaneous result at another point. The EFTs describe such systems are then nonlocal. Therefore, we create this package to extend the conventional EFT to a new frontier, namely to systematically model the quantum fields with spooky interactions with a distance.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Nonlocal and nonrelativistic EFTs are typically much more difficult to deal with than conventional EFTs. One of the major difficulties is how to make predictions with such theories. It is often not possible anymore to calculate the observables analytically. We thus develop this numerical package to solve the problem and make nonlocal EFT a practical tool for real-world applications, including the electron liquids in real materials, chiral EFT in the neutron-rich matter, and all kinds of emergent low-energy field theories in lattice models.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package NumericalEFT.jl is a collection of several independent components, which are organized in the following infrastructure: ","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: NumericalEFT)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Most of the components have been published as independent packages, and you can test or use them separately. The packages are still fast-evolving, but many are production-ready.","category":"page"},{"location":"#Core-packages:-a-set-of-self-contained-and-general-purpose-tools.","page":"Home","title":"Core packages: a set of self-contained and general-purpose tools.","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Lehmann.jl: Discrete Lehmann representation (DLR) for imaginary-time/Matsubara frequency Green's function. For a generic Green's function at a temperature T, DLR is capable of representing it up to a given accuracy ϵ with a cost ~ log(1/T)log(1/ϵ), significantly cheaper than a naive approach with a cost ~ 1/(Tϵ). \nFeynmanDiagram.jl: A mini-compiler that compiles generic multi-loop Feynman diagrams to a computational graph, which then can be efficiently manipulated or evaluated. The same type of computational graph has been the corner of neural-network-based machine learning.\nMCIntegration.jl: An adaptive Monte Carlo calculator for general high dimensional integral. It is one of the most robust and fastest Monte Carlo integration packages on the market. \nCompositeGrids.jl: Composite Cheybeshev/Gaussian/logarithmic grid systems for highly efficient one-dimensional interpolation and integration. It allows the user to combine different grids to represent nontrivial functions.\nBrillouinZoneMeshes.jl: Compact mesh systems for representing and manipulating functions defined on generic Brillouin zone in 2D or 3D. ","category":"page"},{"location":"#Toolbox-packages:-integrated-software-for-quantum-many-body-problems","page":"Home","title":"Toolbox packages: integrated software for quantum many-body problems","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"GreenFunc.jl: A software to calculate, manipulate and analyze the Green's functions and the vertex functions at the tree-level, which characterize the quantum field dynamics in the semiclassical limit ħ→0. It consists of:\nA container of generic Green's functions based on the discrete Lehmann representation and adaptive mesh systems. \nSeveral helper functions to generate typical Green's functions. For example, a set of functions to calculate the many-body Green's functions of a small cluster of Hubbard-type atoms is a small-scale exact diagonalization solver. \nImport(export) Green's function from(to) the Triqs.\nMultiLoop.jl (WIP): A software to calculate and analyze the quantum many-body effects beyond the semiclassical limit. It consists of:\nDiagrammatic Monte Carlo calculator of multi-loop Feynman diagrams of correlation functions and vertex functions. \nRenormalization technique to improve the perturbation theory.\nRenormalization Group analysis.","category":"page"},{"location":"#Applications","page":"Home","title":"Applications","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ElectronGas.jl: A package that uses the numerical EFT to explore many-fermion systems with singular interactions. It can be used to study the uniform electron gas problem, Hertz-Millis theory, etc. \nQuantumMaterials.jl (WIP): Ab-initio methods for real materials based on an effective field theory.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package has been registered. So, simply type import Pkg; Pkg.add(\"NumericalEFT\") in the Julia REPL to install.","category":"page"},{"location":"#Questions-and-Contributions","page":"Home","title":"Questions and Contributions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Contributions are very welcome, as are feature requests and suggestions. Please open an issue if you encounter any problems.","category":"page"}]
}
