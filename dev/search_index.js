var documenterSearchIndex = {"docs":
[{"location":"lib/compositegrids/#Composite-1D-Grids","page":"Composite 1D Grids","title":"Composite 1D Grids","text":"","category":"section"},{"location":"lib/compositegrids/","page":"Composite 1D Grids","title":"Composite 1D Grids","text":"Modules = [NumericalEFT.CompositeGrids]","category":"page"},{"location":"man/MC/#Important-Sampling","page":"Monte Carlo integrator","title":"Important Sampling","text":"","category":"section"},{"location":"man/MC/#Introduction","page":"Monte Carlo integrator","title":"Introduction","text":"","category":"section"},{"location":"man/MC/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"This note compares two important sampling approaches for Monte Carlo integration. The first approach introduces a normalization sector and lets the Markov chain jumps between this additional sector and the integrand sector following a calibrated probability density for important sampling. One can infer the integration between the ratio of weights between two sectors. On the other hand, the second approach reweights the original integrand to make it as flat as possible, one then perform a random walk uniformly in the parameter space to calculate the integration. This is the conventional approach used in Vegas algorithm.","category":"page"},{"location":"man/MC/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"In general, the first approach is more robust than the second one, but less efficient. In many applications, for example, high order Feynman diagrams with a sign alternation, the important sampling probability can't represent the complicated integrand well. Then the first approach is as efficient as the second one, but tends to be much robust.","category":"page"},{"location":"man/MC/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"We next present a benchmark between two approaches. Consider the MC sampling of an one-dimensional functions f(x) (its sign may oscillate).","category":"page"},{"location":"man/MC/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"We want to design an efficient algorithm to calculate the integral int_a^b dx f(x). To do that, we normalize the integrand with an ansatz g(x)0 to reduce the variant. ","category":"page"},{"location":"man/MC/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"Our package supports two important sampling schemes. ","category":"page"},{"location":"man/MC/#Approach-1:-Algorithm-with-a-Normalization-Sector","page":"Monte Carlo integrator","title":"Approach 1: Algorithm with a Normalization Sector","text":"","category":"section"},{"location":"man/MC/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"In this approach, the configuration spaces consist of two sub-spaces: the physical sector with orders nge 1 and the normalization sector with the order n=0. The weight function of the latter, g(x), should be simple enough so that the integral G=int g(x) d x is explicitly known. In our algorithm we use a constant g(x) propto 1 for simplicity. In this setup, the physical sector weight, namely the integral F = int f(x) dx, can be calculated with the equation","category":"page"},{"location":"man/MC/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"    F=fracF_rm MCG_rm MC G","category":"page"},{"location":"man/MC/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"where the MC estimators F_rm MC and G_rm MC are measured with ","category":"page"},{"location":"man/MC/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"F_rm MC =frac1N left sum_i=1^N_f fracf(x_i)rho_f(x_i) + sum_i=1^N_g 0 right","category":"page"},{"location":"man/MC/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"and","category":"page"},{"location":"man/MC/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"G_rm MC =frac1N leftsum_i=1^N_f 0 + sum_i=1^N_g fracg(x_i)rho_g(x_i)  right","category":"page"},{"location":"man/MC/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"The probability density of a given configuration is proportional to rho_f(x)=f(x) and rho_g(x)=g(x), respectively. After N MC updates, the physical sector is sampled for N_f times, and the normalization sector is for N_g times. ","category":"page"},{"location":"man/MC/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"Now we estimate the statistic error. According to the propagation of uncertainty, the variance of F  is given by","category":"page"},{"location":"man/MC/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":" fracsigma^2_FF^2 =  fracsigma_F_rm MC^2F_MC^2 + fracsigma_G_rm MC^2G_MC^2 ","category":"page"},{"location":"man/MC/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"where sigma_F_rm MC and sigma_G_rm MC are variance of the MC integration F_rm MC and G_rm MC, respectively. In the Markov chain MC, the variance of F_rm MC can be written as ","category":"page"},{"location":"man/MC/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"sigma^2_F_rm MC = frac1N left sum_i^N_f left( fracf(x_i)rho_f(x_i)- fracFZright)^2 +sum_j^N_g left(0-fracFZ right)^2  right ","category":"page"},{"location":"man/MC/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"= int left( fracf(x)rho_f(x) - fracFZ right)^2 fracrho_f(x)Z rm dx + int left( fracFZ right)^2 fracrho_g(x)Z dx ","category":"page"},{"location":"man/MC/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"=  int fracf^2(x)rho_f(x) fracdxZ -fracF^2Z^2 ","category":"page"},{"location":"man/MC/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"Here Z=Z_f+Z_g and Z_fg=int rho_fg(x)dx are the partition sums of the corresponding configuration spaces. Due to the detailed balance, one has Z_fZ_g=N_fN_g.  ","category":"page"},{"location":"man/MC/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"Similarly, the variance of G_rm MC can be written as ","category":"page"},{"location":"man/MC/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"sigma^2_G_rm MC=  int fracg^2(x)rho_g(x) fracdxZ - fracG^2Z^2","category":"page"},{"location":"man/MC/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"By substituting rho_f(x)=f(x) and  rho_g(x)=g(x), the variances of F_rm MC and G_rm MC are given by","category":"page"},{"location":"man/MC/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"sigma^2_F_rm MC= frac1Z^2 left( Z Z_f - F^2 right)","category":"page"},{"location":"man/MC/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"sigma^2_G_rm MC= frac1Z^2 left( Z Z_g - G^2 right)","category":"page"},{"location":"man/MC/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"We derive the variance of F as","category":"page"},{"location":"man/MC/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"fracsigma^2_FF^2 = fracZ cdot Z_fF^2+fracZ cdot Z_gG^2 - 2 ","category":"page"},{"location":"man/MC/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"Note that g(x)0 indicates Z_g = G,  so that","category":"page"},{"location":"man/MC/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"fracsigma^2_FF^2 = fracZ_f^2F^2+fracGcdot Z_fF^2+fracZ_fG - 1","category":"page"},{"location":"man/MC/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"Interestingly, this variance is a function of G instead of a functional of g(x). It is then possible to normalized g(x) with a constant to minimize the variance. The optimal constant makes G to be,","category":"page"},{"location":"man/MC/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"fracd sigma^2_FdG=0","category":"page"},{"location":"man/MC/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"which makes G_best = F. The minimized the variance is given by,","category":"page"},{"location":"man/MC/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"fracsigma^2_FF^2= left(fracZ_fF+1right)^2 - 2ge 0","category":"page"},{"location":"man/MC/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"The equal sign is achieved when f(x)0 is positively defined.","category":"page"},{"location":"man/MC/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"It is very important that the above analysis is based on the assumption that the autocorrelation time negligible. The autocorrelation time related to the jump between the normalization and physical sectors is controlled by the deviation of the ratio f(x)g(x) from unity. The variance sigma_F^2 given above will be amplified to sim sigma_F^2 tau where tau is the autocorrelation time.","category":"page"},{"location":"man/MC/#Approach-2:-Conventional-algorithm-(e.g.,-Vegas-algorithm)","page":"Monte Carlo integrator","title":"Approach 2: Conventional algorithm (e.g., Vegas algorithm)","text":"","category":"section"},{"location":"man/MC/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"Important sampling is actually more straightforward than the above approach. One simply sample x with a distribution rho_g(x)=g(x)Z_g, then measure the observable f(x)g(x). Therefore, the mean estimation,","category":"page"},{"location":"man/MC/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"fracFZ=int dx fracf(x)g(x) rho_g(x)","category":"page"},{"location":"man/MC/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"the variance of F in this approach is given by,","category":"page"},{"location":"man/MC/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"sigma_F^2=Z_g^2int dx left( fracf(x)g(x)- fracFZ_gright)^2rho_g(x)","category":"page"},{"location":"man/MC/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"fracsigma_F^2F^2=fracZ_gF^2int dx fracf(x)^2g(x)- 1","category":"page"},{"location":"man/MC/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"The optimal g(x) that minimizes the variance is g(x) =f(x),","category":"page"},{"location":"man/MC/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"fracsigma_F^2F^2=fracZ_f^2F^2-1","category":"page"},{"location":"man/MC/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"The variance of the conventional approach is a functional of g(x), while that of the previous approach isn't. There are two interesting limit:\nIf the f(x)0, the optimal choice g(x)=f(x) leads to zero variance. In this limit, the conventional approach is clearly much better than the previous approach.\nOn the other hand, if g(x) is far from the optimal choice f(x), say simply setting g(x)=1, one naively expect that the the conventional approach may leads to much larger variance than the previous approach. However,  this statement may not be true. If g(x) is very different from f(x), the normalization and the physical sector in the previous approach mismatch, causing large autocorrelation time and large statistical error . In contrast, the conventional approach doesn't have this problem.","category":"page"},{"location":"man/MC/#Benchmark","page":"Monte Carlo integrator","title":"Benchmark","text":"","category":"section"},{"location":"man/MC/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"To benchmark, we sample the following integral up to 10^8 updates, ","category":"page"},{"location":"man/MC/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"int_0^beta e^-(x-beta2)^2delta^2dx approx sqrtpidelta","category":"page"},{"location":"man/MC/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"where beta gg delta.","category":"page"},{"location":"man/MC/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"g(x)=f(x)","category":"page"},{"location":"man/MC/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"Normalization Sector:  doesn't lead to exact result, the variance left(fracZ_fF+1right)^2 - 2=2 doesn't change with parameters","category":"page"},{"location":"man/MC/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"beta 10 100\nresult 0.1771(1) 0.1773(1)","category":"page"},{"location":"man/MC/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"Conventional: exact result","category":"page"},{"location":"man/MC/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"g(x)=sqrtpideltabeta1","category":"page"},{"location":"man/MC/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"beta 10 100\nNormalization 0.1772(4) 0.1767(17)\nConventional 0.1777(3) 0.1767(8)","category":"page"},{"location":"man/MC/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"g(x)=exp(-(x-beta2+s)^2delta^2) with beta=100","category":"page"},{"location":"man/MC/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"s delta 2delta 3delta 4delta 5delta\nNormalization 0.1775(8) 0.1767(25) 0.1770(60) 0.176(15) 183(143)\nConventional 0.1776(5) 0.1707(39) 0.1243(174) 0.0204 (64) ","category":"page"},{"location":"man/MC/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"The conventional algorithm is not ergodic anymore for s=4delta, the acceptance ratio to update x is about 015, while the normalization algorithm becomes non ergodic for s=5delta. So the latter is slightly more stable.","category":"page"},{"location":"man/MC/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"<!– The code are ![[test.jl]] for the normalization approach and ![[test2.jl]] for the conventional approach. –>","category":"page"},{"location":"man/MC/","page":"Monte Carlo integrator","title":"Monte Carlo integrator","text":"Reference:  [1] Wang, B.Z., Hou, P.C., Deng, Y., Haule, K. and Chen, K., Fermionic sign structure of high-order Feynman diagrams in a many-fermion system. Physical Review B, 103, 115141 (2021).","category":"page"},{"location":"lib/MCintegration/#Monte-Carlo-Integrator","page":"Monte Carlo Integrator","title":"Monte Carlo Integrator","text":"","category":"section"},{"location":"lib/MCintegration/","page":"Monte Carlo Integrator","title":"Monte Carlo Integrator","text":"Modules = [NumericalEFT.MCIntegration]","category":"page"},{"location":"lib/MCintegration/#MCIntegration.Configuration","page":"Monte Carlo Integrator","title":"MCIntegration.Configuration","text":"mutable struct Configuration\n\nStruct that contains everything needed for MC.\n\nThere are three different componenets:\n\nMembers\n\nStatic parameters\n\nseed: seed to initialize random numebr generator, also serves as the unique pid of the configuration\nrng: a MersenneTwister random number generator, seeded by seed\npara: user-defined parameter, set to nothing if not needed\ntotalStep: the total number of updates for this configuration\nvar: TUPLE of variables, each variable should be derived from the abstract type Variable, see variable.jl for details). Use a tuple rather than a vector improves the performance.\n\nintegrand properties\n\nneighbor::Vector{Vector{Int}} : vectors that indicates the neighbors of each integrand. e.g., ([2, ], [1, ]) means the neighbor of the first integrand is the second one, while the neighbor of the second integrand is the first.    There is a MC update proposes to jump from one integrand to another. If these two integrands' degrees of freedom are very different, then the update is unlikely to be accepted. To avoid this problem, one can specify neighbor to guide the update. \nBy default, we assume the N integrands are in the increase order, meaning the neighbor will be set to ([N+1, 2], [1, 3], [2, 4], ..., [N-1,], [1, ]), where the first N entries are for diagram 1, 2, ..., N and the last entry is for the normalization diagram. Only the first diagram is connected to the normalization diagram.\ndof::Vector{Vector{Int}}: degrees of freedom of each integrand, e.g., [[0, 1], [2, 3]] means the first integrand has zero var#1 and one var#2; while the second integrand has two var#1 and 3 var#2. \nobservable: observables that is required to calculate the integrands, will be used in the measure function call.   It is either an array of any type with the common operations like +-*/^ defined. \nreweight: reweight factors for each integrands. The reweight factor of the normalization diagram is assumed to be 1. Note that you don't need to explicitly add the normalization diagram. \nvisited: how many times this integrand is visited by the Markov chain.\n\ncurrent MC state\n\nstep: the number of MC updates performed up to now\ncurr: the current integrand, initialize with 1\nnorm: the index of the normalization diagram. norm is larger than the index of any user-defined integrands \nnormalization: the accumulated normalization factor. Physical observable = Configuration.observable/Configuration.normalization.\nabsWeight: the abolute weight of the current integrand. User is responsible to initialize it after the contructor is called.\npropose/accept: array to store the proposed and accepted updates for each integrands and variables.  Their shapes are (number of updates X integrand number X max(integrand number, variable number).  The last index will waste some memory, but the dimension is small anyway.\n\n\n\n\n\n","category":"type"},{"location":"lib/MCintegration/#MCIntegration.create!-Tuple{MCIntegration.Angle, Int64, Any}","page":"Monte Carlo Integrator","title":"MCIntegration.create!","text":"create!(theta::Angle, idx::Int, rng=GLOBAL_RNG)\n\nPropose to generate new angle (uniformly) randomly in [0, 2π), return proposal probability\n\nArguments\n\ntheta:  angle variable\nidx: theta.t[idx] will be updated\n\n\n\n\n\n","category":"method"},{"location":"lib/MCintegration/#MCIntegration.create!-Tuple{MCIntegration.Continuous, Int64, Any}","page":"Monte Carlo Integrator","title":"MCIntegration.create!","text":"create!(T::Continuous, idx::Int, rng=GLOBAL_RNG)\n\nPropose to generate new (uniform) variable randomly in [T.lower, T.lower+T.range), return proposal probability\n\nArguments\n\nT:  Continuous variable\nidx: T.data[idx] will be updated\n\n\n\n\n\n","category":"method"},{"location":"lib/MCintegration/#MCIntegration.create!-Tuple{MCIntegration.Discrete, Int64, Any}","page":"Monte Carlo Integrator","title":"MCIntegration.create!","text":"createIdx!(newIdx::Int, size::Int, rng=GLOBAL_RNG)\n\nPropose to generate new index (uniformly) randomly in [1, size]\n\nArguments\n\nnewIdx:  index ∈ [1, size]\nsize : up limit of the index\nrng=GLOBAL_RNG : random number generator\n\n\n\n\n\n","category":"method"},{"location":"lib/MCintegration/#MCIntegration.create!-Tuple{MCIntegration.RadialFermiK, Int64, Any}","page":"Monte Carlo Integrator","title":"MCIntegration.create!","text":"create!(K::RadialFermiK, idx::Int, rng=GLOBAL_RNG)\n\nPropose to generate new k randomly in [0, +inf), return proposal probability k is generated uniformly on [0, K.kF-K.δk), Lorentzianly on [K.kF-K.δk,K.kF+K.δk), and exponentially on [K.kF-K.δk, +inf).\n\nArguments\n\nK:  k variable\nidx: K.data[idx] will be updated\n\n\n\n\n\n","category":"method"},{"location":"lib/MCintegration/#MCIntegration.create!-Tuple{MCIntegration.Tau, Int64, Any}","page":"Monte Carlo Integrator","title":"MCIntegration.create!","text":"create!(T::Tau, idx::Int, rng=GLOBAL_RNG)\n\nPropose to generate new tau (uniformly) randomly in [0, β), return proposal probability\n\nArguments\n\nT:  Tau variable\nidx: T.data[idx] will be updated\n\n\n\n\n\n","category":"method"},{"location":"lib/MCintegration/#MCIntegration.create!-Tuple{MCIntegration.TauPair, Int64, Any}","page":"Monte Carlo Integrator","title":"MCIntegration.create!","text":"create!(T::TauPair, idx::Int, rng=GLOBAL_RNG)\n\nPropose to generate a new pair of tau (uniformly) randomly in [0, β), return proposal probability\n\nArguments\n\nT:  TauPair variable\nidx: T.data[idx] will be updated\n\n\n\n\n\n","category":"method"},{"location":"lib/MCintegration/#MCIntegration.create!-Union{Tuple{D}, Tuple{MCIntegration.FermiK{D}, Int64, Any}} where D","page":"Monte Carlo Integrator","title":"MCIntegration.create!","text":"create!(K::FermiK{D}, idx::Int, rng=GLOBAL_RNG)\n\nPropose to generate new Fermi K in [Kf-δK, Kf+δK)\n\nArguments\n\nnewK:  vector of dimension of d=2 or 3\n\n\n\n\n\n","category":"method"},{"location":"lib/MCintegration/#MCIntegration.remove!-Tuple{MCIntegration.Angle, Int64, Any}","page":"Monte Carlo Integrator","title":"MCIntegration.remove!","text":"remove(theta::Angle, idx::Int, rng=GLOBAL_RNG)\n\nPropose to remove old theta in [0, 2π), return proposal probability\n\nArguments\n\n- `theta`:  Tau variable\n\nidx: theta.t[idx] will be updated\n\n\n\n\n\n","category":"method"},{"location":"lib/MCintegration/#MCIntegration.remove!-Tuple{MCIntegration.Continuous, Int64, Any}","page":"Monte Carlo Integrator","title":"MCIntegration.remove!","text":"remove(T::Continuous, idx::Int, rng=GLOBAL_RNG)\n\nPropose to remove old variable in [T.lower, T.lower+T.range), return proposal probability\n\nArguments\n\nT:  Continuous variable\nidx: T.data[idx] will be updated\n\n\n\n\n\n","category":"method"},{"location":"lib/MCintegration/#MCIntegration.remove!-Tuple{MCIntegration.Discrete, Int64, Any}","page":"Monte Carlo Integrator","title":"MCIntegration.remove!","text":"removeIdx!(newIdx::Int, size::Int, rng=GLOBAL_RNG)\n\nPropose to remove the old index in [1, size]\n\nArguments\n\noldIdx:  index ∈ [1, size]\nsize : up limit of the index\nrng=GLOBAL_RNG : random number generator\n\n\n\n\n\n","category":"method"},{"location":"lib/MCintegration/#MCIntegration.remove!-Tuple{MCIntegration.RadialFermiK, Int64, Any}","page":"Monte Carlo Integrator","title":"MCIntegration.remove!","text":"remove(K::RadialFermiK, idx::Int, rng=GLOBAL_RNG)\n\nPropose to remove old k in [0, +inf), return proposal probability\n\nArguments\n\nK:  K variable\nidx: K.data[idx] will be updated\n\n\n\n\n\n","category":"method"},{"location":"lib/MCintegration/#MCIntegration.remove!-Tuple{MCIntegration.Tau, Int64, Any}","page":"Monte Carlo Integrator","title":"MCIntegration.remove!","text":"remove(T::Tau, idx::Int, rng=GLOBAL_RNG)\n\nPropose to remove old tau in [0, β), return proposal probability\n\nArguments\n\nT:  Tau variable\nidx: T.data[idx] will be updated\n\n\n\n\n\n","category":"method"},{"location":"lib/MCintegration/#MCIntegration.remove!-Tuple{MCIntegration.TauPair, Int64, Any}","page":"Monte Carlo Integrator","title":"MCIntegration.remove!","text":"remove(T::TauPair, idx::Int, rng=GLOBAL_RNG)\n\nPropose to remove an existing pair of tau in [0, β), return proposal probability\n\nArguments\n\nT:  Tau variable\nidx: T.data[idx] will be updated\n\n\n\n\n\n","category":"method"},{"location":"lib/MCintegration/#MCIntegration.remove!-Union{Tuple{D}, Tuple{MCIntegration.FermiK{D}, Int64, Any}} where D","page":"Monte Carlo Integrator","title":"MCIntegration.remove!","text":"removeFermiK!(oldK, Kf=1.0, δK=0.5, rng=GLOBAL_RNG)\n\nPropose to remove an existing Fermi K in [Kf-δK, Kf+δK)\n\nArguments\n\noldK:  vector of dimension of d=2 or 3\n\n\n\n\n\n","category":"method"},{"location":"lib/MCintegration/#MCIntegration.sample-Tuple{Configuration, Function, Function}","page":"Monte Carlo Integrator","title":"MCIntegration.sample","text":"sample(config::Configuration, integrand::Function, measure::Function; Nblock=16, print=0, printio=stdout, save=0, saveio=nothing, timer=[])\n\nsample the integrands, collect statistics, and return the expected values and errors.\n\nRemarks\n\nUser may run the MC in parallel using MPI. Simply run mpiexec -n N julia userscript.jl where N is the number of workers. In this mode, only the root process returns meaningful results. All other workers return nothing, nothing. User is responsible to handle the returning results properly. If you have multiple number of mpi version, you can use \"mpiexecjl\" in your \"~/.julia/package/MPI/###/bin\" to make sure the version is correct. See https://juliaparallel.github.io/MPI.jl/stable/configuration/ for more detail.\nIn the MC, a normalization diagram is introduced to normalize the MC estimates of the integrands. More information can be found in the link: https://kunyuan.github.io/QuantumStatistics.jl/dev/man/important_sampling/#Important-Sampling. User don't need to explicitly specify this normalization diagram.Internally, normalization diagram will be added to each table that is related to the integrands.\n\nArguments\n\nconfig: Configuration struct\nintegrand: function call to evaluate the integrand. It should accept an argument of the type Configuration, and return a weight.   Internally, MC only samples the absolute value of the weight. Therefore, it is also important to define Main.abs for the weight if its type is user-defined. \nmeasure: function call to measure. It should accept an argument of the type Configuration, then manipulate observables obs. \nNblock: repeat times. The tasks will automatically distributed to multi-process in MPI mode.\nprint: -1 to not print anything, 0 to print minimal information, >0 to print summary for every print seconds\nprintio: io to print the information\nsave: -1 to not save anything, 0 to save observables obs in the end of sampling, >0 to save observables obs for every save seconds\nsaveio: io to save\ntimer: StopWatch other than print and save.\nreweight = config.totalStep/10: the MC steps before reweighting the integrands. Set to -1 if reweighting is not wanted.\n\n\n\n\n\n","category":"method"},{"location":"lib/MCintegration/#MCIntegration.shift!-Tuple{MCIntegration.Angle, Int64, Any}","page":"Monte Carlo Integrator","title":"MCIntegration.shift!","text":"shift!(theta::Angle, idx::Int, rng=GLOBAL_RNG)\n\nPropose to shift the old theta to new theta, both in [0, 2π), return proposal probability\n\nArguments\n\ntheta:  angle variable\nidx: theta.t[idx] will be updated\n\n\n\n\n\n","category":"method"},{"location":"lib/MCintegration/#MCIntegration.shift!-Tuple{MCIntegration.Continuous, Int64, Any}","page":"Monte Carlo Integrator","title":"MCIntegration.shift!","text":"shift!(T::Continuous, idx::Int, rng=GLOBAL_RNG)\n\nPropose to shift an existing variable to a new one, both in [T.lower, T.lower+T.range), return proposal probability\n\nArguments\n\nT:  Continuous variable\nidx: T.data[idx] will be updated\n\n\n\n\n\n","category":"method"},{"location":"lib/MCintegration/#MCIntegration.shift!-Tuple{MCIntegration.Discrete, Int64, Any}","page":"Monte Carlo Integrator","title":"MCIntegration.shift!","text":"shiftIdx!(oldIdx::Int, newIdx::Int, size::Int, rng=GLOBAL_RNG)\n\nPropose to shift the old index in [1, size] to a new index\n\nArguments\n\noldIdx:  old index ∈ [1, size]\nnewIdx:  new index ∈ [1, size], will be modified!\nsize : up limit of the index\nrng=GLOBAL_RNG : random number generator\n\n\n\n\n\n","category":"method"},{"location":"lib/MCintegration/#MCIntegration.shift!-Tuple{MCIntegration.RadialFermiK, Int64, Any}","page":"Monte Carlo Integrator","title":"MCIntegration.shift!","text":"shift!(K::RadialFermiK, idx::Int, rng=GLOBAL_RNG)\n\nPropose to shift an existing k to a new k, both in [0, +inf), return proposal probability\n\nArguments\n\nK:  K variable\nidx: K.data[idx] will be updated\n\n\n\n\n\n","category":"method"},{"location":"lib/MCintegration/#MCIntegration.shift!-Tuple{MCIntegration.Tau, Int64, Any}","page":"Monte Carlo Integrator","title":"MCIntegration.shift!","text":"shift!(T::Tau, idx::Int, rng=GLOBAL_RNG)\n\nPropose to shift an existing tau to a new tau, both in [0, β), return proposal probability\n\nArguments\n\nT:  Tau variable\nidx: T.data[idx] will be updated\n\n\n\n\n\n","category":"method"},{"location":"lib/MCintegration/#MCIntegration.shift!-Tuple{MCIntegration.TauPair, Int64, Any}","page":"Monte Carlo Integrator","title":"MCIntegration.shift!","text":"shift!(T::TauPair, idx::Int, rng=GLOBAL_RNG)\n\nPropose to shift an existing tau pair to a new tau pair, both in [0, β), return proposal probability\n\nArguments\n\nT:  Tau variable\nidx: T.t[idx] will be updated\n\n\n\n\n\n","category":"method"},{"location":"lib/MCintegration/#MCIntegration.shift!-Union{Tuple{D}, Tuple{MCIntegration.FermiK{D}, Int64, Any}} where D","page":"Monte Carlo Integrator","title":"MCIntegration.shift!","text":"shiftK!(oldK, newK, step, rng=GLOBAL_RNG)\n\nPropose to shift oldK to newK. Work for generic momentum vector\n\n\n\n\n\n","category":"method"},{"location":"lib/Feynmandiagram/#Feynman-Diagram","page":"Feynman Diagram","title":"Feynman Diagram","text":"","category":"section"},{"location":"lib/Feynmandiagram/","page":"Feynman Diagram","title":"Feynman Diagram","text":"Modules = [NumericalEFT.FeynmanDiagram]","category":"page"},{"location":"lib/Feynmandiagram/#FeynmanDiagram.innerTauNum-Tuple{FeynmanDiagram.DiagramType, Any, Any}","page":"Feynman Diagram","title":"FeynmanDiagram.innerTauNum","text":"function innerTauNum(diagType::DiagramType, innerLoopNum, interactionTauNum)\n\ninternal imaginary-time degrees of freedom for a given diagram type and internal loop number.\nFor the vertex functions (self-energy, polarization, vertex3, and vertex4), innerTauNum is equivalent to tauNum.\nFor the Green function, tauNum = innerTauNum + external tauNum\n\n\n\n\n\n","category":"method"},{"location":"man/DLR/","page":"Discrete Lehmann Representation","title":"Discrete Lehmann Representation","text":"CurrentModule = Lehmann","category":"page"},{"location":"man/DLR/#Lehmann.jl","page":"Discrete Lehmann Representation","title":"Lehmann.jl","text":"","category":"section"},{"location":"man/DLR/","page":"Discrete Lehmann Representation","title":"Discrete Lehmann Representation","text":"Documentation for Lehmann.jl.","category":"page"},{"location":"man/DLR/#Discrete-Lehmann-Representation-(DLR)","page":"Discrete Lehmann Representation","title":"Discrete Lehmann Representation (DLR)","text":"","category":"section"},{"location":"man/DLR/","page":"Discrete Lehmann Representation","title":"Discrete Lehmann Representation","text":"This package provides subroutines to represent and manuipulate Green's functions in the imaginary-time or in the Matsubara-frequency domain. ","category":"page"},{"location":"man/DLR/","page":"Discrete Lehmann Representation","title":"Discrete Lehmann Representation","text":"Imaginary-time Green's functions encode the thermodynamic properites of quantum many-body systems. At low temperature, they are typically very singular and hard to deal with in numerical calculations. ","category":"page"},{"location":"man/DLR/","page":"Discrete Lehmann Representation","title":"Discrete Lehmann Representation","text":"The physical Green's functions always have the analytic structure specified by the Lehmann representation,","category":"page"},{"location":"man/DLR/","page":"Discrete Lehmann Representation","title":"Discrete Lehmann Representation","text":"G(tau)=-int_-infty^infty K(tau omega) rho(omega) d omega","category":"page"},{"location":"man/DLR/","page":"Discrete Lehmann Representation","title":"Discrete Lehmann Representation","text":"where tau is the imaginary time, omega is the real frequency. While the spectral density rho(omega) depends on the details of the quantum many-body system, the convolution kernel K(tau omega) is universal and is roughly an exponential function exp(-omega tau). ","category":"page"},{"location":"man/DLR/","page":"Discrete Lehmann Representation","title":"Discrete Lehmann Representation","text":"If one cares about the thermodynamic quantities, one only needs to manipulate the Green's functions. Then DLR allows us to represent the Green's function up to an accuracy epsilon with a fake spectral function only has a handful poles,","category":"page"},{"location":"man/DLR/","page":"Discrete Lehmann Representation","title":"Discrete Lehmann Representation","text":"G(tau) approx G_mathrmDLR(tau) equiv sum_k=1^r Kleft(tau omega_kright) widehatrho_k","category":"page"},{"location":"man/DLR/","page":"Discrete Lehmann Representation","title":"Discrete Lehmann Representation","text":"where r is called the rank of DLR. It is of the order,","category":"page"},{"location":"man/DLR/","page":"Discrete Lehmann Representation","title":"Discrete Lehmann Representation","text":"r sim log fracE_uvT log frac1ϵ","category":"page"},{"location":"man/DLR/","page":"Discrete Lehmann Representation","title":"Discrete Lehmann Representation","text":"where T is the temperature, E_uv is the ultraviolet energy scale beyond which the physical spectral function decays away, epsilon is the accuracy.","category":"page"},{"location":"man/DLR/","page":"Discrete Lehmann Representation","title":"Discrete Lehmann Representation","text":"The hallmarks of DLR are the following,","category":"page"},{"location":"man/DLR/","page":"Discrete Lehmann Representation","title":"Discrete Lehmann Representation","text":"In typical use cases, only dozens of coefficients are needed to represent the Green's functions up to the accuracy 1e-10.\nThe basis functions K(tau omega_i) are simple, explicit and analytic functions. It makes the Green's function manipulation (interpolation, fourier transform, convolution) rather simple in DLR.","category":"page"},{"location":"man/DLR/#Main-Features","page":"Discrete Lehmann Representation","title":"Main Features","text":"","category":"section"},{"location":"man/DLR/","page":"Discrete Lehmann Representation","title":"Discrete Lehmann Representation","text":"We provide the following components to ease the numerical manipulation of the Green's functions:","category":"page"},{"location":"man/DLR/","page":"Discrete Lehmann Representation","title":"Discrete Lehmann Representation","text":"Algorithms to generate the discrete Lehamnn representation (DLR), which is a generic and compact representation of Green's functions proposed in the Ref. [1]. In this package, two algorithms are provided: one algorithm is based on conventional QR algorithm, another is based on a functional QR algorithm. The latter extends DLR to extremely low temperature.\nDedicated DLR for Green's functions with the particle-hole symmetry (e.g. phonon propagator) or with the particle-hole antisymmetry (e.g. superconductor gap function).\nFast and accurate Fourier transform between the imaginary-time domain and the Matsubara-frequency domain with a cost sim O(log(1T)log(1ϵ)) and an accuracy ~100ϵ.\nFast and accurate Green's function interpolation with a cost sim O(log(1T)log(1ϵ)) and an accuracy ~100ϵ.\nFit a Green's function with noisy.","category":"page"},{"location":"man/DLR/#Reference","page":"Discrete Lehmann Representation","title":"Reference","text":"","category":"section"},{"location":"man/DLR/","page":"Discrete Lehmann Representation","title":"Discrete Lehmann Representation","text":"If this library helps you to create software or publications, please let us know, and cite","category":"page"},{"location":"man/DLR/","page":"Discrete Lehmann Representation","title":"Discrete Lehmann Representation","text":"[1] \"Discrete Lehmann representation of imaginary time Green's functions\", Jason Kaye, Kun Chen, and Olivier Parcollet, arXiv:2107.13094","category":"page"},{"location":"man/DLR/","page":"Discrete Lehmann Representation","title":"Discrete Lehmann Representation","text":"[2] \"libdlr: Efficient imaginary time calculations using the discrete Lehmann representation\", Jason Kaye and Hugo U.R. Strand, arXiv:2110.06765","category":"page"},{"location":"lib/fastmath/#Fast-Math-Functions","page":"Fast Math Functions","title":"Fast Math Functions","text":"","category":"section"},{"location":"lib/fastmath/","page":"Fast Math Functions","title":"Fast Math Functions","text":"Modules = [NumericalEFT.FastMath]","category":"page"},{"location":"lib/fastmath/#NumericalEFT.FastMath","page":"Fast Math Functions","title":"NumericalEFT.FastMath","text":"Provide a set of fast math functions\n\n\n\n\n\n","category":"module"},{"location":"lib/fastmath/#NumericalEFT.FastMath.invsqrt-Tuple{Float64}","page":"Fast Math Functions","title":"NumericalEFT.FastMath.invsqrt","text":"invsqrt(x)\n\nThe Legendary Fast Inverse Square Root See the following links: wikipedia and thesis\n\n\n\n\n\n","category":"method"},{"location":"man/kernel/#Convention","page":"Lehmann representation convention","title":"Convention","text":"","category":"section"},{"location":"man/kernel/","page":"Lehmann representation convention","title":"Lehmann representation convention","text":"The kernel in the Lehammn representation is a function that only depends on the statistics of the quantum particles, and the symmetry of the Green's function. It is universal in the sense that it doesn't depend on the microscopic details of the quantum many-body system. ","category":"page"},{"location":"man/kernel/","page":"Lehmann representation convention","title":"Lehmann representation convention","text":"The definition of the kernel is not unique. Here we give the defintion in this package.","category":"page"},{"location":"man/kernel/","page":"Lehmann representation convention","title":"Lehmann representation convention","text":"We use the following conventions:","category":"page"},{"location":"man/kernel/","page":"Lehmann representation convention","title":"Lehmann representation convention","text":"Temperature T .\nInverse temperature beta= 1T.\nReal frequency omega.\nImaginary time tau.\nMatsubara frequancy iomega_n. \nFor the fermonic case, omega_n = (2n+1)pi T. \nFor the bosonic case,  omega_n = 2npi T\nFermionic Green's function is antiperiodic G(tau)=-G(beta+tau). \nBosonic one is periodic G(tau)=G(beta+tau). \nDon't confuse the periodicity with the time-reversal symmetry (a.k.a, particle-hole symmetry). \nFourier transform follows the convention in the book \"Quantum Many-particle Systems\" by J. Negele and H. Orland, Page 95,","category":"page"},{"location":"man/kernel/","page":"Lehmann representation convention","title":"Lehmann representation convention","text":"G(tau) = frac1beta sum_n G(iomega_n) texte^-iomega_n tau","category":"page"},{"location":"man/kernel/","page":"Lehmann representation convention","title":"Lehmann representation convention","text":"G(iomega_n) = int_0^beta G(tau) texte^iomega_n tau dtau","category":"page"},{"location":"man/kernel/#Fermion-without-Symmetry","page":"Lehmann representation convention","title":"Fermion without Symmetry","text":"","category":"section"},{"location":"man/kernel/","page":"Lehmann representation convention","title":"Lehmann representation convention","text":"Imaginary time ","category":"page"},{"location":"man/kernel/","page":"Lehmann representation convention","title":"Lehmann representation convention","text":"K(τ ω) = frace^-ωτ1+e^-ωβ","category":"page"},{"location":"man/kernel/","page":"Lehmann representation convention","title":"Lehmann representation convention","text":"Matusbara frequency ","category":"page"},{"location":"man/kernel/","page":"Lehmann representation convention","title":"Lehmann representation convention","text":"K(τ iω_n) = -frac1iω_n-ω","category":"page"},{"location":"man/kernel/#Boson-without-Symmetry","page":"Lehmann representation convention","title":"Boson without Symmetry","text":"","category":"section"},{"location":"man/kernel/","page":"Lehmann representation convention","title":"Lehmann representation convention","text":"We use a bosonic kernel with a regularator near omega =. The imaginary-time kernel happens to be the same as the fermionic kernel. The details can be found in Appendix A of this DLR paper. ","category":"page"},{"location":"man/kernel/","page":"Lehmann representation convention","title":"Lehmann representation convention","text":"Imaginary time ","category":"page"},{"location":"man/kernel/","page":"Lehmann representation convention","title":"Lehmann representation convention","text":"K(τ ω) = frace^-ωτ1+e^-ωβ","category":"page"},{"location":"man/kernel/","page":"Lehmann representation convention","title":"Lehmann representation convention","text":"Matusbara frequency ","category":"page"},{"location":"man/kernel/","page":"Lehmann representation convention","title":"Lehmann representation convention","text":"K(τ iω_n) = -frac1iω_n-ωfrac1-e^-ωβ1+e^-ωβ","category":"page"},{"location":"man/kernel/#Fermion-with-the-Particle-hole-Symmetry","page":"Lehmann representation convention","title":"Fermion with the Particle-hole Symmetry","text":"","category":"section"},{"location":"man/kernel/","page":"Lehmann representation convention","title":"Lehmann representation convention","text":"Particle-hole symmetry means the time reversal symmetry, so that G(tau)=G(beta-tau).","category":"page"},{"location":"man/kernel/","page":"Lehmann representation convention","title":"Lehmann representation convention","text":"Imaginary time","category":"page"},{"location":"man/kernel/","page":"Lehmann representation convention","title":"Lehmann representation convention","text":"K(τ ω) = e^-ωτ+e^-ω(β-τ)","category":"page"},{"location":"man/kernel/","page":"Lehmann representation convention","title":"Lehmann representation convention","text":"Matusbara frequency","category":"page"},{"location":"man/kernel/","page":"Lehmann representation convention","title":"Lehmann representation convention","text":"K(iω_n ω) = frac2iω_nω^2+ω_n^2(1+e^-ωβ)","category":"page"},{"location":"man/kernel/#Boson-with-the-Particle-hole-Symmetry","page":"Lehmann representation convention","title":"Boson with the Particle-hole Symmetry","text":"","category":"section"},{"location":"man/kernel/","page":"Lehmann representation convention","title":"Lehmann representation convention","text":"Particle-hole symmetry means the time reversal symmetry, so that G(tau)=G(beta-tau).","category":"page"},{"location":"man/kernel/","page":"Lehmann representation convention","title":"Lehmann representation convention","text":"Imaginary time","category":"page"},{"location":"man/kernel/","page":"Lehmann representation convention","title":"Lehmann representation convention","text":"K(τ ω) = e^-ωτ+e^-ω(β-τ)","category":"page"},{"location":"man/kernel/","page":"Lehmann representation convention","title":"Lehmann representation convention","text":"Matusbara frequency","category":"page"},{"location":"man/kernel/","page":"Lehmann representation convention","title":"Lehmann representation convention","text":"K(iω_n ω) = frac2ωω^2+ω_n^2(1-e^-ωβ)","category":"page"},{"location":"man/kernel/#Fermion-with-the-Particle-hole-Anti-Symmetry","page":"Lehmann representation convention","title":"Fermion with the Particle-hole Anti-Symmetry","text":"","category":"section"},{"location":"man/kernel/","page":"Lehmann representation convention","title":"Lehmann representation convention","text":"Particle-hole antisymmetry means the time reversal symmetry, so that G(tau)=-G(beta-tau).","category":"page"},{"location":"man/kernel/","page":"Lehmann representation convention","title":"Lehmann representation convention","text":"Imaginary time","category":"page"},{"location":"man/kernel/","page":"Lehmann representation convention","title":"Lehmann representation convention","text":"K(τ ω) = e^-ωτ-e^-ω(β-τ)","category":"page"},{"location":"man/kernel/","page":"Lehmann representation convention","title":"Lehmann representation convention","text":"Matusbara frequency","category":"page"},{"location":"man/kernel/","page":"Lehmann representation convention","title":"Lehmann representation convention","text":"K(iω_n ω) = frac2ωω^2+ω_n^2(1+e^-ωβ)","category":"page"},{"location":"man/kernel/#Boson-with-the-Particle-hole-Anti-Symmetry","page":"Lehmann representation convention","title":"Boson with the Particle-hole Anti-Symmetry","text":"","category":"section"},{"location":"man/kernel/","page":"Lehmann representation convention","title":"Lehmann representation convention","text":"Particle-hole antisymmetry means the time reversal symmetry, so that G(tau)=-G(beta-tau).","category":"page"},{"location":"man/kernel/","page":"Lehmann representation convention","title":"Lehmann representation convention","text":"Imaginary time","category":"page"},{"location":"man/kernel/","page":"Lehmann representation convention","title":"Lehmann representation convention","text":"K(τ ω) = e^-ωτ-e^-ω(β-τ)","category":"page"},{"location":"man/kernel/","page":"Lehmann representation convention","title":"Lehmann representation convention","text":"Matusbara frequency","category":"page"},{"location":"man/kernel/","page":"Lehmann representation convention","title":"Lehmann representation convention","text":"K(iω_n ω) = frac2iω_nω^2+ω_n^2(1-e^-ωβ)","category":"page"},{"location":"man/important_sampling/#Important-Sampling","page":"Important Sampling","title":"Important Sampling","text":"","category":"section"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"Consider the MC sampling of an one-dimensional functions f(x) (its sign may oscillate).","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"We want to design an efficient algorithm to calculate the integral int_a^b dx f(x). To do that, we normalize the integrand with an ansatz g(x)0 to reduce the variant. ","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"Our package supports two important sampling schemes. ","category":"page"},{"location":"man/important_sampling/#Approach-1:-Algorithm-with-a-Normalization-Section","page":"Important Sampling","title":"Approach 1: Algorithm with a Normalization Section","text":"","category":"section"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"In this approach, the configuration spaces consist of two sub-spaces: the physical sector with orders nge 1 and the normalization sector with the order n=0. The weight function of the latter, g(x), should be simple enough so that the integral G=int g(x) d x is explicitly known. In our algorithm we use a constant g(x) propto 1 for simplicity. In this setup, the physical sector weight, namely the integral F = int f(x) dx, can be calculated with the equation","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"    F=fracF_rm MCG_rm MC G","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"where the MC estimators F_rm MC and G_rm MC are measured with ","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"F_rm MC =frac1N left sum_i=1^N_f fracf(x_i)rho_f(x_i) + sum_i=1^N_g 0 right","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"and","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"G_rm MC =frac1N leftsum_i=1^N_f 0 + sum_i=1^N_g fracg(x_i)rho_g(x_i)  right","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"The probability density of a given configuration is proportional to rho_f(x)=f(x) and rho_g(x)=g(x), respectively. After N MC updates, the physical sector is sampled for N_f times, and the normalization sector is for N_g times. ","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"Now we estimate the statistic error. According to the propagation of uncertainty, the variance of F  is given by","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":" fracsigma^2_FF^2 =  fracsigma_F_rm MC^2F_MC^2 + fracsigma_G_rm MC^2G_MC^2 ","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"where sigma_F_rm MC and sigma_G_rm MC are variance of the MC integration F_rm MC and G_rm MC, respectively. In the Markov chain MC, the variance of F_rm MC can be written as ","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"sigma^2_F_rm MC = frac1N left sum_i^N_f left( fracf(x_i)rho_f(x_i)- fracFZright)^2 +sum_j^N_g left(0-fracFZ right)^2  right ","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"= int left( fracf(x)rho_f(x) - fracFZ right)^2 fracrho_f(x)Z rm dx + int left( fracFZ right)^2 fracrho_g(x)Z dx ","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"=  int fracf^2(x)rho_f(x) fracdxZ -fracF^2Z^2 ","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"Here Z=Z_f+Z_g and Z_fg=int rho_fg(x)dx are the partition sums of the corresponding configuration spaces. Due to the detailed balance, one has Z_fZ_g=N_fN_g.  ","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"Similarly, the variance of G_rm MC can be written as ","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"sigma^2_G_rm MC=  int fracg^2(x)rho_g(x) fracrm dxZ - fracG^2Z^2","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"By substituting rho_f(x)=f(x) and  rho_g(x)=g(x), the variances of F_rm MC and G_rm MC are given by","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"sigma^2_F_rm MC= frac1Z^2 left( Z Z_f - F^2 right)","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"sigma^2_G_rm MC= frac1Z^2 left( Z Z_g - G^2 right)","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"We derive the variance of F as","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"fracsigma^2_FF^2 = fracZ cdot Z_fF^2+fracZ cdot Z_gG^2 - 2 ","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"Note that g(x)0 indicates Z_g = G,  so that","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"fracsigma^2_FF^2 = fracZ_f^2F^2+fracGcdot Z_fF^2+fracZ_fG - 1","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"Interestingly, this variance is a function of G instead of a functional of g(x). It is then possible to normalized g(x) with a constant to minimize the variance. The optimal constant makes G to be,","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"fracd sigma^2_FdG=0","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"which makes G_best = F. The minimized the variance is given by,","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"fracsigma^2_FF^2= left(fracZ_fF+1right)^2 - 2ge 0","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"The equal sign is achieved when f(x)0 is positively defined.","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"It is very important that the above analysis is based on the assumption that the autocorrelation time negligible. The autocorrelation time related to the jump between the normalization and physical sectors is controlled by the deviation of the ratio f(x)g(x) from unity. The variance sigma_F^2 given above will be amplified to sim sigma_F^2 tau where tau is the autocorrelation time.","category":"page"},{"location":"man/important_sampling/#Approach-2:-Conventional-algorithm-(e.g.,-Vegas-algorithm)","page":"Important Sampling","title":"Approach 2: Conventional algorithm (e.g., Vegas algorithm)","text":"","category":"section"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"Important sampling is actually more straightforward than the above approach. One simply sample x with a distribution rho_g(x)=g(x)Z_g, then measure the observable f(x)g(x). Therefore, the mean estimation,","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"fracFZ=int dx fracf(x)g(x) rho_g(x)","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"the variance of F in this approach is given by,","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"sigma_F^2=Z_g^2int dx left( fracf(x)g(x)- fracFZ_gright)^2rho_g(x)","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"fracsigma_F^2F^2=fracZ_gF^2int dx fracf(x)^2g(x)- 1","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"The optimal g(x) that minimizes the variance is g(x) =f(x),","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"fracsigma_F^2F^2=fracZ_f^2F^2-1","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"The variance of the conventional approach is a functional of g(x), while that of the previous approach isn't. There are two interesting limit:\nIf the f(x)0, the optimal choice g(x)=f(x) leads to zero variance. In this limit, the conventional approach is clearly much better than the previous approach.\nOn the other hand, if g(x) is far from the optimal choice f(x), say simply setting g(x)=1, one naively expect that the the conventional approach may leads to much larger variance than the previous approach. However,  this statement may not be true. If g(x) is very different from f(x), the normalization and the physical sector in the previous approach mismatch, causing large autocorrelation time and large statistical error . In contrast, the conventional approach doesn't have this problem.","category":"page"},{"location":"man/important_sampling/#Benchmark","page":"Important Sampling","title":"Benchmark","text":"","category":"section"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"To benchmark, we sample the following integral up to 10^8 updates, ","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"int_0^beta e^-(x-beta2)^2delta^2dx approx sqrtpidelta","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"where beta gg delta.","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"g(x)=f(x)","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"Normalization Sector:  doesn't lead to exact result, the variance left(fracZ_fF+1right)^2 - 2=2 doesn't change with parameters","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"beta 10 100\nresult 0.1771(1) 0.1773(1)","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"Conventional: exact result","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"g(x)=sqrtpideltabeta1","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"beta 10 100\nNormalization 0.1772(4) 0.1767(17)\nConventional 0.1777(3) 0.1767(8)","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"g(x)=exp(-(x-beta2+s)^2delta^2) with beta=100","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"s delta 2delta 3delta 4delta 5delta\nNormalization 0.1775(8) 0.1767(25) 0.1770(60) 0.176(15) 183(143)\nConventional 0.1776(5) 0.1707(39) 0.1243(174) 0.0204 (64) ","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"The conventional algorithm is not ergodic anymore for s=4delta, the acceptance ratio to update x is about 015, while the normalization algorithm becomes non ergodic for s=5delta. So the latter is slightly more stable.","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"<!– The code are ![[test.jl]] for the normalization approach and ![[test2.jl]] for the conventional approach. –>","category":"page"},{"location":"man/important_sampling/","page":"Important Sampling","title":"Important Sampling","text":"Reference:  [1] Wang, B.Z., Hou, P.C., Deng, Y., Haule, K. and Chen, K., Fermionic sign structure of high-order Feynman diagrams in a many-fermion system. Physical Review B, 103, 115141 (2021).","category":"page"},{"location":"lib/greenfunc/#Green's-Function","page":"Green's Function","title":"Green's Function","text":"","category":"section"},{"location":"lib/greenfunc/","page":"Green's Function","title":"Green's Function","text":"Modules = [NumericalEFT.GreenFunc]","category":"page"},{"location":"lib/greenfunc/#GreenFunc.Green2DLR","page":"Green's Function","title":"GreenFunc.Green2DLR","text":"Green's function with two external legs that has in-built Discrete Lehmann Representation. #Parameters:\n\n'T': type of data\n'TType': type of time domain, TType<:TimeDomain\n'TGT': type of time grid\n'SGT': type of space grid\n\n#Members:\n\n'name': Name of green's function\n'color': Number of different species of Green's function (such as different spin values)\n'dlrGrid': In-built Discrete Lehmann Representation\n'timeGrid': Time or Frequency grid\n'spaceType': Whether the Green's function is in coordinate space/momentum space\n'spaceGrid': Coordinate or momentum grid\n'instant': Instantaneous part of Green's function that is proportional to δ(τ) in τ space.\n'dynamic': Dynamic part of Green's function\n'instantError': Error of instantaneous part\n'dynamicError': Error of dynamic part\n\n\n\n\n\n","category":"type"},{"location":"lib/greenfunc/#GreenFunc.dynamic-Union{Tuple{SM}, Tuple{TM}, Tuple{SGT}, Tuple{TGT}, Tuple{TT}, Tuple{DT}, Tuple{Green2DLR{DT, TT, TGT, SGT}, Any, Any, Int64, Int64, TM, SM}} where {DT, TT, TGT<:CompositeGrids.SimpleG.AbstractGrid, SGT<:CompositeGrids.SimpleG.AbstractGrid, TM, SM}","page":"Green's Function","title":"GreenFunc.dynamic","text":"function dynamic(green::Green2DLR{DT,TT,TGT,SGT}, time, space, color1::Int, color2::Int, timeMethod::TM , spaceMethod::SM) where {DT,TT,TGT<:CompositeGrids.AbstractGrid,SGT<:CompositeGrids.AbstractGrid,TM,SM}\n\nFind value of Green's function's dynamic part at given color and k/x by interpolation. Interpolation method is by default depending on the grid, but could also be chosen to be linear.\n\n#Argument\n\n'green': Green's function\n'time': Target τ/ω_n point\n'space': Target k/x point\n'color1': Target color1\n'color2': Target color2\n'timeMethod': Method of interpolation for time\n'spaceMethod': Method of interpolation for space \n\n\n\n\n\n","category":"method"},{"location":"lib/greenfunc/#GreenFunc.instant-Union{Tuple{SM}, Tuple{SGT}, Tuple{TGT}, Tuple{TT}, Tuple{DT}, Tuple{Green2DLR{DT, TT, TGT, SGT}, Any, Int64}, Tuple{Green2DLR{DT, TT, TGT, SGT}, Any, Int64, Int64}} where {DT, TT, TGT, SGT, SM}","page":"Green's Function","title":"GreenFunc.instant","text":"function instant(green::Green2DLR{DT,TT,TGT,SGT}, space, color1::Int, color2::Int=color1; spaceMethod::SM = DEFAULTINTERP) where {DT,TT,TGT,SGT,SM}\n\nFind value of Green's function's instant part at given color and k/x by interpolation. Interpolation method is by default depending on the grid, but could also be chosen to be linear.\n\n#Argument\n\n'green': Green's function\n'space': Target k/x point\n'color1': Target color1\n'color2': Target color2\n'spaceMethod': Method of interpolation for space. \n\n\n\n\n\n","category":"method"},{"location":"lib/greenfunc/#GreenFunc.toDLR-Tuple{Green2DLR}","page":"Green's Function","title":"GreenFunc.toDLR","text":"function toDLR(green::Green2DLR)\n\nConvert Green's function to dlr space.\n\n#Arguements\n\n'green': Original Green's function\n\n\n\n\n\n","category":"method"},{"location":"lib/greenfunc/#GreenFunc.toMatFreq","page":"Green's Function","title":"GreenFunc.toMatFreq","text":"function toMatFreq(green::Green2DLR, targetGrid =  green.dlrGrid.n)\n\nConvert Green's function to matfreq space by Fourier transform. If green is already in matfreq space then it will be interpolated to the new grid.\n\n#Arguements\n\n'green': Original Green's function\n'targetGrid': Grid of outcome Green's function. Default: DLR n grid\n\n\n\n\n\n","category":"function"},{"location":"lib/greenfunc/#GreenFunc.toTau","page":"Green's Function","title":"GreenFunc.toTau","text":"function toTau(green::Green2DLR, targetGrid =  green.dlrGrid.τ)\n\nConvert Green's function to τ space by Fourier transform. If green is already in τ space then it will be interpolated to the new grid.\n\n#Arguements\n\n'green': Original Green's function\n'targetGrid': Grid of outcome Green's function. Default: DLR τ grid\n\n\n\n\n\n","category":"function"},{"location":"lib/utility/#Utility","page":"Utility","title":"Utility","text":"","category":"section"},{"location":"lib/utility/","page":"Utility","title":"Utility","text":"Modules = [NumericalEFT.Utility]","category":"page"},{"location":"lib/utility/#NumericalEFT.Utility","page":"Utility","title":"NumericalEFT.Utility","text":"Utility data structures and functions\n\n\n\n\n\n","category":"module"},{"location":"lib/utility/#NumericalEFT.Utility.StopWatch","page":"Utility","title":"NumericalEFT.Utility.StopWatch","text":"StopWatch(start, interval, callback)\n\nInitialize a stopwatch. \n\nArguments\n\nstart::Float64: initial time (in seconds)\ninterval::Float64 : interval to click (in seconds)\ncallback : callback function after each click (interval seconds)\n\n\n\n\n\n","category":"type"},{"location":"lib/utility/#NumericalEFT.Utility.check-Tuple{NumericalEFT.Utility.StopWatch, Vararg{Any}}","page":"Utility","title":"NumericalEFT.Utility.check","text":"check(stopwatch, parameter...)\n\nCheck stopwatch. If it clicks, call the callback function with the unpacked parameter\n\n\n\n\n\n","category":"method"},{"location":"lib/utility/#NumericalEFT.Utility.progressBar-Tuple{Any, Any}","page":"Utility","title":"NumericalEFT.Utility.progressBar","text":"progressBar(step, total)\n\nReturn string of progressBar (step/total*100%)\n\n\n\n\n\n","category":"method"},{"location":"lib/Lehmann/#Discrete-Lehmann-representation","page":"Discrete Lehmann representation","title":"Discrete Lehmann representation","text":"","category":"section"},{"location":"lib/Lehmann/","page":"Discrete Lehmann representation","title":"Discrete Lehmann representation","text":"Modules = [NumericalEFT.Lehmann]","category":"page"},{"location":"lib/Lehmann/#Lehmann.DLRGrid","page":"Discrete Lehmann representation","title":"Lehmann.DLRGrid","text":"struct DLRGrid\n\nDLR grids for imaginary-time/Matsubara frequency correlators\n\n#Members:\n\nisFermi: bool is fermionic or bosonic\nsymmetry: particle-hole symmetric :ph, or particle-hole asymmetric :pha, or :none\nEuv : the UV energy scale of the spectral density \nβ : inverse temeprature\nΛ: cutoff = UV Energy scale of the spectral density * inverse temperature\nrtol: tolerance absolute error\nsize : number of DLR basis\nω : selected representative real-frequency grid\nn : selected representative Matsubara-frequency grid (integer)\nωn : (2n+1)π/β\nτ : selected representative imaginary-time grid\n\n\n\n\n\n","category":"type"},{"location":"lib/Lehmann/#Base.size-Tuple{DLRGrid}","page":"Discrete Lehmann representation","title":"Base.size","text":"Base.size(dlrGrid::DLRGrid) = length(dlrGrid.ω) Base.length(dlrGrid::DLRGrid) = length(dlrGrid.ω) rank(dlrGrid::DLRGrid) = length(dlrGrid.ω)\n\nget the rank of the DLR grid, namely the number of the DLR coefficients.\n\n\n\n\n\n","category":"method"},{"location":"lib/Lehmann/#Lehmann.dlr2matfreq","page":"Discrete Lehmann representation","title":"Lehmann.dlr2matfreq","text":"function dlr2matfreq(dlrGrid::DLRGrid, dlrcoeff, nGrid = dlrGrid.n; axis = 1, verbose = true)\n\nDLR representation to Matsubara-frequency representation\n\n#Members:\n\ndlrGrid  : DLRGrid\ndlrcoeff : DLR coefficients\nnGrid    : expected fine Matsubara-freqeuncy grids (integer)\naxis     : Matsubara-frequency axis in the data dlrcoeff\nverbose  : true to print warning information\n\n\n\n\n\n","category":"function"},{"location":"lib/Lehmann/#Lehmann.dlr2tau","page":"Discrete Lehmann representation","title":"Lehmann.dlr2tau","text":"function dlr2tau(dlrGrid::DLRGrid, dlrcoeff, τGrid = dlrGrid.τ; axis = 1, verbose = true)\n\nDLR representation to imaginary-time representation\n\n#Members:\n\ndlrGrid  : DLRGrid\ndlrcoeff : DLR coefficients\nτGrid    : expected fine imaginary-time grids \naxis     : imaginary-time axis in the data dlrcoeff\nverbose  : true to print warning information\n\n\n\n\n\n","category":"function"},{"location":"lib/Lehmann/#Lehmann.matfreq2dlr","page":"Discrete Lehmann representation","title":"Lehmann.matfreq2dlr","text":"function matfreq2dlr(dlrGrid::DLRGrid, green, nGrid = dlrGrid.n; error = nothing, axis = 1, sumrule = nothing, verbose = true)\n\nMatsubara-frequency representation to DLR representation\n\n#Members:\n\ndlrGrid  : DLRGrid struct.\ngreen    : green's function in Matsubara-frequency domain\nnGrid    : the n grid that Green's function is defined on. \nerror    : error the Green's function. \naxis     : the Matsubara-frequency axis in the data green\nsumrule  : enforce the sum rule \nverbose  : true to print warning information\n\n\n\n\n\n","category":"function"},{"location":"lib/Lehmann/#Lehmann.matfreq2matfreq","page":"Discrete Lehmann representation","title":"Lehmann.matfreq2matfreq","text":"function matfreq2matfreq(dlrGrid, green, nNewGrid, nGrid = dlrGrid.n; error = nothing, axis = 1, sumrule = nothing, verbose = true)\n\nFourier transform from Matsubara-frequency to imaginary-time using the DLR representation\n\n#Members:\n\ndlrGrid  : DLRGrid\ngreen    : green's function in Matsubara-freqeuncy repsentation\nnNewGrid : expected fine Matsubara-freqeuncy grids (integer)\nnGrid    : the n grid that Green's function is defined on. \nerror    : error the Green's function. \naxis     : Matsubara-frequency axis in the data green\nsumrule  : enforce the sum rule \nverbose  : true to print warning information\n\n\n\n\n\n","category":"function"},{"location":"lib/Lehmann/#Lehmann.matfreq2tau","page":"Discrete Lehmann representation","title":"Lehmann.matfreq2tau","text":"function matfreq2tau(dlrGrid, green, τNewGrid = dlrGrid.τ, nGrid = dlrGrid.n; error = nothing, axis = 1, sumrule = nothing, verbose = true)\n\nFourier transform from Matsubara-frequency to imaginary-time using the DLR representation\n\n#Members:\n\ndlrGrid  : DLRGrid\ngreen    : green's function in Matsubara-freqeuncy repsentation\nτNewGrid : expected fine imaginary-time grids\nnGrid    : the n grid that Green's function is defined on. \nerror    : error the Green's function. \naxis     : Matsubara-frequency axis in the data green\nsumrule  : enforce the sum rule \nverbose  : true to print warning information\n\n\n\n\n\n","category":"function"},{"location":"lib/Lehmann/#Lehmann.tau2dlr","page":"Discrete Lehmann representation","title":"Lehmann.tau2dlr","text":"function tau2dlr(dlrGrid::DLRGrid, green, τGrid = dlrGrid.τ; error = nothing, axis = 1, sumrule = nothing, verbose = true)\n\nimaginary-time domain to DLR representation\n\n#Members:\n\ndlrGrid  : DLRGrid struct.\ngreen    : green's function in imaginary-time domain.\nτGrid    : the imaginary-time grid that Green's function is defined on. \nerror    : error the Green's function. \naxis     : the imaginary-time axis in the data green.\nsumrule  : enforce the sum rule \nverbose  : true to print warning information\n\n\n\n\n\n","category":"function"},{"location":"lib/Lehmann/#Lehmann.tau2matfreq","page":"Discrete Lehmann representation","title":"Lehmann.tau2matfreq","text":"function tau2matfreq(dlrGrid, green, nNewGrid = dlrGrid.n, τGrid = dlrGrid.τ; error = nothing, axis = 1, sumrule = nothing, verbose = true)\n\nFourier transform from imaginary-time to Matsubara-frequency using the DLR representation\n\n#Members:\n\ndlrGrid  : DLRGrid\ngreen    : green's function in imaginary-time domain\nnNewGrid : expected fine Matsubara-freqeuncy grids (integer)\nτGrid    : the imaginary-time grid that Green's function is defined on. \nerror    : error the Green's function. \naxis     : the imaginary-time axis in the data green\nsumrule  : enforce the sum rule \nverbose  : true to print warning information\n\n\n\n\n\n","category":"function"},{"location":"lib/Lehmann/#Lehmann.tau2tau","page":"Discrete Lehmann representation","title":"Lehmann.tau2tau","text":"function tau2tau(dlrGrid, green, τNewGrid, τGrid = dlrGrid.τ; error = nothing, axis = 1, sumrule = nothing, verbose = true)\n\nInterpolation from the old imaginary-time grid to a new grid using the DLR representation\n\n#Members:\n\ndlrGrid  : DLRGrid\ngreen    : green's function in imaginary-time domain\nτNewGrid : expected fine imaginary-time grids\nτGrid    : the imaginary-time grid that Green's function is defined on. \nerror    : error the Green's function. \naxis     : the imaginary-time axis in the data green\nsumrule  : enforce the sum rule \nverbose  : true to print warning information\n\n\n\n\n\n","category":"function"},{"location":"#NumericalEFT.jl","page":"Home","title":"NumericalEFT.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Numerical effective field theory toolbox for quantum many-body problem.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Stable) (Image: Dev) (Image: Build Status) (Image: codecov)","category":"page"},{"location":"#Motivation","page":"Home","title":"Motivation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Collective modes of quantum many-body systems are often well described by weakly-interacting quantum fields. Effective field theory (EFT) is a framework to systematically study such problems. EFT has been widely used in high-energy physics, nuclear physics and condensed matter physics. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"For quantum material applications, EFTs are often too complicated to calculate with bare hands. Therefore, we are motivated to create a numerical package for such problems.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Potential applications of this package are the electron liquids and superconductors in real materials, chiral EFT in neutron-rich matter, and all kinds of emergent low-energy field theories in lattice models.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package NumericalEFTjl is a collection of loosely coupled components. They are organized in the following infrastructure: ","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: NumericalEFT)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Most of the components have been published as independent packages, so that user has the freedom to try them separately. The package is in development stage. Many components are still missing. Here we list the components that are ready for applications:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Lehmann.jl: Discrete Lehmann representation (DLR) for imaginary-time/Matsubara frequency Green's function. For a generic Green's function at a temperature T, DLR is capable of representing it up to a given accuracy ϵ with a cost ~ log(1/T)log(1/ϵ), signicantly cheaper than a naive approach with a cost ~ 1/(Tϵ). \nFeynmanDiagram.jl: High-order Feynman diagram builder for general quantum many-body systems. The diagrams are compiled into an expression tree for subsequent efficient evaluations using a MC integrator. It Supports propagator/interaction renormalization, which is important for renormalization group analysis. \nMCIntegration.jl: An adapative Monte Carlo calculator for general high dimensional integral. It is particularly suitable to calculate multiple integrals that are strongly correlated, for example, the Feynman diagrams. \nCompositeGrids.jl: Composite Cheybeshev/Gaussian/logarithmic grid systems for one-dimensional interpolation and integration. It allows the user to combine different grids to represent one highly non-smooth functions.\nGreenFunc.jl: A container for generic Green's functions.","category":"page"},{"location":"#Questions-and-Contributions","page":"Home","title":"Questions and Contributions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Contributions are very welcome, as are feature requests and suggestions. Please open an issue if you encounter any problems.","category":"page"}]
}
