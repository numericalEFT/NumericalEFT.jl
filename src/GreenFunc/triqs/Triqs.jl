module Triqs

export from_triqs

import ..MeshArray
import ..MeshGrids
import ..BrillouinZoneMeshes

using PythonCall

function _get_statistics(mesh)
    statis = pyconvert(String, mesh.statistic)
    if (statis == "Fermion")
        stat = true
    else # Boson or other
        stat = false
    end
    return stat
end

function _get_mesh_from_triqs(triqs_mesh)
    gf = pyimport("triqs.gf")
    ############ load time/freq mesh #############
    if pyisinstance(triqs_mesh, gf.meshes.MeshImTime)
        β = pyconvert(Float64, triqs_mesh.beta)
        stat = _get_statistics(triqs_mesh)
        grid_t = pyconvert(Vector, triqs_mesh.values())
        tgrid = MeshGrids.ImTime(β, stat, grid=grid_t)
        return tgrid
    elseif pyisinstance(triqs_mesh, gf.meshes.MeshImFreq)
        β = pyconvert(Float64, triqs_mesh.beta)
        stat = _get_statistics(triqs_mesh)
        grid_first_index = pyconvert(Int32, triqs_mesh.first_index())
        grid_last_index = pyconvert(Int32, triqs_mesh.last_index())
        grid_t = [grid_first_index:grid_last_index;]
        tgrid = MeshGrids.ImFreq(β, stat, grid=grid_t)
        return tgrid
    elseif pyisinstance(triqs_mesh, gf.meshes.MeshBrZone)
        # when import from python, linear_index remain consistent
        # while cartesian index and order of lattice vector reversed
        mkdims = pyconvert(Array, triqs_mesh.dims)
        mkunits = pyconvert(Array, triqs_mesh.units)
        DIM = count(i -> (i != 1), mkdims) # actual dimension of the grid
        nk = mkdims[1]
        latvec = pyconvert(Array, mkunits)[1:DIM, 1:DIM]' .* nk
        latvec = reverse(latvec, dims=2)
        umesh = BrillouinZoneMeshes.BaseMesh.UniformMesh{DIM,nk,BrillouinZoneMeshes.BaseMesh.EdgedMesh}([0.0, 0.0], latvec)
        return umesh
    elseif pyisinstance(triqs_mesh, gf.mesh_product.MeshProduct)
        # expand MeshProduct to a tuple
        rank = pyconvert(Int, triqs_mesh.rank)
        mlist = Tuple(_get_mesh_from_triqs(triqs_mesh[i-1]) for i in rank:-1:1)
        return MeshGrids.MeshProduct(mlist...)
    else
        error("Unknown mesh type:", pytype(triqs_mesh))
    end
end

function _check_Gf(obj::Py, gf)
    # gf should be generated by gf = pyimport("triqs.gf")
    gtype = [gf.gf.Gf, gf.backwd_compat.gf_imfreq.GfImFreq,
        gf.backwd_compat.gf_imtime.GfImTime, gf.backwd_compat.gf_retime.GfReTime]
    for gt in gtype
        if pyisinstance(obj, gt)
            return true
        end
    end
    return false
end

function _check_BlockGf(obj::Py, gf)
    # gf should be generated by gf = pyimport("triqs.gf")
    return pyisinstance(obj, gf.BlockGf)
end

function _check_mesh(obj::Py, gf)
    # gf should be generated by gf = pyimport("triqs.gf")
    # supported mesh type from triqs
    meshtype = [gf.meshes.MeshImTime, gf.meshes.MeshImFreq,
        gf.meshes.MeshBrZone, gf.mesh_product.MeshProduct,
        gf.meshes.MeshReFreq, gf.meshes.MeshReTime]
    for mesh in meshtype
        if pyisinstance(obj, mesh)
            return true
        end
    end
    return false
end

"""
    function MeshArray(objSrc::Py)
    
Convert a Green's function object from triqs to a MeshArray.
"""
function MeshArray(objSrc::Py)
    # println(objSrc)
    @assert _check_Gf(objSrc, pyimport("triqs.gf")) "Not a Green's function object"
    innerstate = pyconvert(Tuple, objSrc.target_shape)
    # @assert innerstate == dims[1:length(innerstate)] "Inner state dimensions do not match!"
    mesh = (1:state for state in innerstate[end:-1:1])
    triqmesh = _get_mesh_from_triqs(objSrc.mesh)
    if isa(triqmesh, MeshGrids.MeshProduct)
        mesh = (mesh..., triqmesh.meshes...)
    else
        mesh = (mesh..., triqmesh)
    end
    _data = PyArray(objSrc.data, copy=false) #no copy is made, but PyArray will be in column-major 
    # g = MeshArray(mesh...; dtype=Float64)
    # TODO: read data type from python
    g = MeshArray(mesh...; dtype=eltype(_data)) # tprf_rpa produce complex
    for i in 1:length(g)
        g.data[i] = unsafe_load(_data.ptr, i) #read data from pointer
    end
    return g
end

"""
    function from_triqs(pyobj::Py)
    
Convert a triqs object to a julia object. Currently support the following types:

1. Triqs Mesh (ImTime, ImFreq, MeshProduct) -> MeshGrids (ImTime, ImFreq, MeshProduct)
2. Triqs Green's function (Gf, GfImTime, GfImFreq)  -> MeshArray
3. Triqs BlockGf -> Dict{String, MeshArray}
"""
function from_triqs(pyobj::Py)
    gf = pyimport("triqs.gf")
    if _check_mesh(pyobj, gf)
        return _get_mesh_from_triqs(pyobj)
    elseif _check_Gf(pyobj, gf)
        return MeshArray(pyobj)
    elseif _check_BlockGf(pyobj, gf)
        # unfortunately BlockDiagonal only supports matrix type
        glist = [MeshArray(g[1]) for g in pyobj] # g = ("name", Gf)
        namelist = [pyconvert(String, g[0]) for g in pyobj]
        gdict = Dict{eltype(namelist),eltype(glist)}()
        for (ni, name) in enumerate(namelist)
            gdict[name] = glist[ni]
        end
        return gdict
        # return BlockDiagonal(glist)
    else
        error("Unknown type of triqs object: ", pytype(pyobj))
    end

end


function Base.:<<(obj::MeshArray{T,N,MT}, objSrc::Py) where {T,MT,N}
    @assert obj.dims[end:-1:1] == pyconvert(Tuple, objSrc.data.shape) "Dimensions do not match! Expect $(obj.dims[end:-1:1]), got $(objSrc.data.shape)."
    _data = PyArray(objSrc.data, copy=false) #no copy is made, but PyArray will be in column-major 
    for i in 1:length(obj)
        obj.data[i] = unsafe_load(_data.ptr, i) #read data from pointer
    end
    return obj
end

# function Base.:<<(obj::MeshArray{T,N,MT}, objSrc::Py) where {T,MT,N}

#     innerstate = pyconvert(Tuple, objSrc.target_shape)
#     @assert innerstate == dims[1:length(innerstate)] "Inner state dimensions do not match!"

#     β = pyconvert(Float64, objSrc.mesh.beta)
#     statis = pyconvert(String, objSrc.mesh.statistic)
#     if (statis == "Fermion")
#         stat = MeshGrids.FERMI
#     elseif (statis == "Boson")
#         stat = MeshGrids.BOSE
#     else
#         stat = MeshGrids.UNKNOWN
#     end
#     if pyisinstance(objSrc.mesh, gf.meshes.MeshImTime)
#         grid_t = pyconvert(Vector, objSrc.mesh.values())
#         tgrid = GreenFunc.MeshGrids.ImTime(β, stat, grid=grid_t)
#     elseif pyisinstance(objSrc.mesh, gf.meshes.MeshImFreq)
#         grid_first_index = pyconvert(Int32, objSrc.mesh.first_index())
#         grid_last_index = pyconvert(Int32, objSrc.mesh.last_index())
#         grid_t = [grid_first_index:grid_last_index;]
#         tgrid = GreenFunc.MeshGrids.ImFreq(β, stat, grid=grid_t)
#     else
#         error("Unknown mesh type")
#     end
#     data_t = pyconvert(Array, objSrc.data)
#     obj.mesh = ()
#     return Obj = GreenFunc.MeshArray(tgrid, 1:tar_sh[1], 1:tar_sh[2], dtype=eltype(data_t), data=data_t)
# end

end
